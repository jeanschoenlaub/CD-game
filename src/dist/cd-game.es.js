import * as Yt from "react";
import Cg, { useReducer as x2, useRef as Us, useDebugValue as S2, useEffect as $u, useLayoutEffect as M2, useState as b2, useMemo as gE } from "react";
function yE(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var tx = { exports: {} }, zh = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mb;
function w2() {
  if (Mb)
    return zh;
  Mb = 1;
  var u = Cg, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, r = u.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function c(f, h, m) {
    var g, _ = {}, x = null, M = null;
    m !== void 0 && (x = "" + m), h.key !== void 0 && (x = "" + h.key), h.ref !== void 0 && (M = h.ref);
    for (g in h)
      n.call(h, g) && !s.hasOwnProperty(g) && (_[g] = h[g]);
    if (f && f.defaultProps)
      for (g in h = f.defaultProps, h)
        _[g] === void 0 && (_[g] = h[g]);
    return { $$typeof: e, type: f, key: x, ref: M, props: _, _owner: r.current };
  }
  return zh.Fragment = t, zh.jsx = c, zh.jsxs = c, zh;
}
var Oh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bb;
function E2() {
  return bb || (bb = 1, process.env.NODE_ENV !== "production" && function() {
    var u = Cg, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), f = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), _ = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), M = Symbol.for("react.offscreen"), b = Symbol.iterator, E = "@@iterator";
    function w(U) {
      if (U === null || typeof U != "object")
        return null;
      var Q = b && U[b] || U[E];
      return typeof Q == "function" ? Q : null;
    }
    var R = u.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function A(U) {
      {
        for (var Q = arguments.length, se = new Array(Q > 1 ? Q - 1 : 0), Ve = 1; Ve < Q; Ve++)
          se[Ve - 1] = arguments[Ve];
        P("error", U, se);
      }
    }
    function P(U, Q, se) {
      {
        var Ve = R.ReactDebugCurrentFrame, at = Ve.getStackAddendum();
        at !== "" && (Q += "%s", se = se.concat([at]));
        var mt = se.map(function(nt) {
          return String(nt);
        });
        mt.unshift("Warning: " + Q), Function.prototype.apply.call(console[U], console, mt);
      }
    }
    var N = !1, I = !1, B = !1, W = !1, z = !1, k;
    k = Symbol.for("react.module.reference");
    function G(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === n || U === s || z || U === r || U === m || U === g || W || U === M || N || I || B || typeof U == "object" && U !== null && (U.$$typeof === x || U.$$typeof === _ || U.$$typeof === c || U.$$typeof === f || U.$$typeof === h || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === k || U.getModuleId !== void 0));
    }
    function $(U, Q, se) {
      var Ve = U.displayName;
      if (Ve)
        return Ve;
      var at = Q.displayName || Q.name || "";
      return at !== "" ? se + "(" + at + ")" : se;
    }
    function oe(U) {
      return U.displayName || "Context";
    }
    function ne(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && A("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case s:
          return "Profiler";
        case r:
          return "StrictMode";
        case m:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case f:
            var Q = U;
            return oe(Q) + ".Consumer";
          case c:
            var se = U;
            return oe(se._context) + ".Provider";
          case h:
            return $(U, U.render, "ForwardRef");
          case _:
            var Ve = U.displayName || null;
            return Ve !== null ? Ve : ne(U.type) || "Memo";
          case x: {
            var at = U, mt = at._payload, nt = at._init;
            try {
              return ne(nt(mt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ee = Object.assign, ye = 0, Me, De, V, J, Y, de, le;
    function Pe() {
    }
    Pe.__reactDisabledLog = !0;
    function We() {
      {
        if (ye === 0) {
          Me = console.log, De = console.info, V = console.warn, J = console.error, Y = console.group, de = console.groupCollapsed, le = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: Pe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        ye++;
      }
    }
    function $e() {
      {
        if (ye--, ye === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ee({}, U, {
              value: Me
            }),
            info: ee({}, U, {
              value: De
            }),
            warn: ee({}, U, {
              value: V
            }),
            error: ee({}, U, {
              value: J
            }),
            group: ee({}, U, {
              value: Y
            }),
            groupCollapsed: ee({}, U, {
              value: de
            }),
            groupEnd: ee({}, U, {
              value: le
            })
          });
        }
        ye < 0 && A("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ve = R.ReactCurrentDispatcher, gt;
    function ot(U, Q, se) {
      {
        if (gt === void 0)
          try {
            throw Error();
          } catch (at) {
            var Ve = at.stack.trim().match(/\n( *(at )?)/);
            gt = Ve && Ve[1] || "";
          }
        return `
` + gt + U;
      }
    }
    var _t = !1, Qe;
    {
      var At = typeof WeakMap == "function" ? WeakMap : Map;
      Qe = new At();
    }
    function Ne(U, Q) {
      if (!U || _t)
        return "";
      {
        var se = Qe.get(U);
        if (se !== void 0)
          return se;
      }
      var Ve;
      _t = !0;
      var at = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var mt;
      mt = ve.current, ve.current = null, We();
      try {
        if (Q) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (fn) {
              Ve = fn;
            }
            Reflect.construct(U, [], nt);
          } else {
            try {
              nt.call();
            } catch (fn) {
              Ve = fn;
            }
            U.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (fn) {
            Ve = fn;
          }
          U();
        }
      } catch (fn) {
        if (fn && Ve && typeof fn.stack == "string") {
          for (var ht = fn.stack.split(`
`), Ct = Ve.stack.split(`
`), Mt = ht.length - 1, Ut = Ct.length - 1; Mt >= 1 && Ut >= 0 && ht[Mt] !== Ct[Ut]; )
            Ut--;
          for (; Mt >= 1 && Ut >= 0; Mt--, Ut--)
            if (ht[Mt] !== Ct[Ut]) {
              if (Mt !== 1 || Ut !== 1)
                do
                  if (Mt--, Ut--, Ut < 0 || ht[Mt] !== Ct[Ut]) {
                    var Dn = `
` + ht[Mt].replace(" at new ", " at ");
                    return U.displayName && Dn.includes("<anonymous>") && (Dn = Dn.replace("<anonymous>", U.displayName)), typeof U == "function" && Qe.set(U, Dn), Dn;
                  }
                while (Mt >= 1 && Ut >= 0);
              break;
            }
        }
      } finally {
        _t = !1, ve.current = mt, $e(), Error.prepareStackTrace = at;
      }
      var oi = U ? U.displayName || U.name : "", Ui = oi ? ot(oi) : "";
      return typeof U == "function" && Qe.set(U, Ui), Ui;
    }
    function we(U, Q, se) {
      return Ne(U, !1);
    }
    function ke(U) {
      var Q = U.prototype;
      return !!(Q && Q.isReactComponent);
    }
    function rt(U, Q, se) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return Ne(U, ke(U));
      if (typeof U == "string")
        return ot(U);
      switch (U) {
        case m:
          return ot("Suspense");
        case g:
          return ot("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case h:
            return we(U.render);
          case _:
            return rt(U.type, Q, se);
          case x: {
            var Ve = U, at = Ve._payload, mt = Ve._init;
            try {
              return rt(mt(at), Q, se);
            } catch {
            }
          }
        }
      return "";
    }
    var Xe = Object.prototype.hasOwnProperty, wt = {}, St = R.ReactDebugCurrentFrame;
    function pt(U) {
      if (U) {
        var Q = U._owner, se = rt(U.type, U._source, Q ? Q.type : null);
        St.setExtraStackFrame(se);
      } else
        St.setExtraStackFrame(null);
    }
    function kt(U, Q, se, Ve, at) {
      {
        var mt = Function.call.bind(Xe);
        for (var nt in U)
          if (mt(U, nt)) {
            var ht = void 0;
            try {
              if (typeof U[nt] != "function") {
                var Ct = Error((Ve || "React class") + ": " + se + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ct.name = "Invariant Violation", Ct;
              }
              ht = U[nt](Q, nt, Ve, se, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Mt) {
              ht = Mt;
            }
            ht && !(ht instanceof Error) && (pt(at), A("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ve || "React class", se, nt, typeof ht), pt(null)), ht instanceof Error && !(ht.message in wt) && (wt[ht.message] = !0, pt(at), A("Failed %s type: %s", se, ht.message), pt(null));
          }
      }
    }
    var Gt = Array.isArray;
    function X(U) {
      return Gt(U);
    }
    function H(U) {
      {
        var Q = typeof Symbol == "function" && Symbol.toStringTag, se = Q && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return se;
      }
    }
    function be(U) {
      try {
        return qe(U), !1;
      } catch {
        return !0;
      }
    }
    function qe(U) {
      return "" + U;
    }
    function Ye(U) {
      if (be(U))
        return A("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", H(U)), qe(U);
    }
    var Ke = R.ReactCurrentOwner, Et = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, te, he, ae;
    ae = {};
    function pe(U) {
      if (Xe.call(U, "ref")) {
        var Q = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function Ee(U) {
      if (Xe.call(U, "key")) {
        var Q = Object.getOwnPropertyDescriptor(U, "key").get;
        if (Q && Q.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function He(U, Q) {
      if (typeof U.ref == "string" && Ke.current && Q && Ke.current.stateNode !== Q) {
        var se = ne(Ke.current.type);
        ae[se] || (A('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ne(Ke.current.type), U.ref), ae[se] = !0);
      }
    }
    function Fe(U, Q) {
      {
        var se = function() {
          te || (te = !0, A("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        se.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: se,
          configurable: !0
        });
      }
    }
    function Tt(U, Q) {
      {
        var se = function() {
          he || (he = !0, A("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        se.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: se,
          configurable: !0
        });
      }
    }
    var ie = function(U, Q, se, Ve, at, mt, nt) {
      var ht = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: U,
        key: Q,
        ref: se,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: mt
      };
      return ht._store = {}, Object.defineProperty(ht._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ht, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ve
      }), Object.defineProperty(ht, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: at
      }), Object.freeze && (Object.freeze(ht.props), Object.freeze(ht)), ht;
    };
    function Re(U, Q, se, Ve, at) {
      {
        var mt, nt = {}, ht = null, Ct = null;
        se !== void 0 && (Ye(se), ht = "" + se), Ee(Q) && (Ye(Q.key), ht = "" + Q.key), pe(Q) && (Ct = Q.ref, He(Q, at));
        for (mt in Q)
          Xe.call(Q, mt) && !Et.hasOwnProperty(mt) && (nt[mt] = Q[mt]);
        if (U && U.defaultProps) {
          var Mt = U.defaultProps;
          for (mt in Mt)
            nt[mt] === void 0 && (nt[mt] = Mt[mt]);
        }
        if (ht || Ct) {
          var Ut = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          ht && Fe(nt, Ut), Ct && Tt(nt, Ut);
        }
        return ie(U, ht, Ct, at, Ve, Ke.current, nt);
      }
    }
    var fe = R.ReactCurrentOwner, Ae = R.ReactDebugCurrentFrame;
    function Be(U) {
      if (U) {
        var Q = U._owner, se = rt(U.type, U._source, Q ? Q.type : null);
        Ae.setExtraStackFrame(se);
      } else
        Ae.setExtraStackFrame(null);
    }
    var tt;
    tt = !1;
    function hn(U) {
      return typeof U == "object" && U !== null && U.$$typeof === e;
    }
    function an() {
      {
        if (fe.current) {
          var U = ne(fe.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function bi(U) {
      {
        if (U !== void 0) {
          var Q = U.fileName.replace(/^.*[\\\/]/, ""), se = U.lineNumber;
          return `

Check your code at ` + Q + ":" + se + ".";
        }
        return "";
      }
    }
    var Sn = {};
    function Bt(U) {
      {
        var Q = an();
        if (!Q) {
          var se = typeof U == "string" ? U : U.displayName || U.name;
          se && (Q = `

Check the top-level render call using <` + se + ">.");
        }
        return Q;
      }
    }
    function Ln(U, Q) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var se = Bt(Q);
        if (Sn[se])
          return;
        Sn[se] = !0;
        var Ve = "";
        U && U._owner && U._owner !== fe.current && (Ve = " It was passed a child from " + ne(U._owner.type) + "."), Be(U), A('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', se, Ve), Be(null);
      }
    }
    function vr(U, Q) {
      {
        if (typeof U != "object")
          return;
        if (X(U))
          for (var se = 0; se < U.length; se++) {
            var Ve = U[se];
            hn(Ve) && Ln(Ve, Q);
          }
        else if (hn(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var at = w(U);
          if (typeof at == "function" && at !== U.entries)
            for (var mt = at.call(U), nt; !(nt = mt.next()).done; )
              hn(nt.value) && Ln(nt.value, Q);
        }
      }
    }
    function $i(U) {
      {
        var Q = U.type;
        if (Q == null || typeof Q == "string")
          return;
        var se;
        if (typeof Q == "function")
          se = Q.propTypes;
        else if (typeof Q == "object" && (Q.$$typeof === h || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Q.$$typeof === _))
          se = Q.propTypes;
        else
          return;
        if (se) {
          var Ve = ne(Q);
          kt(se, U.props, "prop", Ve, U);
        } else if (Q.PropTypes !== void 0 && !tt) {
          tt = !0;
          var at = ne(Q);
          A("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", at || "Unknown");
        }
        typeof Q.getDefaultProps == "function" && !Q.getDefaultProps.isReactClassApproved && A("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ii(U) {
      {
        for (var Q = Object.keys(U.props), se = 0; se < Q.length; se++) {
          var Ve = Q[se];
          if (Ve !== "children" && Ve !== "key") {
            Be(U), A("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ve), Be(null);
            break;
          }
        }
        U.ref !== null && (Be(U), A("Invalid attribute `ref` supplied to `React.Fragment`."), Be(null));
      }
    }
    function wi(U, Q, se, Ve, at, mt) {
      {
        var nt = G(U);
        if (!nt) {
          var ht = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (ht += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ct = bi(at);
          Ct ? ht += Ct : ht += an();
          var Mt;
          U === null ? Mt = "null" : X(U) ? Mt = "array" : U !== void 0 && U.$$typeof === e ? (Mt = "<" + (ne(U.type) || "Unknown") + " />", ht = " Did you accidentally export a JSX literal instead of a component?") : Mt = typeof U, A("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Mt, ht);
        }
        var Ut = Re(U, Q, se, at, mt);
        if (Ut == null)
          return Ut;
        if (nt) {
          var Dn = Q.children;
          if (Dn !== void 0)
            if (Ve)
              if (X(Dn)) {
                for (var oi = 0; oi < Dn.length; oi++)
                  vr(Dn[oi], U);
                Object.freeze && Object.freeze(Dn);
              } else
                A("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vr(Dn, U);
        }
        return U === n ? Ii(Ut) : $i(Ut), Ut;
      }
    }
    function Do(U, Q, se) {
      return wi(U, Q, se, !0);
    }
    function Pr(U, Q, se) {
      return wi(U, Q, se, !1);
    }
    var j = Pr, ge = Do;
    Oh.Fragment = n, Oh.jsx = j, Oh.jsxs = ge;
  }()), Oh;
}
process.env.NODE_ENV === "production" ? tx.exports = w2() : tx.exports = E2();
var si = tx.exports;
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Rg = "145", Gu = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Wu = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, _E = 0, nx = 1, xE = 2, T2 = 3, SE = 0, Ag = 1, Yh = 2, Xu = 3, sc = 0, ma = 1, Fs = 2, Co = 0, ec = 1, ix = 2, rx = 3, ax = 4, ME = 5, ju = 100, bE = 101, wE = 102, sx = 103, ox = 104, EE = 200, TE = 201, CE = 202, RE = 203, jx = 204, Yx = 205, AE = 206, LE = 207, DE = 208, PE = 209, NE = 210, zE = 0, OE = 1, IE = 2, _g = 3, UE = 4, FE = 5, BE = 6, HE = 7, mp = 0, kE = 1, VE = 2, ds = 0, GE = 1, WE = 2, qE = 3, Xx = 4, jE = 5, Lg = 300, Fl = 301, Bl = 302, Qh = 303, Kh = 304, ad = 306, $h = 1e3, Lr = 1001, ep = 1002, Si = 1003, xg = 1004, C2 = 1004, Sg = 1005, R2 = 1005, vi = 1006, Zx = 1007, A2 = 1007, cc = 1008, L2 = 1008, Ro = 1009, YE = 1010, XE = 1011, Jx = 1012, ZE = 1013, Ol = 1014, Eo = 1015, td = 1016, JE = 1017, QE = 1018, tc = 1020, KE = 1021, $E = 1022, pa = 1023, eT = 1024, tT = 1025, Ul = 1026, oc = 1027, nT = 1028, iT = 1029, rT = 1030, aT = 1031, sT = 1033, fg = 33776, dg = 33777, hg = 33778, pg = 33779, lx = 35840, ux = 35841, cx = 35842, fx = 35843, oT = 36196, dx = 37492, hx = 37496, px = 37808, mx = 37809, vx = 37810, gx = 37811, yx = 37812, _x = 37813, xx = 37814, Sx = 37815, Mx = 37816, bx = 37817, wx = 37818, Ex = 37819, Tx = 37820, Cx = 37821, Rx = 36492, lT = 2200, uT = 2201, cT = 2202, tp = 2300, np = 2301, mg = 2302, Zu = 2400, Ju = 2401, ip = 2402, Dg = 2500, Qx = 2501, D2 = 0, P2 = 1, N2 = 2, Hl = 3e3, ti = 3001, fT = 3200, dT = 3201, Gl = 0, hT = 1, z2 = "", Is = "srgb", Il = "srgb-linear", O2 = 0, vg = 7680, I2 = 7681, U2 = 7682, F2 = 7683, B2 = 34055, H2 = 34056, k2 = 5386, V2 = 512, G2 = 513, W2 = 514, q2 = 515, j2 = 516, Y2 = 517, X2 = 518, pT = 519, rp = 35044, Z2 = 35048, J2 = 35040, Q2 = 35045, K2 = 35049, $2 = 35041, eL = 35046, tL = 35050, nL = 35042, iL = "100", Ax = "300 es", Mg = 1035;
class ks {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, c = r.length; s < c; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
}
const hr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let wb = 1234567;
const nc = Math.PI / 180, ap = 180 / Math.PI;
function va() {
  const u = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (hr[u & 255] + hr[u >> 8 & 255] + hr[u >> 16 & 255] + hr[u >> 24 & 255] + "-" + hr[e & 255] + hr[e >> 8 & 255] + "-" + hr[e >> 16 & 15 | 64] + hr[e >> 24 & 255] + "-" + hr[t & 63 | 128] + hr[t >> 8 & 255] + "-" + hr[t >> 16 & 255] + hr[t >> 24 & 255] + hr[n & 255] + hr[n >> 8 & 255] + hr[n >> 16 & 255] + hr[n >> 24 & 255]).toLowerCase();
}
function gi(u, e, t) {
  return Math.max(e, Math.min(t, u));
}
function Kx(u, e) {
  return (u % e + e) % e;
}
function rL(u, e, t, n, r) {
  return n + (u - e) * (r - n) / (t - e);
}
function aL(u, e, t) {
  return u !== e ? (t - u) / (e - u) : 0;
}
function Xh(u, e, t) {
  return (1 - t) * u + t * e;
}
function sL(u, e, t, n) {
  return Xh(u, e, 1 - Math.exp(-t * n));
}
function oL(u, e = 1) {
  return e - Math.abs(Kx(u, e * 2) - e);
}
function lL(u, e, t) {
  return u <= e ? 0 : u >= t ? 1 : (u = (u - e) / (t - e), u * u * (3 - 2 * u));
}
function uL(u, e, t) {
  return u <= e ? 0 : u >= t ? 1 : (u = (u - e) / (t - e), u * u * u * (u * (u * 6 - 15) + 10));
}
function cL(u, e) {
  return u + Math.floor(Math.random() * (e - u + 1));
}
function fL(u, e) {
  return u + Math.random() * (e - u);
}
function dL(u) {
  return u * (0.5 - Math.random());
}
function hL(u) {
  u !== void 0 && (wb = u);
  let e = wb += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function pL(u) {
  return u * nc;
}
function mL(u) {
  return u * ap;
}
function Lx(u) {
  return (u & u - 1) === 0 && u !== 0;
}
function mT(u) {
  return Math.pow(2, Math.ceil(Math.log(u) / Math.LN2));
}
function bg(u) {
  return Math.pow(2, Math.floor(Math.log(u) / Math.LN2));
}
function vL(u, e, t, n, r) {
  const s = Math.cos, c = Math.sin, f = s(t / 2), h = c(t / 2), m = s((e + n) / 2), g = c((e + n) / 2), _ = s((e - n) / 2), x = c((e - n) / 2), M = s((n - e) / 2), b = c((n - e) / 2);
  switch (r) {
    case "XYX":
      u.set(f * g, h * _, h * x, f * m);
      break;
    case "YZY":
      u.set(h * x, f * g, h * _, f * m);
      break;
    case "ZXZ":
      u.set(h * _, h * x, f * g, f * m);
      break;
    case "XZX":
      u.set(f * g, h * b, h * M, f * m);
      break;
    case "YXY":
      u.set(h * M, f * g, h * b, f * m);
      break;
    case "ZYZ":
      u.set(h * b, h * M, f * g, f * m);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function To(u, e) {
  switch (e.constructor) {
    case Float32Array:
      return u;
    case Uint16Array:
      return u / 65535;
    case Uint8Array:
      return u / 255;
    case Int16Array:
      return Math.max(u / 32767, -1);
    case Int8Array:
      return Math.max(u / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Un(u, e) {
  switch (e.constructor) {
    case Float32Array:
      return u;
    case Uint16Array:
      return Math.round(u * 65535);
    case Uint8Array:
      return Math.round(u * 255);
    case Int16Array:
      return Math.round(u * 32767);
    case Int8Array:
      return Math.round(u * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var gL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD: nc,
  RAD2DEG: ap,
  generateUUID: va,
  clamp: gi,
  euclideanModulo: Kx,
  mapLinear: rL,
  inverseLerp: aL,
  lerp: Xh,
  damp: sL,
  pingpong: oL,
  smoothstep: lL,
  smootherstep: uL,
  randInt: cL,
  randFloat: fL,
  randFloatSpread: dL,
  seededRandom: hL,
  degToRad: pL,
  radToDeg: mL,
  isPowerOfTwo: Lx,
  ceilPowerOfTwo: mT,
  floorPowerOfTwo: bg,
  setQuaternionFromProperEuler: vL,
  normalize: Un,
  denormalize: To
});
class Ue {
  constructor(e = 0, t = 0) {
    Ue.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = this.x - e.x, c = this.y - e.y;
    return this.x = s * n - c * r + e.x, this.y = s * r + c * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Zr {
  constructor() {
    Zr.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, n, r, s, c, f, h, m) {
    const g = this.elements;
    return g[0] = e, g[1] = r, g[2] = f, g[3] = t, g[4] = s, g[5] = h, g[6] = n, g[7] = c, g[8] = m, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, c = n[0], f = n[3], h = n[6], m = n[1], g = n[4], _ = n[7], x = n[2], M = n[5], b = n[8], E = r[0], w = r[3], R = r[6], A = r[1], P = r[4], N = r[7], I = r[2], B = r[5], W = r[8];
    return s[0] = c * E + f * A + h * I, s[3] = c * w + f * P + h * B, s[6] = c * R + f * N + h * W, s[1] = m * E + g * A + _ * I, s[4] = m * w + g * P + _ * B, s[7] = m * R + g * N + _ * W, s[2] = x * E + M * A + b * I, s[5] = x * w + M * P + b * B, s[8] = x * R + M * N + b * W, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], c = e[4], f = e[5], h = e[6], m = e[7], g = e[8];
    return t * c * g - t * f * m - n * s * g + n * f * h + r * s * m - r * c * h;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], c = e[4], f = e[5], h = e[6], m = e[7], g = e[8], _ = g * c - f * m, x = f * h - g * s, M = m * s - c * h, b = t * _ + n * x + r * M;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / b;
    return e[0] = _ * E, e[1] = (r * m - g * n) * E, e[2] = (f * n - r * c) * E, e[3] = x * E, e[4] = (g * t - r * h) * E, e[5] = (r * s - f * t) * E, e[6] = M * E, e[7] = (n * h - m * t) * E, e[8] = (c * t - n * s) * E, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, r, s, c, f) {
    const h = Math.cos(s), m = Math.sin(s);
    return this.set(
      n * h,
      n * m,
      -n * (h * c + m * f) + c + e,
      -r * m,
      r * h,
      -r * (-m * c + h * f) + f + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), n = Math.sin(e), r = this.elements, s = r[0], c = r[3], f = r[6], h = r[1], m = r[4], g = r[7];
    return r[0] = t * s + n * h, r[3] = t * c + n * m, r[6] = t * f + n * g, r[1] = -n * s + t * h, r[4] = -n * c + t * m, r[7] = -n * f + t * g, this;
  }
  translate(e, t) {
    const n = this.elements;
    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function vT(u) {
  for (let e = u.length - 1; e >= 0; --e)
    if (u[e] >= 65535)
      return !0;
  return !1;
}
const yL = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Zf(u, e) {
  return new yL[u](e);
}
function sp(u) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", u);
}
function ic(u) {
  return u < 0.04045 ? u * 0.0773993808 : Math.pow(u * 0.9478672986 + 0.0521327014, 2.4);
}
function gg(u) {
  return u < 31308e-7 ? u * 12.92 : 1.055 * Math.pow(u, 0.41666) - 0.055;
}
const a_ = {
  [Is]: { [Il]: ic },
  [Il]: { [Is]: gg }
}, ka = {
  legacyMode: !0,
  get workingColorSpace() {
    return Il;
  },
  set workingColorSpace(u) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(u, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return u;
    if (a_[e] && a_[e][t] !== void 0) {
      const n = a_[e][t];
      return u.r = n(u.r), u.g = n(u.g), u.b = n(u.b), u;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(u, e) {
    return this.convert(u, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(u, e) {
    return this.convert(u, e, this.workingColorSpace);
  }
}, gT = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ni = { r: 0, g: 0, b: 0 }, ls = { h: 0, s: 0, l: 0 }, Sv = { h: 0, s: 0, l: 0 };
function s_(u, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? u + (e - u) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? u + (e - u) * 6 * (2 / 3 - t) : u;
}
function Mv(u, e) {
  return e.r = u.r, e.g = u.g, e.b = u.b, e;
}
class xt {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Is) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ka.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, r = Il) {
    return this.r = e, this.g = t, this.b = n, ka.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, n, r = Il) {
    if (e = Kx(e, 1), t = gi(t, 0, 1), n = gi(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t, c = 2 * n - s;
      this.r = s_(c, s, e + 1 / 3), this.g = s_(c, s, e), this.b = s_(c, s, e - 1 / 3);
    }
    return ka.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Is) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s;
      const c = r[1], f = r[2];
      switch (c) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, ka.toWorkingColorSpace(this, t), n(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, ka.toWorkingColorSpace(this, t), n(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f)) {
            const h = parseFloat(s[1]) / 360, m = parseFloat(s[2]) / 100, g = parseFloat(s[3]) / 100;
            return n(s[4]), this.setHSL(h, m, g, t);
          }
          break;
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], c = s.length;
      if (c === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, ka.toWorkingColorSpace(this, t), this;
      if (c === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, ka.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = Is) {
    const n = gT[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ic(e.r), this.g = ic(e.g), this.b = ic(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = gg(e.r), this.g = gg(e.g), this.b = gg(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Is) {
    return ka.fromWorkingColorSpace(Mv(this, Ni), e), gi(Ni.r * 255, 0, 255) << 16 ^ gi(Ni.g * 255, 0, 255) << 8 ^ gi(Ni.b * 255, 0, 255) << 0;
  }
  getHexString(e = Is) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Il) {
    ka.fromWorkingColorSpace(Mv(this, Ni), t);
    const n = Ni.r, r = Ni.g, s = Ni.b, c = Math.max(n, r, s), f = Math.min(n, r, s);
    let h, m;
    const g = (f + c) / 2;
    if (f === c)
      h = 0, m = 0;
    else {
      const _ = c - f;
      switch (m = g <= 0.5 ? _ / (c + f) : _ / (2 - c - f), c) {
        case n:
          h = (r - s) / _ + (r < s ? 6 : 0);
          break;
        case r:
          h = (s - n) / _ + 2;
          break;
        case s:
          h = (n - r) / _ + 4;
          break;
      }
      h /= 6;
    }
    return e.h = h, e.s = m, e.l = g, e;
  }
  getRGB(e, t = Il) {
    return ka.fromWorkingColorSpace(Mv(this, Ni), t), e.r = Ni.r, e.g = Ni.g, e.b = Ni.b, e;
  }
  getStyle(e = Is) {
    return ka.fromWorkingColorSpace(Mv(this, Ni), e), e !== Is ? `color(${e} ${Ni.r} ${Ni.g} ${Ni.b})` : `rgb(${Ni.r * 255 | 0},${Ni.g * 255 | 0},${Ni.b * 255 | 0})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(ls), ls.h += e, ls.s += t, ls.l += n, this.setHSL(ls.h, ls.s, ls.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(ls), e.getHSL(Sv);
    const n = Xh(ls.h, Sv.h, t), r = Xh(ls.s, Sv.s, t), s = Xh(ls.l, Sv.l, t);
    return this.setHSL(n, r, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
xt.NAMES = gT;
let Cf;
class $x {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Cf === void 0 && (Cf = sp("canvas")), Cf.width = e.width, Cf.height = e.height;
      const n = Cf.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Cf;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = sp("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let c = 0; c < s.length; c++)
        s[c] = ic(s[c] / 255) * 255;
      return n.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(ic(t[n] / 255) * 255) : t[n] = ic(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class Qu {
  constructor(e = null) {
    this.isSource = !0, this.uuid = va(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let c = 0, f = r.length; c < f; c++)
          r[c].isDataTexture ? s.push(o_(r[c].image)) : s.push(o_(r[c]));
      } else
        s = o_(r);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function o_(u) {
  return typeof HTMLImageElement < "u" && u instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && u instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && u instanceof ImageBitmap ? $x.getDataURL(u) : u.data ? {
    data: Array.from(u.data),
    width: u.width,
    height: u.height,
    type: u.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let _L = 0;
class Mi extends ks {
  constructor(e = Mi.DEFAULT_IMAGE, t = Mi.DEFAULT_MAPPING, n = Lr, r = Lr, s = vi, c = cc, f = pa, h = Ro, m = 1, g = Hl) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: _L++ }), this.uuid = va(), this.name = "", this.source = new Qu(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = c, this.anisotropy = m, this.format = f, this.internalFormat = null, this.type = h, this.offset = new Ue(0, 0), this.repeat = new Ue(1, 1), this.center = new Ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Zr(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = g, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Lg)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case $h:
          e.x = e.x - Math.floor(e.x);
          break;
        case Lr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ep:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case $h:
          e.y = e.y - Math.floor(e.y);
          break;
        case Lr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ep:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
Mi.DEFAULT_IMAGE = null;
Mi.DEFAULT_MAPPING = Lg;
class An {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    An.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, r) {
    return this.x = e, this.y = t, this.z = n, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = this.w, c = e.elements;
    return this.x = c[0] * t + c[4] * n + c[8] * r + c[12] * s, this.y = c[1] * t + c[5] * n + c[9] * r + c[13] * s, this.z = c[2] * t + c[6] * n + c[10] * r + c[14] * s, this.w = c[3] * t + c[7] * n + c[11] * r + c[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, s;
    const h = e.elements, m = h[0], g = h[4], _ = h[8], x = h[1], M = h[5], b = h[9], E = h[2], w = h[6], R = h[10];
    if (Math.abs(g - x) < 0.01 && Math.abs(_ - E) < 0.01 && Math.abs(b - w) < 0.01) {
      if (Math.abs(g + x) < 0.1 && Math.abs(_ + E) < 0.1 && Math.abs(b + w) < 0.1 && Math.abs(m + M + R - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const P = (m + 1) / 2, N = (M + 1) / 2, I = (R + 1) / 2, B = (g + x) / 4, W = (_ + E) / 4, z = (b + w) / 4;
      return P > N && P > I ? P < 0.01 ? (n = 0, r = 0.707106781, s = 0.707106781) : (n = Math.sqrt(P), r = B / n, s = W / n) : N > I ? N < 0.01 ? (n = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(N), n = B / r, s = z / r) : I < 0.01 ? (n = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(I), n = W / s, r = z / s), this.set(n, r, s, t), this;
    }
    let A = Math.sqrt((w - b) * (w - b) + (_ - E) * (_ - E) + (x - g) * (x - g));
    return Math.abs(A) < 1e-3 && (A = 1), this.x = (w - b) / A, this.y = (_ - E) / A, this.z = (x - g) / A, this.w = Math.acos((m + M + R - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Wa extends ks {
  constructor(e, t, n = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new An(0, 0, e, t), this.scissorTest = !1, this.viewport = new An(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    this.texture = new Mi(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : vi, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Qu(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class vp extends Mi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Si, this.minFilter = Si, this.wrapR = Lr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class xL extends Wa {
  constructor(e, t, n) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new vp(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class Pg extends Mi {
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = Si, this.minFilter = Si, this.wrapR = Lr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class SL extends Wa {
  constructor(e, t, n) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Pg(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class ML extends Wa {
  constructor(e, t, n, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
    const s = this.texture;
    this.texture = [];
    for (let c = 0; c < n; c++)
      this.texture[c] = s.clone(), this.texture[c].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let r = 0, s = this.texture.length; r < s; r++)
        this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class mr {
  constructor(e = 0, t = 0, n = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
  }
  static slerpFlat(e, t, n, r, s, c, f) {
    let h = n[r + 0], m = n[r + 1], g = n[r + 2], _ = n[r + 3];
    const x = s[c + 0], M = s[c + 1], b = s[c + 2], E = s[c + 3];
    if (f === 0) {
      e[t + 0] = h, e[t + 1] = m, e[t + 2] = g, e[t + 3] = _;
      return;
    }
    if (f === 1) {
      e[t + 0] = x, e[t + 1] = M, e[t + 2] = b, e[t + 3] = E;
      return;
    }
    if (_ !== E || h !== x || m !== M || g !== b) {
      let w = 1 - f;
      const R = h * x + m * M + g * b + _ * E, A = R >= 0 ? 1 : -1, P = 1 - R * R;
      if (P > Number.EPSILON) {
        const I = Math.sqrt(P), B = Math.atan2(I, R * A);
        w = Math.sin(w * B) / I, f = Math.sin(f * B) / I;
      }
      const N = f * A;
      if (h = h * w + x * N, m = m * w + M * N, g = g * w + b * N, _ = _ * w + E * N, w === 1 - f) {
        const I = 1 / Math.sqrt(h * h + m * m + g * g + _ * _);
        h *= I, m *= I, g *= I, _ *= I;
      }
    }
    e[t] = h, e[t + 1] = m, e[t + 2] = g, e[t + 3] = _;
  }
  static multiplyQuaternionsFlat(e, t, n, r, s, c) {
    const f = n[r], h = n[r + 1], m = n[r + 2], g = n[r + 3], _ = s[c], x = s[c + 1], M = s[c + 2], b = s[c + 3];
    return e[t] = f * b + g * _ + h * M - m * x, e[t + 1] = h * b + g * x + m * _ - f * M, e[t + 2] = m * b + g * M + f * x - h * _, e[t + 3] = g * b - f * _ - h * x - m * M, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, r) {
    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const n = e._x, r = e._y, s = e._z, c = e._order, f = Math.cos, h = Math.sin, m = f(n / 2), g = f(r / 2), _ = f(s / 2), x = h(n / 2), M = h(r / 2), b = h(s / 2);
    switch (c) {
      case "XYZ":
        this._x = x * g * _ + m * M * b, this._y = m * M * _ - x * g * b, this._z = m * g * b + x * M * _, this._w = m * g * _ - x * M * b;
        break;
      case "YXZ":
        this._x = x * g * _ + m * M * b, this._y = m * M * _ - x * g * b, this._z = m * g * b - x * M * _, this._w = m * g * _ + x * M * b;
        break;
      case "ZXY":
        this._x = x * g * _ - m * M * b, this._y = m * M * _ + x * g * b, this._z = m * g * b + x * M * _, this._w = m * g * _ - x * M * b;
        break;
      case "ZYX":
        this._x = x * g * _ - m * M * b, this._y = m * M * _ + x * g * b, this._z = m * g * b - x * M * _, this._w = m * g * _ + x * M * b;
        break;
      case "YZX":
        this._x = x * g * _ + m * M * b, this._y = m * M * _ + x * g * b, this._z = m * g * b - x * M * _, this._w = m * g * _ - x * M * b;
        break;
      case "XZY":
        this._x = x * g * _ - m * M * b, this._y = m * M * _ - x * g * b, this._z = m * g * b + x * M * _, this._w = m * g * _ + x * M * b;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + c);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, r = Math.sin(n);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], r = t[4], s = t[8], c = t[1], f = t[5], h = t[9], m = t[2], g = t[6], _ = t[10], x = n + f + _;
    if (x > 0) {
      const M = 0.5 / Math.sqrt(x + 1);
      this._w = 0.25 / M, this._x = (g - h) * M, this._y = (s - m) * M, this._z = (c - r) * M;
    } else if (n > f && n > _) {
      const M = 2 * Math.sqrt(1 + n - f - _);
      this._w = (g - h) / M, this._x = 0.25 * M, this._y = (r + c) / M, this._z = (s + m) / M;
    } else if (f > _) {
      const M = 2 * Math.sqrt(1 + f - n - _);
      this._w = (s - m) / M, this._x = (r + c) / M, this._y = 0.25 * M, this._z = (h + g) / M;
    } else {
      const M = 2 * Math.sqrt(1 + _ - n - f);
      this._w = (c - r) / M, this._x = (s + m) / M, this._y = (h + g) / M, this._z = 0.25 * M;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(gi(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0)
      return this;
    const r = Math.min(1, t / n);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, r = e._y, s = e._z, c = e._w, f = t._x, h = t._y, m = t._z, g = t._w;
    return this._x = n * g + c * f + r * m - s * h, this._y = r * g + c * h + s * f - n * m, this._z = s * g + c * m + n * h - r * f, this._w = c * g - n * f - r * h - s * m, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const n = this._x, r = this._y, s = this._z, c = this._w;
    let f = c * e._w + n * e._x + r * e._y + s * e._z;
    if (f < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, f = -f) : this.copy(e), f >= 1)
      return this._w = c, this._x = n, this._y = r, this._z = s, this;
    const h = 1 - f * f;
    if (h <= Number.EPSILON) {
      const M = 1 - t;
      return this._w = M * c + t * this._w, this._x = M * n + t * this._x, this._y = M * r + t * this._y, this._z = M * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const m = Math.sqrt(h), g = Math.atan2(m, f), _ = Math.sin((1 - t) * g) / m, x = Math.sin(t * g) / m;
    return this._w = c * _ + this._w * x, this._x = n * _ + this._x * x, this._y = r * _ + this._y * x, this._z = s * _ + this._z * x, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      n * Math.sin(s),
      n * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class q {
  constructor(e = 0, t = 0, n = 0) {
    q.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Eb.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Eb.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6] * r, this.y = s[1] * t + s[4] * n + s[7] * r, this.z = s[2] * t + s[5] * n + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements, c = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * c, this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * c, this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * c, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, r = this.z, s = e.x, c = e.y, f = e.z, h = e.w, m = h * t + c * r - f * n, g = h * n + f * t - s * r, _ = h * r + s * n - c * t, x = -s * t - c * n - f * r;
    return this.x = m * h + x * -s + g * -f - _ * -c, this.y = g * h + x * -c + _ * -s - m * -f, this.z = _ * h + x * -f + m * -c - g * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * n + s[8] * r, this.y = s[1] * t + s[5] * n + s[9] * r, this.z = s[2] * t + s[6] * n + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, r = e.y, s = e.z, c = t.x, f = t.y, h = t.z;
    return this.x = r * h - s * f, this.y = s * c - n * h, this.z = n * f - r * c, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return l_.copy(this).projectOnVector(e), this.sub(l_);
  }
  reflect(e) {
    return this.sub(l_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(gi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const l_ = /* @__PURE__ */ new q(), Eb = /* @__PURE__ */ new mr();
class fc {
  constructor(e = new q(1 / 0, 1 / 0, 1 / 0), t = new q(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, c = -1 / 0, f = -1 / 0;
    for (let h = 0, m = e.length; h < m; h += 3) {
      const g = e[h], _ = e[h + 1], x = e[h + 2];
      g < t && (t = g), _ < n && (n = _), x < r && (r = x), g > s && (s = g), _ > c && (c = _), x > f && (f = x);
    }
    return this.min.set(t, n, r), this.max.set(s, c, f), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, c = -1 / 0, f = -1 / 0;
    for (let h = 0, m = e.count; h < m; h++) {
      const g = e.getX(h), _ = e.getY(h), x = e.getZ(h);
      g < t && (t = g), _ < n && (n = _), x < r && (r = x), g > s && (s = g), _ > c && (c = _), x > f && (f = x);
    }
    return this.min.set(t, n, r), this.max.set(s, c, f), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Ou.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0)
      if (t && n.attributes != null && n.attributes.position !== void 0) {
        const s = n.attributes.position;
        for (let c = 0, f = s.count; c < f; c++)
          Ou.fromBufferAttribute(s, c).applyMatrix4(e.matrixWorld), this.expandByPoint(Ou);
      } else
        n.boundingBox === null && n.computeBoundingBox(), u_.copy(n.boundingBox), u_.applyMatrix4(e.matrixWorld), this.union(u_);
    const r = e.children;
    for (let s = 0, c = r.length; s < c; s++)
      this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Ou), Ou.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Ih), bv.subVectors(this.max, Ih), Rf.subVectors(e.a, Ih), Af.subVectors(e.b, Ih), Lf.subVectors(e.c, Ih), wl.subVectors(Af, Rf), El.subVectors(Lf, Af), Iu.subVectors(Rf, Lf);
    let t = [
      0,
      -wl.z,
      wl.y,
      0,
      -El.z,
      El.y,
      0,
      -Iu.z,
      Iu.y,
      wl.z,
      0,
      -wl.x,
      El.z,
      0,
      -El.x,
      Iu.z,
      0,
      -Iu.x,
      -wl.y,
      wl.x,
      0,
      -El.y,
      El.x,
      0,
      -Iu.y,
      Iu.x,
      0
    ];
    return !c_(t, Rf, Af, Lf, bv) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !c_(t, Rf, Af, Lf, bv)) ? !1 : (wv.crossVectors(wl, El), t = [wv.x, wv.y, wv.z], c_(t, Rf, Af, Lf, bv));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Ou.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(Ou).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (yo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), yo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), yo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), yo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), yo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), yo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), yo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), yo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(yo), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const yo = [
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q()
], Ou = /* @__PURE__ */ new q(), u_ = /* @__PURE__ */ new fc(), Rf = /* @__PURE__ */ new q(), Af = /* @__PURE__ */ new q(), Lf = /* @__PURE__ */ new q(), wl = /* @__PURE__ */ new q(), El = /* @__PURE__ */ new q(), Iu = /* @__PURE__ */ new q(), Ih = /* @__PURE__ */ new q(), bv = /* @__PURE__ */ new q(), wv = /* @__PURE__ */ new q(), Uu = /* @__PURE__ */ new q();
function c_(u, e, t, n, r) {
  for (let s = 0, c = u.length - 3; s <= c; s += 3) {
    Uu.fromArray(u, s);
    const f = r.x * Math.abs(Uu.x) + r.y * Math.abs(Uu.y) + r.z * Math.abs(Uu.z), h = e.dot(Uu), m = t.dot(Uu), g = n.dot(Uu);
    if (Math.max(-Math.max(h, m, g), Math.min(h, m, g)) > f)
      return !1;
  }
  return !0;
}
const bL = /* @__PURE__ */ new fc(), Tb = /* @__PURE__ */ new q(), Ev = /* @__PURE__ */ new q(), f_ = /* @__PURE__ */ new q();
class dc {
  constructor(e = new q(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : bL.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let s = 0, c = e.length; s < c; s++)
      r = Math.max(r, n.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    f_.subVectors(e, this.center);
    const t = f_.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), r = (n - this.radius) * 0.5;
      this.center.add(f_.multiplyScalar(r / n)), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? Ev.set(0, 0, 1).multiplyScalar(e.radius) : Ev.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Tb.copy(e.center).add(Ev)), this.expandByPoint(Tb.copy(e.center).sub(Ev)), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _o = /* @__PURE__ */ new q(), d_ = /* @__PURE__ */ new q(), Tv = /* @__PURE__ */ new q(), Tl = /* @__PURE__ */ new q(), h_ = /* @__PURE__ */ new q(), Cv = /* @__PURE__ */ new q(), p_ = /* @__PURE__ */ new q();
class gp {
  constructor(e = new q(), t = new q(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _o)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _o.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_o.copy(this.direction).multiplyScalar(t).add(this.origin), _o.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, r) {
    d_.copy(e).add(t).multiplyScalar(0.5), Tv.copy(t).sub(e).normalize(), Tl.copy(this.origin).sub(d_);
    const s = e.distanceTo(t) * 0.5, c = -this.direction.dot(Tv), f = Tl.dot(this.direction), h = -Tl.dot(Tv), m = Tl.lengthSq(), g = Math.abs(1 - c * c);
    let _, x, M, b;
    if (g > 0)
      if (_ = c * h - f, x = c * f - h, b = s * g, _ >= 0)
        if (x >= -b)
          if (x <= b) {
            const E = 1 / g;
            _ *= E, x *= E, M = _ * (_ + c * x + 2 * f) + x * (c * _ + x + 2 * h) + m;
          } else
            x = s, _ = Math.max(0, -(c * x + f)), M = -_ * _ + x * (x + 2 * h) + m;
        else
          x = -s, _ = Math.max(0, -(c * x + f)), M = -_ * _ + x * (x + 2 * h) + m;
      else
        x <= -b ? (_ = Math.max(0, -(-c * s + f)), x = _ > 0 ? -s : Math.min(Math.max(-s, -h), s), M = -_ * _ + x * (x + 2 * h) + m) : x <= b ? (_ = 0, x = Math.min(Math.max(-s, -h), s), M = x * (x + 2 * h) + m) : (_ = Math.max(0, -(c * s + f)), x = _ > 0 ? s : Math.min(Math.max(-s, -h), s), M = -_ * _ + x * (x + 2 * h) + m);
    else
      x = c > 0 ? -s : s, _ = Math.max(0, -(c * x + f)), M = -_ * _ + x * (x + 2 * h) + m;
    return n && n.copy(this.direction).multiplyScalar(_).add(this.origin), r && r.copy(Tv).multiplyScalar(x).add(d_), M;
  }
  intersectSphere(e, t) {
    _o.subVectors(e.center, this.origin);
    const n = _o.dot(this.direction), r = _o.dot(_o) - n * n, s = e.radius * e.radius;
    if (r > s)
      return null;
    const c = Math.sqrt(s - r), f = n - c, h = n + c;
    return f < 0 && h < 0 ? null : f < 0 ? this.at(h, t) : this.at(f, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, r, s, c, f, h;
    const m = 1 / this.direction.x, g = 1 / this.direction.y, _ = 1 / this.direction.z, x = this.origin;
    return m >= 0 ? (n = (e.min.x - x.x) * m, r = (e.max.x - x.x) * m) : (n = (e.max.x - x.x) * m, r = (e.min.x - x.x) * m), g >= 0 ? (s = (e.min.y - x.y) * g, c = (e.max.y - x.y) * g) : (s = (e.max.y - x.y) * g, c = (e.min.y - x.y) * g), n > c || s > r || ((s > n || n !== n) && (n = s), (c < r || r !== r) && (r = c), _ >= 0 ? (f = (e.min.z - x.z) * _, h = (e.max.z - x.z) * _) : (f = (e.max.z - x.z) * _, h = (e.min.z - x.z) * _), n > h || f > r) || ((f > n || n !== n) && (n = f), (h < r || r !== r) && (r = h), r < 0) ? null : this.at(n >= 0 ? n : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, _o) !== null;
  }
  intersectTriangle(e, t, n, r, s) {
    h_.subVectors(t, e), Cv.subVectors(n, e), p_.crossVectors(h_, Cv);
    let c = this.direction.dot(p_), f;
    if (c > 0) {
      if (r)
        return null;
      f = 1;
    } else if (c < 0)
      f = -1, c = -c;
    else
      return null;
    Tl.subVectors(this.origin, e);
    const h = f * this.direction.dot(Cv.crossVectors(Tl, Cv));
    if (h < 0)
      return null;
    const m = f * this.direction.dot(h_.cross(Tl));
    if (m < 0 || h + m > c)
      return null;
    const g = -f * Tl.dot(p_);
    return g < 0 ? null : this.at(g / c, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qt {
  constructor() {
    Qt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, n, r, s, c, f, h, m, g, _, x, M, b, E, w) {
    const R = this.elements;
    return R[0] = e, R[4] = t, R[8] = n, R[12] = r, R[1] = s, R[5] = c, R[9] = f, R[13] = h, R[2] = m, R[6] = g, R[10] = _, R[14] = x, R[3] = M, R[7] = b, R[11] = E, R[15] = w, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Qt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, r = 1 / Df.setFromMatrixColumn(e, 0).length(), s = 1 / Df.setFromMatrixColumn(e, 1).length(), c = 1 / Df.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * c, t[9] = n[9] * c, t[10] = n[10] * c, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z, c = Math.cos(n), f = Math.sin(n), h = Math.cos(r), m = Math.sin(r), g = Math.cos(s), _ = Math.sin(s);
    if (e.order === "XYZ") {
      const x = c * g, M = c * _, b = f * g, E = f * _;
      t[0] = h * g, t[4] = -h * _, t[8] = m, t[1] = M + b * m, t[5] = x - E * m, t[9] = -f * h, t[2] = E - x * m, t[6] = b + M * m, t[10] = c * h;
    } else if (e.order === "YXZ") {
      const x = h * g, M = h * _, b = m * g, E = m * _;
      t[0] = x + E * f, t[4] = b * f - M, t[8] = c * m, t[1] = c * _, t[5] = c * g, t[9] = -f, t[2] = M * f - b, t[6] = E + x * f, t[10] = c * h;
    } else if (e.order === "ZXY") {
      const x = h * g, M = h * _, b = m * g, E = m * _;
      t[0] = x - E * f, t[4] = -c * _, t[8] = b + M * f, t[1] = M + b * f, t[5] = c * g, t[9] = E - x * f, t[2] = -c * m, t[6] = f, t[10] = c * h;
    } else if (e.order === "ZYX") {
      const x = c * g, M = c * _, b = f * g, E = f * _;
      t[0] = h * g, t[4] = b * m - M, t[8] = x * m + E, t[1] = h * _, t[5] = E * m + x, t[9] = M * m - b, t[2] = -m, t[6] = f * h, t[10] = c * h;
    } else if (e.order === "YZX") {
      const x = c * h, M = c * m, b = f * h, E = f * m;
      t[0] = h * g, t[4] = E - x * _, t[8] = b * _ + M, t[1] = _, t[5] = c * g, t[9] = -f * g, t[2] = -m * g, t[6] = M * _ + b, t[10] = x - E * _;
    } else if (e.order === "XZY") {
      const x = c * h, M = c * m, b = f * h, E = f * m;
      t[0] = h * g, t[4] = -_, t[8] = m * g, t[1] = x * _ + E, t[5] = c * g, t[9] = M * _ - b, t[2] = b * _ - M, t[6] = f * g, t[10] = E * _ + x;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(wL, e, EL);
  }
  lookAt(e, t, n) {
    const r = this.elements;
    return da.subVectors(e, t), da.lengthSq() === 0 && (da.z = 1), da.normalize(), Cl.crossVectors(n, da), Cl.lengthSq() === 0 && (Math.abs(n.z) === 1 ? da.x += 1e-4 : da.z += 1e-4, da.normalize(), Cl.crossVectors(n, da)), Cl.normalize(), Rv.crossVectors(da, Cl), r[0] = Cl.x, r[4] = Rv.x, r[8] = da.x, r[1] = Cl.y, r[5] = Rv.y, r[9] = da.y, r[2] = Cl.z, r[6] = Rv.z, r[10] = da.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, c = n[0], f = n[4], h = n[8], m = n[12], g = n[1], _ = n[5], x = n[9], M = n[13], b = n[2], E = n[6], w = n[10], R = n[14], A = n[3], P = n[7], N = n[11], I = n[15], B = r[0], W = r[4], z = r[8], k = r[12], G = r[1], $ = r[5], oe = r[9], ne = r[13], ee = r[2], ye = r[6], Me = r[10], De = r[14], V = r[3], J = r[7], Y = r[11], de = r[15];
    return s[0] = c * B + f * G + h * ee + m * V, s[4] = c * W + f * $ + h * ye + m * J, s[8] = c * z + f * oe + h * Me + m * Y, s[12] = c * k + f * ne + h * De + m * de, s[1] = g * B + _ * G + x * ee + M * V, s[5] = g * W + _ * $ + x * ye + M * J, s[9] = g * z + _ * oe + x * Me + M * Y, s[13] = g * k + _ * ne + x * De + M * de, s[2] = b * B + E * G + w * ee + R * V, s[6] = b * W + E * $ + w * ye + R * J, s[10] = b * z + E * oe + w * Me + R * Y, s[14] = b * k + E * ne + w * De + R * de, s[3] = A * B + P * G + N * ee + I * V, s[7] = A * W + P * $ + N * ye + I * J, s[11] = A * z + P * oe + N * Me + I * Y, s[15] = A * k + P * ne + N * De + I * de, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], r = e[8], s = e[12], c = e[1], f = e[5], h = e[9], m = e[13], g = e[2], _ = e[6], x = e[10], M = e[14], b = e[3], E = e[7], w = e[11], R = e[15];
    return b * (+s * h * _ - r * m * _ - s * f * x + n * m * x + r * f * M - n * h * M) + E * (+t * h * M - t * m * x + s * c * x - r * c * M + r * m * g - s * h * g) + w * (+t * m * _ - t * f * M - s * c * _ + n * c * M + s * f * g - n * m * g) + R * (-r * f * g - t * h * _ + t * f * x + r * c * _ - n * c * x + n * h * g);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], c = e[4], f = e[5], h = e[6], m = e[7], g = e[8], _ = e[9], x = e[10], M = e[11], b = e[12], E = e[13], w = e[14], R = e[15], A = _ * w * m - E * x * m + E * h * M - f * w * M - _ * h * R + f * x * R, P = b * x * m - g * w * m - b * h * M + c * w * M + g * h * R - c * x * R, N = g * E * m - b * _ * m + b * f * M - c * E * M - g * f * R + c * _ * R, I = b * _ * h - g * E * h - b * f * x + c * E * x + g * f * w - c * _ * w, B = t * A + n * P + r * N + s * I;
    if (B === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const W = 1 / B;
    return e[0] = A * W, e[1] = (E * x * s - _ * w * s - E * r * M + n * w * M + _ * r * R - n * x * R) * W, e[2] = (f * w * s - E * h * s + E * r * m - n * w * m - f * r * R + n * h * R) * W, e[3] = (_ * h * s - f * x * s - _ * r * m + n * x * m + f * r * M - n * h * M) * W, e[4] = P * W, e[5] = (g * w * s - b * x * s + b * r * M - t * w * M - g * r * R + t * x * R) * W, e[6] = (b * h * s - c * w * s - b * r * m + t * w * m + c * r * R - t * h * R) * W, e[7] = (c * x * s - g * h * s + g * r * m - t * x * m - c * r * M + t * h * M) * W, e[8] = N * W, e[9] = (b * _ * s - g * E * s - b * n * M + t * E * M + g * n * R - t * _ * R) * W, e[10] = (c * E * s - b * f * s + b * n * m - t * E * m - c * n * R + t * f * R) * W, e[11] = (g * f * s - c * _ * s - g * n * m + t * _ * m + c * n * M - t * f * M) * W, e[12] = I * W, e[13] = (g * E * r - b * _ * r + b * n * x - t * E * x - g * n * w + t * _ * w) * W, e[14] = (b * f * r - c * E * r - b * n * h + t * E * h + c * n * w - t * f * w) * W, e[15] = (c * _ * r - g * f * r + g * n * h - t * _ * h - c * n * x + t * f * x) * W, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z;
    return t[0] *= n, t[4] *= r, t[8] *= s, t[1] *= n, t[5] *= r, t[9] *= s, t[2] *= n, t[6] *= r, t[10] *= s, t[3] *= n, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  makeTranslation(e, t, n) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = 1 - n, c = e.x, f = e.y, h = e.z, m = s * c, g = s * f;
    return this.set(
      m * c + n,
      m * f - r * h,
      m * h + r * f,
      0,
      m * f + r * h,
      g * f + n,
      g * h - r * c,
      0,
      m * h - r * f,
      g * h + r * c,
      s * h * h + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, r, s, c) {
    return this.set(
      1,
      n,
      s,
      0,
      e,
      1,
      c,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const r = this.elements, s = t._x, c = t._y, f = t._z, h = t._w, m = s + s, g = c + c, _ = f + f, x = s * m, M = s * g, b = s * _, E = c * g, w = c * _, R = f * _, A = h * m, P = h * g, N = h * _, I = n.x, B = n.y, W = n.z;
    return r[0] = (1 - (E + R)) * I, r[1] = (M + N) * I, r[2] = (b - P) * I, r[3] = 0, r[4] = (M - N) * B, r[5] = (1 - (x + R)) * B, r[6] = (w + A) * B, r[7] = 0, r[8] = (b + P) * W, r[9] = (w - A) * W, r[10] = (1 - (x + E)) * W, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, n) {
    const r = this.elements;
    let s = Df.set(r[0], r[1], r[2]).length();
    const c = Df.set(r[4], r[5], r[6]).length(), f = Df.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], us.copy(this);
    const m = 1 / s, g = 1 / c, _ = 1 / f;
    return us.elements[0] *= m, us.elements[1] *= m, us.elements[2] *= m, us.elements[4] *= g, us.elements[5] *= g, us.elements[6] *= g, us.elements[8] *= _, us.elements[9] *= _, us.elements[10] *= _, t.setFromRotationMatrix(us), n.x = s, n.y = c, n.z = f, this;
  }
  makePerspective(e, t, n, r, s, c) {
    const f = this.elements, h = 2 * s / (t - e), m = 2 * s / (n - r), g = (t + e) / (t - e), _ = (n + r) / (n - r), x = -(c + s) / (c - s), M = -2 * c * s / (c - s);
    return f[0] = h, f[4] = 0, f[8] = g, f[12] = 0, f[1] = 0, f[5] = m, f[9] = _, f[13] = 0, f[2] = 0, f[6] = 0, f[10] = x, f[14] = M, f[3] = 0, f[7] = 0, f[11] = -1, f[15] = 0, this;
  }
  makeOrthographic(e, t, n, r, s, c) {
    const f = this.elements, h = 1 / (t - e), m = 1 / (n - r), g = 1 / (c - s), _ = (t + e) * h, x = (n + r) * m, M = (c + s) * g;
    return f[0] = 2 * h, f[4] = 0, f[8] = 0, f[12] = -_, f[1] = 0, f[5] = 2 * m, f[9] = 0, f[13] = -x, f[2] = 0, f[6] = 0, f[10] = -2 * g, f[14] = -M, f[3] = 0, f[7] = 0, f[11] = 0, f[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== n[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const Df = /* @__PURE__ */ new q(), us = /* @__PURE__ */ new Qt(), wL = /* @__PURE__ */ new q(0, 0, 0), EL = /* @__PURE__ */ new q(1, 1, 1), Cl = /* @__PURE__ */ new q(), Rv = /* @__PURE__ */ new q(), da = /* @__PURE__ */ new q(), Cb = /* @__PURE__ */ new Qt(), Rb = /* @__PURE__ */ new mr();
class sd {
  constructor(e = 0, t = 0, n = 0, r = sd.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, r = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements, s = r[0], c = r[4], f = r[8], h = r[1], m = r[5], g = r[9], _ = r[2], x = r[6], M = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(gi(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(-g, M), this._z = Math.atan2(-c, s)) : (this._x = Math.atan2(x, m), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-gi(g, -1, 1)), Math.abs(g) < 0.9999999 ? (this._y = Math.atan2(f, M), this._z = Math.atan2(h, m)) : (this._y = Math.atan2(-_, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(gi(x, -1, 1)), Math.abs(x) < 0.9999999 ? (this._y = Math.atan2(-_, M), this._z = Math.atan2(-c, m)) : (this._y = 0, this._z = Math.atan2(h, s));
        break;
      case "ZYX":
        this._y = Math.asin(-gi(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._x = Math.atan2(x, M), this._z = Math.atan2(h, s)) : (this._x = 0, this._z = Math.atan2(-c, m));
        break;
      case "YZX":
        this._z = Math.asin(gi(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-g, m), this._y = Math.atan2(-_, s)) : (this._x = 0, this._y = Math.atan2(f, M));
        break;
      case "XZY":
        this._z = Math.asin(-gi(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(x, m), this._y = Math.atan2(f, s)) : (this._x = Math.atan2(-g, M), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return Cb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Cb, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Rb.setFromEuler(this), this.setFromQuaternion(Rb, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
sd.DefaultOrder = "XYZ";
sd.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class rc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let TL = 0;
const Ab = /* @__PURE__ */ new q(), Pf = /* @__PURE__ */ new mr(), xo = /* @__PURE__ */ new Qt(), Av = /* @__PURE__ */ new q(), Uh = /* @__PURE__ */ new q(), CL = /* @__PURE__ */ new q(), RL = /* @__PURE__ */ new mr(), Lb = /* @__PURE__ */ new q(1, 0, 0), Db = /* @__PURE__ */ new q(0, 1, 0), Pb = /* @__PURE__ */ new q(0, 0, 1), AL = { type: "added" }, Nb = { type: "removed" };
class xn extends ks {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: TL++ }), this.uuid = va(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = xn.DefaultUp.clone();
    const e = new q(), t = new sd(), n = new mr(), r = new q(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function c() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s), n._onChange(c), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new Qt()
      },
      normalMatrix: {
        value: new Zr()
      }
    }), this.matrix = new Qt(), this.matrixWorld = new Qt(), this.matrixAutoUpdate = xn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = xn.DefaultMatrixWorldAutoUpdate, this.layers = new rc(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Pf.setFromAxisAngle(e, t), this.quaternion.multiply(Pf), this;
  }
  rotateOnWorldAxis(e, t) {
    return Pf.setFromAxisAngle(e, t), this.quaternion.premultiply(Pf), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Lb, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Db, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Pb, e);
  }
  translateOnAxis(e, t) {
    return Ab.copy(e).applyQuaternion(this.quaternion), this.position.add(Ab.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Lb, e);
  }
  translateY(e) {
    return this.translateOnAxis(Db, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Pb, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(xo.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Av.copy(e) : Av.set(e, t, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), Uh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xo.lookAt(Uh, Av, this.up) : xo.lookAt(Av, Uh, this.up), this.quaternion.setFromRotationMatrix(xo), r && (xo.extractRotation(r.matrixWorld), Pf.setFromRotationMatrix(xo), this.quaternion.premultiply(Pf.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(AL)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Nb)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(Nb);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), xo.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), xo.multiply(e.parent.matrixWorld)), e.applyMatrix4(xo), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const c = this.children[n].getObjectByProperty(e, t);
      if (c !== void 0)
        return c;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uh, e, CL), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uh, RL, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, c = r.length; s < c; s++) {
        const f = r[s];
        f.matrixWorldAutoUpdate === !0 && f.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
    function s(f, h) {
      return f[h.uuid] === void 0 && (f[h.uuid] = h.toJSON(e)), h.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const f = this.geometry.parameters;
      if (f !== void 0 && f.shapes !== void 0) {
        const h = f.shapes;
        if (Array.isArray(h))
          for (let m = 0, g = h.length; m < g; m++) {
            const _ = h[m];
            s(e.shapes, _);
          }
        else
          s(e.shapes, h);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const f = [];
        for (let h = 0, m = this.material.length; h < m; h++)
          f.push(s(e.materials, this.material[h]));
        r.material = f;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let f = 0; f < this.children.length; f++)
        r.children.push(this.children[f].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let f = 0; f < this.animations.length; f++) {
        const h = this.animations[f];
        r.animations.push(s(e.animations, h));
      }
    }
    if (t) {
      const f = c(e.geometries), h = c(e.materials), m = c(e.textures), g = c(e.images), _ = c(e.shapes), x = c(e.skeletons), M = c(e.animations), b = c(e.nodes);
      f.length > 0 && (n.geometries = f), h.length > 0 && (n.materials = h), m.length > 0 && (n.textures = m), g.length > 0 && (n.images = g), _.length > 0 && (n.shapes = _), x.length > 0 && (n.skeletons = x), M.length > 0 && (n.animations = M), b.length > 0 && (n.nodes = b);
    }
    return n.object = r, n;
    function c(f) {
      const h = [];
      for (const m in f) {
        const g = f[m];
        delete g.metadata, h.push(g);
      }
      return h;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
xn.DefaultUp = /* @__PURE__ */ new q(0, 1, 0);
xn.DefaultMatrixAutoUpdate = !0;
xn.DefaultMatrixWorldAutoUpdate = !0;
const cs = /* @__PURE__ */ new q(), So = /* @__PURE__ */ new q(), m_ = /* @__PURE__ */ new q(), Mo = /* @__PURE__ */ new q(), Nf = /* @__PURE__ */ new q(), zf = /* @__PURE__ */ new q(), zb = /* @__PURE__ */ new q(), v_ = /* @__PURE__ */ new q(), g_ = /* @__PURE__ */ new q(), y_ = /* @__PURE__ */ new q();
class Ga {
  constructor(e = new q(), t = new q(), n = new q()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, r) {
    r.subVectors(n, t), cs.subVectors(e, t), r.cross(cs);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, r, s) {
    cs.subVectors(r, t), So.subVectors(n, t), m_.subVectors(e, t);
    const c = cs.dot(cs), f = cs.dot(So), h = cs.dot(m_), m = So.dot(So), g = So.dot(m_), _ = c * m - f * f;
    if (_ === 0)
      return s.set(-2, -1, -1);
    const x = 1 / _, M = (m * h - f * g) * x, b = (c * g - f * h) * x;
    return s.set(1 - M - b, b, M);
  }
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, Mo), Mo.x >= 0 && Mo.y >= 0 && Mo.x + Mo.y <= 1;
  }
  static getUV(e, t, n, r, s, c, f, h) {
    return this.getBarycoord(e, t, n, r, Mo), h.set(0, 0), h.addScaledVector(s, Mo.x), h.addScaledVector(c, Mo.y), h.addScaledVector(f, Mo.z), h;
  }
  static isFrontFacing(e, t, n, r) {
    return cs.subVectors(n, t), So.subVectors(e, t), cs.cross(So).dot(r) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, r) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, n, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return cs.subVectors(this.c, this.b), So.subVectors(this.a, this.b), cs.cross(So).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ga.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ga.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, r, s) {
    return Ga.getUV(e, this.a, this.b, this.c, t, n, r, s);
  }
  containsPoint(e) {
    return Ga.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ga.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, r = this.b, s = this.c;
    let c, f;
    Nf.subVectors(r, n), zf.subVectors(s, n), v_.subVectors(e, n);
    const h = Nf.dot(v_), m = zf.dot(v_);
    if (h <= 0 && m <= 0)
      return t.copy(n);
    g_.subVectors(e, r);
    const g = Nf.dot(g_), _ = zf.dot(g_);
    if (g >= 0 && _ <= g)
      return t.copy(r);
    const x = h * _ - g * m;
    if (x <= 0 && h >= 0 && g <= 0)
      return c = h / (h - g), t.copy(n).addScaledVector(Nf, c);
    y_.subVectors(e, s);
    const M = Nf.dot(y_), b = zf.dot(y_);
    if (b >= 0 && M <= b)
      return t.copy(s);
    const E = M * m - h * b;
    if (E <= 0 && m >= 0 && b <= 0)
      return f = m / (m - b), t.copy(n).addScaledVector(zf, f);
    const w = g * b - M * _;
    if (w <= 0 && _ - g >= 0 && M - b >= 0)
      return zb.subVectors(s, r), f = (_ - g) / (_ - g + (M - b)), t.copy(r).addScaledVector(zb, f);
    const R = 1 / (w + E + x);
    return c = E * R, f = x * R, t.copy(n).addScaledVector(Nf, c).addScaledVector(zf, f);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let LL = 0;
class Ki extends ks {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: LL++ }), this.uuid = va(), this.name = "", this.type = "Material", this.blending = ec, this.side = sc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = jx, this.blendDst = Yx, this.blendEquation = ju, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = _g, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = pT, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = vg, this.stencilZFail = vg, this.stencilZPass = vg, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== ec && (n.blending = this.blending), this.side !== sc && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function r(s) {
      const c = [];
      for (const f in s) {
        const h = s[f];
        delete h.metadata, c.push(h);
      }
      return c;
    }
    if (t) {
      const s = r(e.textures), c = r(e.images);
      s.length > 0 && (n.textures = s), c.length > 0 && (n.images = c);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = t[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Wl extends Ki {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new xt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mp, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const xi = /* @__PURE__ */ new q(), Lv = /* @__PURE__ */ new Ue();
class Fn {
  constructor(e, t, n) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n === !0, this.usage = rp, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Lv.fromBufferAttribute(this, t), Lv.applyMatrix3(e), this.setXY(t, Lv.x, Lv.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        xi.fromBufferAttribute(this, t), xi.applyMatrix3(e), this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      xi.fromBufferAttribute(this, t), xi.applyMatrix4(e), this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      xi.fromBufferAttribute(this, t), xi.applyNormalMatrix(e), this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      xi.fromBufferAttribute(this, t), xi.transformDirection(e), this.setXYZ(t, xi.x, xi.y, xi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = To(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = To(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = To(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = To(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Un(t, this.array), n = Un(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = Un(t, this.array), n = Un(n, this.array), r = Un(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, s) {
    return e *= this.itemSize, this.normalized && (t = Un(t, this.array), n = Un(n, this.array), r = Un(r, this.array), s = Un(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== rp && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
  // @deprecated
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
}
class DL extends Fn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class PL extends Fn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class NL extends Fn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class zL extends Fn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class eS extends Fn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class OL extends Fn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class tS extends Fn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class IL extends Fn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
}
class Rt extends Fn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class UL extends Fn {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let FL = 0;
const Ha = /* @__PURE__ */ new Qt(), __ = /* @__PURE__ */ new xn(), Of = /* @__PURE__ */ new q(), ha = /* @__PURE__ */ new fc(), Fh = /* @__PURE__ */ new fc(), ki = /* @__PURE__ */ new q();
class Kt extends ks {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: FL++ }), this.uuid = va(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (vT(e) ? tS : eS)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new Zr().getNormalMatrix(e);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ha.makeRotationFromQuaternion(e), this.applyMatrix4(Ha), this;
  }
  rotateX(e) {
    return Ha.makeRotationX(e), this.applyMatrix4(Ha), this;
  }
  rotateY(e) {
    return Ha.makeRotationY(e), this.applyMatrix4(Ha), this;
  }
  rotateZ(e) {
    return Ha.makeRotationZ(e), this.applyMatrix4(Ha), this;
  }
  translate(e, t, n) {
    return Ha.makeTranslation(e, t, n), this.applyMatrix4(Ha), this;
  }
  scale(e, t, n) {
    return Ha.makeScale(e, t, n), this.applyMatrix4(Ha), this;
  }
  lookAt(e) {
    return __.lookAt(e), __.updateMatrix(), this.applyMatrix4(__.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Of).negate(), this.translate(Of.x, Of.y, Of.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Rt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new fc());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new q(-1 / 0, -1 / 0, -1 / 0),
        new q(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          ha.setFromBufferAttribute(s), this.morphTargetsRelative ? (ki.addVectors(this.boundingBox.min, ha.min), this.boundingBox.expandByPoint(ki), ki.addVectors(this.boundingBox.max, ha.max), this.boundingBox.expandByPoint(ki)) : (this.boundingBox.expandByPoint(ha.min), this.boundingBox.expandByPoint(ha.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new dc());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new q(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (ha.setFromBufferAttribute(e), t)
        for (let s = 0, c = t.length; s < c; s++) {
          const f = t[s];
          Fh.setFromBufferAttribute(f), this.morphTargetsRelative ? (ki.addVectors(ha.min, Fh.min), ha.expandByPoint(ki), ki.addVectors(ha.max, Fh.max), ha.expandByPoint(ki)) : (ha.expandByPoint(Fh.min), ha.expandByPoint(Fh.max));
        }
      ha.getCenter(n);
      let r = 0;
      for (let s = 0, c = e.count; s < c; s++)
        ki.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(ki));
      if (t)
        for (let s = 0, c = t.length; s < c; s++) {
          const f = t[s], h = this.morphTargetsRelative;
          for (let m = 0, g = f.count; m < g; m++)
            ki.fromBufferAttribute(f, m), h && (Of.fromBufferAttribute(e, m), ki.add(Of)), r = Math.max(r, n.distanceToSquared(ki));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, r = t.position.array, s = t.normal.array, c = t.uv.array, f = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Fn(new Float32Array(4 * f), 4));
    const h = this.getAttribute("tangent").array, m = [], g = [];
    for (let G = 0; G < f; G++)
      m[G] = new q(), g[G] = new q();
    const _ = new q(), x = new q(), M = new q(), b = new Ue(), E = new Ue(), w = new Ue(), R = new q(), A = new q();
    function P(G, $, oe) {
      _.fromArray(r, G * 3), x.fromArray(r, $ * 3), M.fromArray(r, oe * 3), b.fromArray(c, G * 2), E.fromArray(c, $ * 2), w.fromArray(c, oe * 2), x.sub(_), M.sub(_), E.sub(b), w.sub(b);
      const ne = 1 / (E.x * w.y - w.x * E.y);
      isFinite(ne) && (R.copy(x).multiplyScalar(w.y).addScaledVector(M, -E.y).multiplyScalar(ne), A.copy(M).multiplyScalar(E.x).addScaledVector(x, -w.x).multiplyScalar(ne), m[G].add(R), m[$].add(R), m[oe].add(R), g[G].add(A), g[$].add(A), g[oe].add(A));
    }
    let N = this.groups;
    N.length === 0 && (N = [{
      start: 0,
      count: n.length
    }]);
    for (let G = 0, $ = N.length; G < $; ++G) {
      const oe = N[G], ne = oe.start, ee = oe.count;
      for (let ye = ne, Me = ne + ee; ye < Me; ye += 3)
        P(
          n[ye + 0],
          n[ye + 1],
          n[ye + 2]
        );
    }
    const I = new q(), B = new q(), W = new q(), z = new q();
    function k(G) {
      W.fromArray(s, G * 3), z.copy(W);
      const $ = m[G];
      I.copy($), I.sub(W.multiplyScalar(W.dot($))).normalize(), B.crossVectors(z, $);
      const ne = B.dot(g[G]) < 0 ? -1 : 1;
      h[G * 4] = I.x, h[G * 4 + 1] = I.y, h[G * 4 + 2] = I.z, h[G * 4 + 3] = ne;
    }
    for (let G = 0, $ = N.length; G < $; ++G) {
      const oe = N[G], ne = oe.start, ee = oe.count;
      for (let ye = ne, Me = ne + ee; ye < Me; ye += 3)
        k(n[ye + 0]), k(n[ye + 1]), k(n[ye + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Fn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let x = 0, M = n.count; x < M; x++)
          n.setXYZ(x, 0, 0, 0);
      const r = new q(), s = new q(), c = new q(), f = new q(), h = new q(), m = new q(), g = new q(), _ = new q();
      if (e)
        for (let x = 0, M = e.count; x < M; x += 3) {
          const b = e.getX(x + 0), E = e.getX(x + 1), w = e.getX(x + 2);
          r.fromBufferAttribute(t, b), s.fromBufferAttribute(t, E), c.fromBufferAttribute(t, w), g.subVectors(c, s), _.subVectors(r, s), g.cross(_), f.fromBufferAttribute(n, b), h.fromBufferAttribute(n, E), m.fromBufferAttribute(n, w), f.add(g), h.add(g), m.add(g), n.setXYZ(b, f.x, f.y, f.z), n.setXYZ(E, h.x, h.y, h.z), n.setXYZ(w, m.x, m.y, m.z);
        }
      else
        for (let x = 0, M = t.count; x < M; x += 3)
          r.fromBufferAttribute(t, x + 0), s.fromBufferAttribute(t, x + 1), c.fromBufferAttribute(t, x + 2), g.subVectors(c, s), _.subVectors(r, s), g.cross(_), n.setXYZ(x + 0, g.x, g.y, g.z), n.setXYZ(x + 1, g.x, g.y, g.z), n.setXYZ(x + 2, g.x, g.y, g.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  // @deprecated since r144
  merge() {
    return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      ki.fromBufferAttribute(e, t), ki.normalize(), e.setXYZ(t, ki.x, ki.y, ki.z);
  }
  toNonIndexed() {
    function e(f, h) {
      const m = f.array, g = f.itemSize, _ = f.normalized, x = new m.constructor(h.length * g);
      let M = 0, b = 0;
      for (let E = 0, w = h.length; E < w; E++) {
        f.isInterleavedBufferAttribute ? M = h[E] * f.data.stride + f.offset : M = h[E] * g;
        for (let R = 0; R < g; R++)
          x[b++] = m[M++];
      }
      return new Fn(x, g, _);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Kt(), n = this.index.array, r = this.attributes;
    for (const f in r) {
      const h = r[f], m = e(h, n);
      t.setAttribute(f, m);
    }
    const s = this.morphAttributes;
    for (const f in s) {
      const h = [], m = s[f];
      for (let g = 0, _ = m.length; g < _; g++) {
        const x = m[g], M = e(x, n);
        h.push(M);
      }
      t.morphAttributes[f] = h;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const c = this.groups;
    for (let f = 0, h = c.length; f < h; f++) {
      const m = c[f];
      t.addGroup(m.start, m.count, m.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const h = this.parameters;
      for (const m in h)
        h[m] !== void 0 && (e[m] = h[m]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const h in n) {
      const m = n[h];
      e.data.attributes[h] = m.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const h in this.morphAttributes) {
      const m = this.morphAttributes[h], g = [];
      for (let _ = 0, x = m.length; _ < x; _++) {
        const M = m[_];
        g.push(M.toJSON(e.data));
      }
      g.length > 0 && (r[h] = g, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const c = this.groups;
    c.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(c)));
    const f = this.boundingSphere;
    return f !== null && (e.data.boundingSphere = {
      center: f.center.toArray(),
      radius: f.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const r = e.attributes;
    for (const m in r) {
      const g = r[m];
      this.setAttribute(m, g.clone(t));
    }
    const s = e.morphAttributes;
    for (const m in s) {
      const g = [], _ = s[m];
      for (let x = 0, M = _.length; x < M; x++)
        g.push(_[x].clone(t));
      this.morphAttributes[m] = g;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const c = e.groups;
    for (let m = 0, g = c.length; m < g; m++) {
      const _ = c[m];
      this.addGroup(_.start, _.count, _.materialIndex);
    }
    const f = e.boundingBox;
    f !== null && (this.boundingBox = f.clone());
    const h = e.boundingSphere;
    return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Ob = /* @__PURE__ */ new Qt(), If = /* @__PURE__ */ new gp(), x_ = /* @__PURE__ */ new dc(), Rl = /* @__PURE__ */ new q(), Al = /* @__PURE__ */ new q(), Ll = /* @__PURE__ */ new q(), S_ = /* @__PURE__ */ new q(), M_ = /* @__PURE__ */ new q(), b_ = /* @__PURE__ */ new q(), Dv = /* @__PURE__ */ new q(), Pv = /* @__PURE__ */ new q(), Nv = /* @__PURE__ */ new q(), zv = /* @__PURE__ */ new Ue(), Ov = /* @__PURE__ */ new Ue(), Iv = /* @__PURE__ */ new Ue(), w_ = /* @__PURE__ */ new q(), Uv = /* @__PURE__ */ new q();
class Qi extends xn {
  constructor(e = new Kt(), t = new Wl()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, c = r.length; s < c; s++) {
          const f = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = s;
        }
      }
    }
  }
  raycast(e, t) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), x_.copy(n.boundingSphere), x_.applyMatrix4(s), e.ray.intersectsSphere(x_) === !1) || (Ob.copy(s).invert(), If.copy(e.ray).applyMatrix4(Ob), n.boundingBox !== null && If.intersectsBox(n.boundingBox) === !1))
      return;
    let c;
    const f = n.index, h = n.attributes.position, m = n.morphAttributes.position, g = n.morphTargetsRelative, _ = n.attributes.uv, x = n.attributes.uv2, M = n.groups, b = n.drawRange;
    if (f !== null)
      if (Array.isArray(r))
        for (let E = 0, w = M.length; E < w; E++) {
          const R = M[E], A = r[R.materialIndex], P = Math.max(R.start, b.start), N = Math.min(f.count, Math.min(R.start + R.count, b.start + b.count));
          for (let I = P, B = N; I < B; I += 3) {
            const W = f.getX(I), z = f.getX(I + 1), k = f.getX(I + 2);
            c = Fv(this, A, e, If, h, m, g, _, x, W, z, k), c && (c.faceIndex = Math.floor(I / 3), c.face.materialIndex = R.materialIndex, t.push(c));
          }
        }
      else {
        const E = Math.max(0, b.start), w = Math.min(f.count, b.start + b.count);
        for (let R = E, A = w; R < A; R += 3) {
          const P = f.getX(R), N = f.getX(R + 1), I = f.getX(R + 2);
          c = Fv(this, r, e, If, h, m, g, _, x, P, N, I), c && (c.faceIndex = Math.floor(R / 3), t.push(c));
        }
      }
    else if (h !== void 0)
      if (Array.isArray(r))
        for (let E = 0, w = M.length; E < w; E++) {
          const R = M[E], A = r[R.materialIndex], P = Math.max(R.start, b.start), N = Math.min(h.count, Math.min(R.start + R.count, b.start + b.count));
          for (let I = P, B = N; I < B; I += 3) {
            const W = I, z = I + 1, k = I + 2;
            c = Fv(this, A, e, If, h, m, g, _, x, W, z, k), c && (c.faceIndex = Math.floor(I / 3), c.face.materialIndex = R.materialIndex, t.push(c));
          }
        }
      else {
        const E = Math.max(0, b.start), w = Math.min(h.count, b.start + b.count);
        for (let R = E, A = w; R < A; R += 3) {
          const P = R, N = R + 1, I = R + 2;
          c = Fv(this, r, e, If, h, m, g, _, x, P, N, I), c && (c.faceIndex = Math.floor(R / 3), t.push(c));
        }
      }
  }
}
function BL(u, e, t, n, r, s, c, f) {
  let h;
  if (e.side === ma ? h = n.intersectTriangle(c, s, r, !0, f) : h = n.intersectTriangle(r, s, c, e.side !== Fs, f), h === null)
    return null;
  Uv.copy(f), Uv.applyMatrix4(u.matrixWorld);
  const m = t.ray.origin.distanceTo(Uv);
  return m < t.near || m > t.far ? null : {
    distance: m,
    point: Uv.clone(),
    object: u
  };
}
function Fv(u, e, t, n, r, s, c, f, h, m, g, _) {
  Rl.fromBufferAttribute(r, m), Al.fromBufferAttribute(r, g), Ll.fromBufferAttribute(r, _);
  const x = u.morphTargetInfluences;
  if (s && x) {
    Dv.set(0, 0, 0), Pv.set(0, 0, 0), Nv.set(0, 0, 0);
    for (let b = 0, E = s.length; b < E; b++) {
      const w = x[b], R = s[b];
      w !== 0 && (S_.fromBufferAttribute(R, m), M_.fromBufferAttribute(R, g), b_.fromBufferAttribute(R, _), c ? (Dv.addScaledVector(S_, w), Pv.addScaledVector(M_, w), Nv.addScaledVector(b_, w)) : (Dv.addScaledVector(S_.sub(Rl), w), Pv.addScaledVector(M_.sub(Al), w), Nv.addScaledVector(b_.sub(Ll), w)));
    }
    Rl.add(Dv), Al.add(Pv), Ll.add(Nv);
  }
  u.isSkinnedMesh && (u.boneTransform(m, Rl), u.boneTransform(g, Al), u.boneTransform(_, Ll));
  const M = BL(u, e, t, n, Rl, Al, Ll, w_);
  if (M) {
    f && (zv.fromBufferAttribute(f, m), Ov.fromBufferAttribute(f, g), Iv.fromBufferAttribute(f, _), M.uv = Ga.getUV(w_, Rl, Al, Ll, zv, Ov, Iv, new Ue())), h && (zv.fromBufferAttribute(h, m), Ov.fromBufferAttribute(h, g), Iv.fromBufferAttribute(h, _), M.uv2 = Ga.getUV(w_, Rl, Al, Ll, zv, Ov, Iv, new Ue()));
    const b = {
      a: m,
      b: g,
      c: _,
      normal: new q(),
      materialIndex: 0
    };
    Ga.getNormal(Rl, Al, Ll, b.normal), M.face = b;
  }
  return M;
}
class ql extends Kt {
  constructor(e = 1, t = 1, n = 1, r = 1, s = 1, c = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: r,
      heightSegments: s,
      depthSegments: c
    };
    const f = this;
    r = Math.floor(r), s = Math.floor(s), c = Math.floor(c);
    const h = [], m = [], g = [], _ = [];
    let x = 0, M = 0;
    b("z", "y", "x", -1, -1, n, t, e, c, s, 0), b("z", "y", "x", 1, -1, n, t, -e, c, s, 1), b("x", "z", "y", 1, 1, e, n, t, r, c, 2), b("x", "z", "y", 1, -1, e, n, -t, r, c, 3), b("x", "y", "z", 1, -1, e, t, n, r, s, 4), b("x", "y", "z", -1, -1, e, t, -n, r, s, 5), this.setIndex(h), this.setAttribute("position", new Rt(m, 3)), this.setAttribute("normal", new Rt(g, 3)), this.setAttribute("uv", new Rt(_, 2));
    function b(E, w, R, A, P, N, I, B, W, z, k) {
      const G = N / W, $ = I / z, oe = N / 2, ne = I / 2, ee = B / 2, ye = W + 1, Me = z + 1;
      let De = 0, V = 0;
      const J = new q();
      for (let Y = 0; Y < Me; Y++) {
        const de = Y * $ - ne;
        for (let le = 0; le < ye; le++) {
          const Pe = le * G - oe;
          J[E] = Pe * A, J[w] = de * P, J[R] = ee, m.push(J.x, J.y, J.z), J[E] = 0, J[w] = 0, J[R] = B > 0 ? 1 : -1, g.push(J.x, J.y, J.z), _.push(le / W), _.push(1 - Y / z), De += 1;
        }
      }
      for (let Y = 0; Y < z; Y++)
        for (let de = 0; de < W; de++) {
          const le = x + de + ye * Y, Pe = x + de + ye * (Y + 1), We = x + (de + 1) + ye * (Y + 1), $e = x + (de + 1) + ye * Y;
          h.push(le, Pe, $e), h.push(Pe, We, $e), V += 6;
        }
      f.addGroup(M, V, k), M += V, x += De;
    }
  }
  static fromJSON(e) {
    return new ql(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function nd(u) {
  const e = {};
  for (const t in u) {
    e[t] = {};
    for (const n in u[t]) {
      const r = u[t][n];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r;
    }
  }
  return e;
}
function pr(u) {
  const e = {};
  for (let t = 0; t < u.length; t++) {
    const n = nd(u[t]);
    for (const r in n)
      e[r] = n[r];
  }
  return e;
}
function HL(u) {
  const e = [];
  for (let t = 0; t < u.length; t++)
    e.push(u[t].clone());
  return e;
}
const yT = { clone: nd, merge: pr };
var kL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, VL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Hs extends Ki {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = kL, this.fragmentShader = VL, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = nd(e.uniforms), this.uniformsGroups = HL(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const c = this.uniforms[r].value;
      c && c.isTexture ? t.uniforms[r] = {
        type: "t",
        value: c.toJSON(e).uuid
      } : c && c.isColor ? t.uniforms[r] = {
        type: "c",
        value: c.getHex()
      } : c && c.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: c.toArray()
      } : c && c.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: c.toArray()
      } : c && c.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: c.toArray()
      } : c && c.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: c.toArray()
      } : c && c.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: c.toArray()
      } : t.uniforms[r] = {
        value: c
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const n = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class yp extends xn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Qt(), this.projectionMatrix = new Qt(), this.projectionMatrixInverse = new Qt();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Vi extends yp {
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = ap * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(nc * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return ap * 2 * Math.atan(
      Math.tan(nc * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, r, s, c) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = c, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(nc * 0.5 * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, s = -0.5 * r;
    const c = this.view;
    if (this.view !== null && this.view.enabled) {
      const h = c.fullWidth, m = c.fullHeight;
      s += c.offsetX * r / h, t -= c.offsetY * n / m, r *= c.width / h, n *= c.height / m;
    }
    const f = this.filmOffset;
    f !== 0 && (s += e * f / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Uf = 90, Ff = 1;
class _T extends xn {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n;
    const r = new Vi(Uf, Ff, e, t);
    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new q(1, 0, 0)), this.add(r);
    const s = new Vi(Uf, Ff, e, t);
    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new q(-1, 0, 0)), this.add(s);
    const c = new Vi(Uf, Ff, e, t);
    c.layers = this.layers, c.up.set(0, 0, 1), c.lookAt(new q(0, 1, 0)), this.add(c);
    const f = new Vi(Uf, Ff, e, t);
    f.layers = this.layers, f.up.set(0, 0, -1), f.lookAt(new q(0, -1, 0)), this.add(f);
    const h = new Vi(Uf, Ff, e, t);
    h.layers = this.layers, h.up.set(0, -1, 0), h.lookAt(new q(0, 0, 1)), this.add(h);
    const m = new Vi(Uf, Ff, e, t);
    m.layers = this.layers, m.up.set(0, -1, 0), m.lookAt(new q(0, 0, -1)), this.add(m);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget, [r, s, c, f, h, m] = this.children, g = e.getRenderTarget(), _ = e.toneMapping, x = e.xr.enabled;
    e.toneMapping = ds, e.xr.enabled = !1;
    const M = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, c), e.setRenderTarget(n, 3), e.render(t, f), e.setRenderTarget(n, 4), e.render(t, h), n.texture.generateMipmaps = M, e.setRenderTarget(n, 5), e.render(t, m), e.setRenderTarget(g), e.toneMapping = _, e.xr.enabled = x, n.texture.needsPMREMUpdate = !0;
  }
}
class _p extends Mi {
  constructor(e, t, n, r, s, c, f, h, m, g) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Fl, super(e, t, n, r, s, c, f, h, m, g), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class xT extends Wa {
  constructor(e, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n];
    this.texture = new _p(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : vi;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new ql(5, 5, 5), s = new Hs({
      name: "CubemapFromEquirect",
      uniforms: nd(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: ma,
      blending: Co
    });
    s.uniforms.tEquirect.value = t;
    const c = new Qi(r, s), f = t.minFilter;
    return t.minFilter === cc && (t.minFilter = vi), new _T(1, 10, this).update(e, c), t.minFilter = f, c.geometry.dispose(), c.material.dispose(), this;
  }
  clear(e, t, n, r) {
    const s = e.getRenderTarget();
    for (let c = 0; c < 6; c++)
      e.setRenderTarget(this, c), e.clear(t, n, r);
    e.setRenderTarget(s);
  }
}
const E_ = /* @__PURE__ */ new q(), GL = /* @__PURE__ */ new q(), WL = /* @__PURE__ */ new Zr();
class zl {
  constructor(e = new q(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, r) {
    return this.normal.set(e, t, n), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const r = E_.subVectors(n, t).cross(GL.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const n = e.delta(E_), r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(n).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || WL.getNormalMatrix(e), r = this.coplanarPoint(E_).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Bf = /* @__PURE__ */ new dc(), Bv = /* @__PURE__ */ new q();
class Ng {
  constructor(e = new zl(), t = new zl(), n = new zl(), r = new zl(), s = new zl(), c = new zl()) {
    this.planes = [e, t, n, r, s, c];
  }
  set(e, t, n, r, s, c) {
    const f = this.planes;
    return f[0].copy(e), f[1].copy(t), f[2].copy(n), f[3].copy(r), f[4].copy(s), f[5].copy(c), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, n = e.elements, r = n[0], s = n[1], c = n[2], f = n[3], h = n[4], m = n[5], g = n[6], _ = n[7], x = n[8], M = n[9], b = n[10], E = n[11], w = n[12], R = n[13], A = n[14], P = n[15];
    return t[0].setComponents(f - r, _ - h, E - x, P - w).normalize(), t[1].setComponents(f + r, _ + h, E + x, P + w).normalize(), t[2].setComponents(f + s, _ + m, E + M, P + R).normalize(), t[3].setComponents(f - s, _ - m, E - M, P - R).normalize(), t[4].setComponents(f - c, _ - g, E - b, P - A).normalize(), t[5].setComponents(f + c, _ + g, E + b, P + A).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), Bf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Bf);
  }
  intersectsSprite(e) {
    return Bf.center.set(0, 0, 0), Bf.radius = 0.7071067811865476, Bf.applyMatrix4(e.matrixWorld), this.intersectsSphere(Bf);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(n) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (Bv.x = r.normal.x > 0 ? e.max.x : e.min.x, Bv.y = r.normal.y > 0 ? e.max.y : e.min.y, Bv.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Bv) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ST() {
  let u = null, e = !1, t = null, n = null;
  function r(s, c) {
    t(s, c), n = u.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = u.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      u.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      u = s;
    }
  };
}
function qL(u, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function r(m, g) {
    const _ = m.array, x = m.usage, M = u.createBuffer();
    u.bindBuffer(g, M), u.bufferData(g, _, x), m.onUploadCallback();
    let b;
    if (_ instanceof Float32Array)
      b = 5126;
    else if (_ instanceof Uint16Array)
      if (m.isFloat16BufferAttribute)
        if (t)
          b = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        b = 5123;
    else if (_ instanceof Int16Array)
      b = 5122;
    else if (_ instanceof Uint32Array)
      b = 5125;
    else if (_ instanceof Int32Array)
      b = 5124;
    else if (_ instanceof Int8Array)
      b = 5120;
    else if (_ instanceof Uint8Array)
      b = 5121;
    else if (_ instanceof Uint8ClampedArray)
      b = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + _);
    return {
      buffer: M,
      type: b,
      bytesPerElement: _.BYTES_PER_ELEMENT,
      version: m.version
    };
  }
  function s(m, g, _) {
    const x = g.array, M = g.updateRange;
    u.bindBuffer(_, m), M.count === -1 ? u.bufferSubData(_, 0, x) : (t ? u.bufferSubData(
      _,
      M.offset * x.BYTES_PER_ELEMENT,
      x,
      M.offset,
      M.count
    ) : u.bufferSubData(
      _,
      M.offset * x.BYTES_PER_ELEMENT,
      x.subarray(M.offset, M.offset + M.count)
    ), M.count = -1);
  }
  function c(m) {
    return m.isInterleavedBufferAttribute && (m = m.data), n.get(m);
  }
  function f(m) {
    m.isInterleavedBufferAttribute && (m = m.data);
    const g = n.get(m);
    g && (u.deleteBuffer(g.buffer), n.delete(m));
  }
  function h(m, g) {
    if (m.isGLBufferAttribute) {
      const x = n.get(m);
      (!x || x.version < m.version) && n.set(m, {
        buffer: m.buffer,
        type: m.type,
        bytesPerElement: m.elementSize,
        version: m.version
      });
      return;
    }
    m.isInterleavedBufferAttribute && (m = m.data);
    const _ = n.get(m);
    _ === void 0 ? n.set(m, r(m, g)) : _.version < m.version && (s(_.buffer, m, g), _.version = m.version);
  }
  return {
    get: c,
    remove: f,
    update: h
  };
}
class od extends Kt {
  constructor(e = 1, t = 1, n = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: r
    };
    const s = e / 2, c = t / 2, f = Math.floor(n), h = Math.floor(r), m = f + 1, g = h + 1, _ = e / f, x = t / h, M = [], b = [], E = [], w = [];
    for (let R = 0; R < g; R++) {
      const A = R * x - c;
      for (let P = 0; P < m; P++) {
        const N = P * _ - s;
        b.push(N, -A, 0), E.push(0, 0, 1), w.push(P / f), w.push(1 - R / h);
      }
    }
    for (let R = 0; R < h; R++)
      for (let A = 0; A < f; A++) {
        const P = A + m * R, N = A + m * (R + 1), I = A + 1 + m * (R + 1), B = A + 1 + m * R;
        M.push(P, N, B), M.push(N, I, B);
      }
    this.setIndex(M), this.setAttribute("position", new Rt(b, 3)), this.setAttribute("normal", new Rt(E, 3)), this.setAttribute("uv", new Rt(w, 2));
  }
  static fromJSON(e) {
    return new od(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var jL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, YL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, XL = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, ZL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, JL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, QL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, KL = "vec3 transformed = vec3( position );", $L = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, eD = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, tD = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, nD = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, iD = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, rD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, aD = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, sD = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, oD = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, lD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, uD = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, cD = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, fD = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, dD = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, hD = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, pD = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, mD = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, vD = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, gD = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, yD = "gl_FragColor = linearToOutputTexel( gl_FragColor );", _D = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, xD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, SD = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, MD = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, bD = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, wD = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, ED = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, TD = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, CD = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, RD = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, AD = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, LD = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, DD = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, PD = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, ND = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`, zD = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, OD = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, ID = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, UD = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, FD = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, BD = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, HD = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, kD = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, VD = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, GD = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, WD = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, qD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, jD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, YD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, XD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, ZD = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, JD = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, QD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, KD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, $D = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, eP = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, tP = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, nP = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, iP = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, rP = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, aP = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, sP = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, oP = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, lP = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, uP = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, cP = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, fP = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, dP = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, hP = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, pP = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, mP = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, vP = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, gP = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, yP = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, _P = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, xP = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, SP = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, MP = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, bP = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, wP = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, EP = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, TP = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, CP = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, RP = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, AP = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, LP = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, DP = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, PP = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, NP = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, zP = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, OP = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, IP = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, UP = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, FP = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, BP = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, HP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, kP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, VP = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, GP = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const WP = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, qP = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, jP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, YP = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, XP = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ZP = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, JP = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, QP = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, KP = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, $P = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, eN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, tN = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, nN = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, iN = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rN = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, aN = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, sN = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, oN = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lN = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, uN = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, cN = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, fN = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, dN = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, hN = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, pN = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, mN = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vN = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, gN = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, yN = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, _N = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, xN = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, SN = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, nn = {
  alphamap_fragment: jL,
  alphamap_pars_fragment: YL,
  alphatest_fragment: XL,
  alphatest_pars_fragment: ZL,
  aomap_fragment: JL,
  aomap_pars_fragment: QL,
  begin_vertex: KL,
  beginnormal_vertex: $L,
  bsdfs: eD,
  iridescence_fragment: tD,
  bumpmap_pars_fragment: nD,
  clipping_planes_fragment: iD,
  clipping_planes_pars_fragment: rD,
  clipping_planes_pars_vertex: aD,
  clipping_planes_vertex: sD,
  color_fragment: oD,
  color_pars_fragment: lD,
  color_pars_vertex: uD,
  color_vertex: cD,
  common: fD,
  cube_uv_reflection_fragment: dD,
  defaultnormal_vertex: hD,
  displacementmap_pars_vertex: pD,
  displacementmap_vertex: mD,
  emissivemap_fragment: vD,
  emissivemap_pars_fragment: gD,
  encodings_fragment: yD,
  encodings_pars_fragment: _D,
  envmap_fragment: xD,
  envmap_common_pars_fragment: SD,
  envmap_pars_fragment: MD,
  envmap_pars_vertex: bD,
  envmap_physical_pars_fragment: OD,
  envmap_vertex: wD,
  fog_vertex: ED,
  fog_pars_vertex: TD,
  fog_fragment: CD,
  fog_pars_fragment: RD,
  gradientmap_pars_fragment: AD,
  lightmap_fragment: LD,
  lightmap_pars_fragment: DD,
  lights_lambert_fragment: PD,
  lights_lambert_pars_fragment: ND,
  lights_pars_begin: zD,
  lights_toon_fragment: ID,
  lights_toon_pars_fragment: UD,
  lights_phong_fragment: FD,
  lights_phong_pars_fragment: BD,
  lights_physical_fragment: HD,
  lights_physical_pars_fragment: kD,
  lights_fragment_begin: VD,
  lights_fragment_maps: GD,
  lights_fragment_end: WD,
  logdepthbuf_fragment: qD,
  logdepthbuf_pars_fragment: jD,
  logdepthbuf_pars_vertex: YD,
  logdepthbuf_vertex: XD,
  map_fragment: ZD,
  map_pars_fragment: JD,
  map_particle_fragment: QD,
  map_particle_pars_fragment: KD,
  metalnessmap_fragment: $D,
  metalnessmap_pars_fragment: eP,
  morphcolor_vertex: tP,
  morphnormal_vertex: nP,
  morphtarget_pars_vertex: iP,
  morphtarget_vertex: rP,
  normal_fragment_begin: aP,
  normal_fragment_maps: sP,
  normal_pars_fragment: oP,
  normal_pars_vertex: lP,
  normal_vertex: uP,
  normalmap_pars_fragment: cP,
  clearcoat_normal_fragment_begin: fP,
  clearcoat_normal_fragment_maps: dP,
  clearcoat_pars_fragment: hP,
  iridescence_pars_fragment: pP,
  output_fragment: mP,
  packing: vP,
  premultiplied_alpha_fragment: gP,
  project_vertex: yP,
  dithering_fragment: _P,
  dithering_pars_fragment: xP,
  roughnessmap_fragment: SP,
  roughnessmap_pars_fragment: MP,
  shadowmap_pars_fragment: bP,
  shadowmap_pars_vertex: wP,
  shadowmap_vertex: EP,
  shadowmask_pars_fragment: TP,
  skinbase_vertex: CP,
  skinning_pars_vertex: RP,
  skinning_vertex: AP,
  skinnormal_vertex: LP,
  specularmap_fragment: DP,
  specularmap_pars_fragment: PP,
  tonemapping_fragment: NP,
  tonemapping_pars_fragment: zP,
  transmission_fragment: OP,
  transmission_pars_fragment: IP,
  uv_pars_fragment: UP,
  uv_pars_vertex: FP,
  uv_vertex: BP,
  uv2_pars_fragment: HP,
  uv2_pars_vertex: kP,
  uv2_vertex: VP,
  worldpos_vertex: GP,
  background_vert: WP,
  background_frag: qP,
  cube_vert: jP,
  cube_frag: YP,
  depth_vert: XP,
  depth_frag: ZP,
  distanceRGBA_vert: JP,
  distanceRGBA_frag: QP,
  equirect_vert: KP,
  equirect_frag: $P,
  linedashed_vert: eN,
  linedashed_frag: tN,
  meshbasic_vert: nN,
  meshbasic_frag: iN,
  meshlambert_vert: rN,
  meshlambert_frag: aN,
  meshmatcap_vert: sN,
  meshmatcap_frag: oN,
  meshnormal_vert: lN,
  meshnormal_frag: uN,
  meshphong_vert: cN,
  meshphong_frag: fN,
  meshphysical_vert: dN,
  meshphysical_frag: hN,
  meshtoon_vert: pN,
  meshtoon_frag: mN,
  points_vert: vN,
  points_frag: gN,
  shadow_vert: yN,
  shadow_frag: _N,
  sprite_vert: xN,
  sprite_frag: SN
}, lt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Zr() },
    uv2Transform: { value: /* @__PURE__ */ new Zr() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new Ue(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new xt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Zr() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new xt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ue(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Zr() }
  }
}, fs = {
  basic: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.specularmap,
      lt.envmap,
      lt.aomap,
      lt.lightmap,
      lt.fog
    ]),
    vertexShader: nn.meshbasic_vert,
    fragmentShader: nn.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.specularmap,
      lt.envmap,
      lt.aomap,
      lt.lightmap,
      lt.emissivemap,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      lt.fog,
      lt.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) }
      }
    ]),
    vertexShader: nn.meshlambert_vert,
    fragmentShader: nn.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.specularmap,
      lt.envmap,
      lt.aomap,
      lt.lightmap,
      lt.emissivemap,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      lt.fog,
      lt.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) },
        specular: { value: /* @__PURE__ */ new xt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: nn.meshphong_vert,
    fragmentShader: nn.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.envmap,
      lt.aomap,
      lt.lightmap,
      lt.emissivemap,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      lt.roughnessmap,
      lt.metalnessmap,
      lt.fog,
      lt.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: nn.meshphysical_vert,
    fragmentShader: nn.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.aomap,
      lt.lightmap,
      lt.emissivemap,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      lt.gradientmap,
      lt.fog,
      lt.lights,
      {
        emissive: { value: /* @__PURE__ */ new xt(0) }
      }
    ]),
    vertexShader: nn.meshtoon_vert,
    fragmentShader: nn.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      lt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: nn.meshmatcap_vert,
    fragmentShader: nn.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ pr([
      lt.points,
      lt.fog
    ]),
    vertexShader: nn.points_vert,
    fragmentShader: nn.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: nn.linedashed_vert,
    fragmentShader: nn.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.displacementmap
    ]),
    vertexShader: nn.depth_vert,
    fragmentShader: nn.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.bumpmap,
      lt.normalmap,
      lt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nn.meshnormal_vert,
    fragmentShader: nn.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ pr([
      lt.sprite,
      lt.fog
    ]),
    vertexShader: nn.sprite_vert,
    fragmentShader: nn.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Zr() },
      t2D: { value: null }
    },
    vertexShader: nn.background_vert,
    fragmentShader: nn.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ pr([
      lt.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nn.cube_vert,
    fragmentShader: nn.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: nn.equirect_vert,
    fragmentShader: nn.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ pr([
      lt.common,
      lt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new q() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: nn.distanceRGBA_vert,
    fragmentShader: nn.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ pr([
      lt.lights,
      lt.fog,
      {
        color: { value: /* @__PURE__ */ new xt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: nn.shadow_vert,
    fragmentShader: nn.shadow_frag
  }
};
fs.physical = {
  uniforms: /* @__PURE__ */ pr([
    fs.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ue(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new xt(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ue() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new xt(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new xt(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: nn.meshphysical_vert,
  fragmentShader: nn.meshphysical_frag
};
function MN(u, e, t, n, r, s) {
  const c = new xt(0);
  let f = r === !0 ? 0 : 1, h, m, g = null, _ = 0, x = null;
  function M(E, w) {
    let R = !1, A = w.isScene === !0 ? w.background : null;
    A && A.isTexture && (A = e.get(A));
    const P = u.xr, N = P.getSession && P.getSession();
    N && N.environmentBlendMode === "additive" && (A = null), A === null ? b(c, f) : A && A.isColor && (b(A, 1), R = !0), (u.autoClear || R) && u.clear(u.autoClearColor, u.autoClearDepth, u.autoClearStencil), A && (A.isCubeTexture || A.mapping === ad) ? (m === void 0 && (m = new Qi(
      new ql(1, 1, 1),
      new Hs({
        name: "BackgroundCubeMaterial",
        uniforms: nd(fs.cube.uniforms),
        vertexShader: fs.cube.vertexShader,
        fragmentShader: fs.cube.fragmentShader,
        side: ma,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), m.geometry.deleteAttribute("normal"), m.geometry.deleteAttribute("uv"), m.onBeforeRender = function(I, B, W) {
      this.matrixWorld.copyPosition(W.matrixWorld);
    }, Object.defineProperty(m.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), n.update(m)), m.material.uniforms.envMap.value = A, m.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, (g !== A || _ !== A.version || x !== u.toneMapping) && (m.material.needsUpdate = !0, g = A, _ = A.version, x = u.toneMapping), m.layers.enableAll(), E.unshift(m, m.geometry, m.material, 0, 0, null)) : A && A.isTexture && (h === void 0 && (h = new Qi(
      new od(2, 2),
      new Hs({
        name: "BackgroundMaterial",
        uniforms: nd(fs.background.uniforms),
        vertexShader: fs.background.vertexShader,
        fragmentShader: fs.background.fragmentShader,
        side: sc,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), n.update(h)), h.material.uniforms.t2D.value = A, A.matrixAutoUpdate === !0 && A.updateMatrix(), h.material.uniforms.uvTransform.value.copy(A.matrix), (g !== A || _ !== A.version || x !== u.toneMapping) && (h.material.needsUpdate = !0, g = A, _ = A.version, x = u.toneMapping), h.layers.enableAll(), E.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function b(E, w) {
    t.buffers.color.setClear(E.r, E.g, E.b, w, s);
  }
  return {
    getClearColor: function() {
      return c;
    },
    setClearColor: function(E, w = 1) {
      c.set(E), f = w, b(c, f);
    },
    getClearAlpha: function() {
      return f;
    },
    setClearAlpha: function(E) {
      f = E, b(c, f);
    },
    render: M
  };
}
function bN(u, e, t, n) {
  const r = u.getParameter(34921), s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), c = n.isWebGL2 || s !== null, f = {}, h = w(null);
  let m = h, g = !1;
  function _(ee, ye, Me, De, V) {
    let J = !1;
    if (c) {
      const Y = E(De, Me, ye);
      m !== Y && (m = Y, M(m.object)), J = R(ee, De, Me, V), J && A(ee, De, Me, V);
    } else {
      const Y = ye.wireframe === !0;
      (m.geometry !== De.id || m.program !== Me.id || m.wireframe !== Y) && (m.geometry = De.id, m.program = Me.id, m.wireframe = Y, J = !0);
    }
    V !== null && t.update(V, 34963), (J || g) && (g = !1, z(ee, ye, Me, De), V !== null && u.bindBuffer(34963, t.get(V).buffer));
  }
  function x() {
    return n.isWebGL2 ? u.createVertexArray() : s.createVertexArrayOES();
  }
  function M(ee) {
    return n.isWebGL2 ? u.bindVertexArray(ee) : s.bindVertexArrayOES(ee);
  }
  function b(ee) {
    return n.isWebGL2 ? u.deleteVertexArray(ee) : s.deleteVertexArrayOES(ee);
  }
  function E(ee, ye, Me) {
    const De = Me.wireframe === !0;
    let V = f[ee.id];
    V === void 0 && (V = {}, f[ee.id] = V);
    let J = V[ye.id];
    J === void 0 && (J = {}, V[ye.id] = J);
    let Y = J[De];
    return Y === void 0 && (Y = w(x()), J[De] = Y), Y;
  }
  function w(ee) {
    const ye = [], Me = [], De = [];
    for (let V = 0; V < r; V++)
      ye[V] = 0, Me[V] = 0, De[V] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: ye,
      enabledAttributes: Me,
      attributeDivisors: De,
      object: ee,
      attributes: {},
      index: null
    };
  }
  function R(ee, ye, Me, De) {
    const V = m.attributes, J = ye.attributes;
    let Y = 0;
    const de = Me.getAttributes();
    for (const le in de)
      if (de[le].location >= 0) {
        const We = V[le];
        let $e = J[le];
        if ($e === void 0 && (le === "instanceMatrix" && ee.instanceMatrix && ($e = ee.instanceMatrix), le === "instanceColor" && ee.instanceColor && ($e = ee.instanceColor)), We === void 0 || We.attribute !== $e || $e && We.data !== $e.data)
          return !0;
        Y++;
      }
    return m.attributesNum !== Y || m.index !== De;
  }
  function A(ee, ye, Me, De) {
    const V = {}, J = ye.attributes;
    let Y = 0;
    const de = Me.getAttributes();
    for (const le in de)
      if (de[le].location >= 0) {
        let We = J[le];
        We === void 0 && (le === "instanceMatrix" && ee.instanceMatrix && (We = ee.instanceMatrix), le === "instanceColor" && ee.instanceColor && (We = ee.instanceColor));
        const $e = {};
        $e.attribute = We, We && We.data && ($e.data = We.data), V[le] = $e, Y++;
      }
    m.attributes = V, m.attributesNum = Y, m.index = De;
  }
  function P() {
    const ee = m.newAttributes;
    for (let ye = 0, Me = ee.length; ye < Me; ye++)
      ee[ye] = 0;
  }
  function N(ee) {
    I(ee, 0);
  }
  function I(ee, ye) {
    const Me = m.newAttributes, De = m.enabledAttributes, V = m.attributeDivisors;
    Me[ee] = 1, De[ee] === 0 && (u.enableVertexAttribArray(ee), De[ee] = 1), V[ee] !== ye && ((n.isWebGL2 ? u : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](ee, ye), V[ee] = ye);
  }
  function B() {
    const ee = m.newAttributes, ye = m.enabledAttributes;
    for (let Me = 0, De = ye.length; Me < De; Me++)
      ye[Me] !== ee[Me] && (u.disableVertexAttribArray(Me), ye[Me] = 0);
  }
  function W(ee, ye, Me, De, V, J) {
    n.isWebGL2 === !0 && (Me === 5124 || Me === 5125) ? u.vertexAttribIPointer(ee, ye, Me, V, J) : u.vertexAttribPointer(ee, ye, Me, De, V, J);
  }
  function z(ee, ye, Me, De) {
    if (n.isWebGL2 === !1 && (ee.isInstancedMesh || De.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    P();
    const V = De.attributes, J = Me.getAttributes(), Y = ye.defaultAttributeValues;
    for (const de in J) {
      const le = J[de];
      if (le.location >= 0) {
        let Pe = V[de];
        if (Pe === void 0 && (de === "instanceMatrix" && ee.instanceMatrix && (Pe = ee.instanceMatrix), de === "instanceColor" && ee.instanceColor && (Pe = ee.instanceColor)), Pe !== void 0) {
          const We = Pe.normalized, $e = Pe.itemSize, ve = t.get(Pe);
          if (ve === void 0)
            continue;
          const gt = ve.buffer, ot = ve.type, _t = ve.bytesPerElement;
          if (Pe.isInterleavedBufferAttribute) {
            const Qe = Pe.data, At = Qe.stride, Ne = Pe.offset;
            if (Qe.isInstancedInterleavedBuffer) {
              for (let we = 0; we < le.locationSize; we++)
                I(le.location + we, Qe.meshPerAttribute);
              ee.isInstancedMesh !== !0 && De._maxInstanceCount === void 0 && (De._maxInstanceCount = Qe.meshPerAttribute * Qe.count);
            } else
              for (let we = 0; we < le.locationSize; we++)
                N(le.location + we);
            u.bindBuffer(34962, gt);
            for (let we = 0; we < le.locationSize; we++)
              W(
                le.location + we,
                $e / le.locationSize,
                ot,
                We,
                At * _t,
                (Ne + $e / le.locationSize * we) * _t
              );
          } else {
            if (Pe.isInstancedBufferAttribute) {
              for (let Qe = 0; Qe < le.locationSize; Qe++)
                I(le.location + Qe, Pe.meshPerAttribute);
              ee.isInstancedMesh !== !0 && De._maxInstanceCount === void 0 && (De._maxInstanceCount = Pe.meshPerAttribute * Pe.count);
            } else
              for (let Qe = 0; Qe < le.locationSize; Qe++)
                N(le.location + Qe);
            u.bindBuffer(34962, gt);
            for (let Qe = 0; Qe < le.locationSize; Qe++)
              W(
                le.location + Qe,
                $e / le.locationSize,
                ot,
                We,
                $e * _t,
                $e / le.locationSize * Qe * _t
              );
          }
        } else if (Y !== void 0) {
          const We = Y[de];
          if (We !== void 0)
            switch (We.length) {
              case 2:
                u.vertexAttrib2fv(le.location, We);
                break;
              case 3:
                u.vertexAttrib3fv(le.location, We);
                break;
              case 4:
                u.vertexAttrib4fv(le.location, We);
                break;
              default:
                u.vertexAttrib1fv(le.location, We);
            }
        }
      }
    }
    B();
  }
  function k() {
    oe();
    for (const ee in f) {
      const ye = f[ee];
      for (const Me in ye) {
        const De = ye[Me];
        for (const V in De)
          b(De[V].object), delete De[V];
        delete ye[Me];
      }
      delete f[ee];
    }
  }
  function G(ee) {
    if (f[ee.id] === void 0)
      return;
    const ye = f[ee.id];
    for (const Me in ye) {
      const De = ye[Me];
      for (const V in De)
        b(De[V].object), delete De[V];
      delete ye[Me];
    }
    delete f[ee.id];
  }
  function $(ee) {
    for (const ye in f) {
      const Me = f[ye];
      if (Me[ee.id] === void 0)
        continue;
      const De = Me[ee.id];
      for (const V in De)
        b(De[V].object), delete De[V];
      delete Me[ee.id];
    }
  }
  function oe() {
    ne(), g = !0, m !== h && (m = h, M(m.object));
  }
  function ne() {
    h.geometry = null, h.program = null, h.wireframe = !1;
  }
  return {
    setup: _,
    reset: oe,
    resetDefaultState: ne,
    dispose: k,
    releaseStatesOfGeometry: G,
    releaseStatesOfProgram: $,
    initAttributes: P,
    enableAttribute: N,
    disableUnusedAttributes: B
  };
}
function wN(u, e, t, n) {
  const r = n.isWebGL2;
  let s;
  function c(m) {
    s = m;
  }
  function f(m, g) {
    u.drawArrays(s, m, g), t.update(g, s, 1);
  }
  function h(m, g, _) {
    if (_ === 0)
      return;
    let x, M;
    if (r)
      x = u, M = "drawArraysInstanced";
    else if (x = e.get("ANGLE_instanced_arrays"), M = "drawArraysInstancedANGLE", x === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    x[M](s, m, g, _), t.update(g, s, _);
  }
  this.setMode = c, this.render = f, this.renderInstances = h;
}
function EN(u, e, t) {
  let n;
  function r() {
    if (n !== void 0)
      return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const W = e.get("EXT_texture_filter_anisotropic");
      n = u.getParameter(W.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function s(W) {
    if (W === "highp") {
      if (u.getShaderPrecisionFormat(35633, 36338).precision > 0 && u.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      W = "mediump";
    }
    return W === "mediump" && u.getShaderPrecisionFormat(35633, 36337).precision > 0 && u.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const c = typeof WebGL2RenderingContext < "u" && u instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && u instanceof WebGL2ComputeRenderingContext;
  let f = t.precision !== void 0 ? t.precision : "highp";
  const h = s(f);
  h !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", h, "instead."), f = h);
  const m = c || e.has("WEBGL_draw_buffers"), g = t.logarithmicDepthBuffer === !0, _ = u.getParameter(34930), x = u.getParameter(35660), M = u.getParameter(3379), b = u.getParameter(34076), E = u.getParameter(34921), w = u.getParameter(36347), R = u.getParameter(36348), A = u.getParameter(36349), P = x > 0, N = c || e.has("OES_texture_float"), I = P && N, B = c ? u.getParameter(36183) : 0;
  return {
    isWebGL2: c,
    drawBuffers: m,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: f,
    logarithmicDepthBuffer: g,
    maxTextures: _,
    maxVertexTextures: x,
    maxTextureSize: M,
    maxCubemapSize: b,
    maxAttributes: E,
    maxVertexUniforms: w,
    maxVaryings: R,
    maxFragmentUniforms: A,
    vertexTextures: P,
    floatFragmentTextures: N,
    floatVertexTextures: I,
    maxSamples: B
  };
}
function TN(u) {
  const e = this;
  let t = null, n = 0, r = !1, s = !1;
  const c = new zl(), f = new Zr(), h = { value: null, needsUpdate: !1 };
  this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function(_, x, M) {
    const b = _.length !== 0 || x || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || r;
    return r = x, t = g(_, M, 0), n = _.length, b;
  }, this.beginShadows = function() {
    s = !0, g(null);
  }, this.endShadows = function() {
    s = !1, m();
  }, this.setState = function(_, x, M) {
    const b = _.clippingPlanes, E = _.clipIntersection, w = _.clipShadows, R = u.get(_);
    if (!r || b === null || b.length === 0 || s && !w)
      s ? g(null) : m();
    else {
      const A = s ? 0 : n, P = A * 4;
      let N = R.clippingState || null;
      h.value = N, N = g(b, x, P, M);
      for (let I = 0; I !== P; ++I)
        N[I] = t[I];
      R.clippingState = N, this.numIntersection = E ? this.numPlanes : 0, this.numPlanes += A;
    }
  };
  function m() {
    h.value !== t && (h.value = t, h.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function g(_, x, M, b) {
    const E = _ !== null ? _.length : 0;
    let w = null;
    if (E !== 0) {
      if (w = h.value, b !== !0 || w === null) {
        const R = M + E * 4, A = x.matrixWorldInverse;
        f.getNormalMatrix(A), (w === null || w.length < R) && (w = new Float32Array(R));
        for (let P = 0, N = M; P !== E; ++P, N += 4)
          c.copy(_[P]).applyMatrix4(A, f), c.normal.toArray(w, N), w[N + 3] = c.constant;
      }
      h.value = w, h.needsUpdate = !0;
    }
    return e.numPlanes = E, e.numIntersection = 0, w;
  }
}
function CN(u) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(c, f) {
    return f === Qh ? c.mapping = Fl : f === Kh && (c.mapping = Bl), c;
  }
  function n(c) {
    if (c && c.isTexture && c.isRenderTargetTexture === !1) {
      const f = c.mapping;
      if (f === Qh || f === Kh)
        if (e.has(c)) {
          const h = e.get(c).texture;
          return t(h, c.mapping);
        } else {
          const h = c.image;
          if (h && h.height > 0) {
            const m = new xT(h.height / 2);
            return m.fromEquirectangularTexture(u, c), e.set(c, m), c.addEventListener("dispose", r), t(m.texture, c.mapping);
          } else
            return null;
        }
    }
    return c;
  }
  function r(c) {
    const f = c.target;
    f.removeEventListener("dispose", r);
    const h = e.get(f);
    h !== void 0 && (e.delete(f), h.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: s
  };
}
class xp extends yp {
  constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, c = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = s, this.far = c, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, r, s, c) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = c, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - e, c = n + e, f = r + t, h = r - t;
    if (this.view !== null && this.view.enabled) {
      const m = (this.right - this.left) / this.view.fullWidth / this.zoom, g = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += m * this.view.offsetX, c = s + m * this.view.width, f -= g * this.view.offsetY, h = f - g * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, c, f, h, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Jf = 4, Ib = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Yu = 20, T_ = /* @__PURE__ */ new xp(), Ub = /* @__PURE__ */ new xt();
let C_ = null;
const qu = (1 + Math.sqrt(5)) / 2, Hf = 1 / qu, Fb = [
  /* @__PURE__ */ new q(1, 1, 1),
  /* @__PURE__ */ new q(-1, 1, 1),
  /* @__PURE__ */ new q(1, 1, -1),
  /* @__PURE__ */ new q(-1, 1, -1),
  /* @__PURE__ */ new q(0, qu, Hf),
  /* @__PURE__ */ new q(0, qu, -Hf),
  /* @__PURE__ */ new q(Hf, 0, qu),
  /* @__PURE__ */ new q(-Hf, 0, qu),
  /* @__PURE__ */ new q(qu, Hf, 0),
  /* @__PURE__ */ new q(-qu, Hf, 0)
];
class Dx {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, r = 100) {
    C_ = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, n, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = kb(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Hb(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(C_), e.scissorTest = !1, Hv(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Fl || e.mapping === Bl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), C_ = this._renderer.getRenderTarget();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: vi,
      minFilter: vi,
      generateMipmaps: !1,
      type: td,
      format: pa,
      encoding: Hl,
      depthBuffer: !1
    }, r = Bb(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Bb(e, t, n);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = RN(s)), this._blurMaterial = AN(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Qi(this._lodPlanes[0], e);
    this._renderer.compile(t, T_);
  }
  _sceneToCubeUV(e, t, n, r) {
    const f = new Vi(90, 1, t, n), h = [1, -1, 1, 1, 1, 1], m = [1, 1, 1, -1, -1, -1], g = this._renderer, _ = g.autoClear, x = g.toneMapping;
    g.getClearColor(Ub), g.toneMapping = ds, g.autoClear = !1;
    const M = new Wl({
      name: "PMREM.Background",
      side: ma,
      depthWrite: !1,
      depthTest: !1
    }), b = new Qi(new ql(), M);
    let E = !1;
    const w = e.background;
    w ? w.isColor && (M.color.copy(w), e.background = null, E = !0) : (M.color.copy(Ub), E = !0);
    for (let R = 0; R < 6; R++) {
      const A = R % 3;
      A === 0 ? (f.up.set(0, h[R], 0), f.lookAt(m[R], 0, 0)) : A === 1 ? (f.up.set(0, 0, h[R]), f.lookAt(0, m[R], 0)) : (f.up.set(0, h[R], 0), f.lookAt(0, 0, m[R]));
      const P = this._cubeSize;
      Hv(r, A * P, R > 2 ? P : 0, P, P), g.setRenderTarget(r), E && g.render(b, f), g.render(e, f);
    }
    b.geometry.dispose(), b.material.dispose(), g.toneMapping = x, g.autoClear = _, e.background = w;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, r = e.mapping === Fl || e.mapping === Bl;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = kb()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Hb());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, c = new Qi(this._lodPlanes[0], s), f = s.uniforms;
    f.envMap.value = e;
    const h = this._cubeSize;
    Hv(t, 0, 0, 3 * h, 2 * h), n.setRenderTarget(t), n.render(c, T_);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), c = Fb[(r - 1) % Fb.length];
      this._blur(e, r - 1, r, s, c);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, r, s) {
    const c = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      c,
      t,
      n,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      c,
      e,
      n,
      n,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, n, r, s, c, f) {
    const h = this._renderer, m = this._blurMaterial;
    c !== "latitudinal" && c !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const g = 3, _ = new Qi(this._lodPlanes[r], m), x = m.uniforms, M = this._sizeLods[n] - 1, b = isFinite(s) ? Math.PI / (2 * M) : 2 * Math.PI / (2 * Yu - 1), E = s / b, w = isFinite(s) ? 1 + Math.floor(g * E) : Yu;
    w > Yu && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${Yu}`);
    const R = [];
    let A = 0;
    for (let W = 0; W < Yu; ++W) {
      const z = W / E, k = Math.exp(-z * z / 2);
      R.push(k), W === 0 ? A += k : W < w && (A += 2 * k);
    }
    for (let W = 0; W < R.length; W++)
      R[W] = R[W] / A;
    x.envMap.value = e.texture, x.samples.value = w, x.weights.value = R, x.latitudinal.value = c === "latitudinal", f && (x.poleAxis.value = f);
    const { _lodMax: P } = this;
    x.dTheta.value = b, x.mipInt.value = P - n;
    const N = this._sizeLods[r], I = 3 * N * (r > P - Jf ? r - P + Jf : 0), B = 4 * (this._cubeSize - N);
    Hv(t, I, B, 3 * N, 2 * N), h.setRenderTarget(t), h.render(_, T_);
  }
}
function RN(u) {
  const e = [], t = [], n = [];
  let r = u;
  const s = u - Jf + 1 + Ib.length;
  for (let c = 0; c < s; c++) {
    const f = Math.pow(2, r);
    t.push(f);
    let h = 1 / f;
    c > u - Jf ? h = Ib[c - u + Jf - 1] : c === 0 && (h = 0), n.push(h);
    const m = 1 / (f - 2), g = -m, _ = 1 + m, x = [g, g, _, g, _, _, g, g, _, _, g, _], M = 6, b = 6, E = 3, w = 2, R = 1, A = new Float32Array(E * b * M), P = new Float32Array(w * b * M), N = new Float32Array(R * b * M);
    for (let B = 0; B < M; B++) {
      const W = B % 3 * 2 / 3 - 1, z = B > 2 ? 0 : -1, k = [
        W,
        z,
        0,
        W + 2 / 3,
        z,
        0,
        W + 2 / 3,
        z + 1,
        0,
        W,
        z,
        0,
        W + 2 / 3,
        z + 1,
        0,
        W,
        z + 1,
        0
      ];
      A.set(k, E * b * B), P.set(x, w * b * B);
      const G = [B, B, B, B, B, B];
      N.set(G, R * b * B);
    }
    const I = new Kt();
    I.setAttribute("position", new Fn(A, E)), I.setAttribute("uv", new Fn(P, w)), I.setAttribute("faceIndex", new Fn(N, R)), e.push(I), r > Jf && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Bb(u, e, t) {
  const n = new Wa(u, e, t);
  return n.texture.mapping = ad, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Hv(u, e, t, n, r) {
  u.viewport.set(e, t, n, r), u.scissor.set(e, t, n, r);
}
function AN(u, e, t) {
  const n = new Float32Array(Yu), r = new q(0, 1, 0);
  return new Hs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Yu,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${u}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: nS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Co,
    depthTest: !1,
    depthWrite: !1
  });
}
function Hb() {
  return new Hs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: nS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Co,
    depthTest: !1,
    depthWrite: !1
  });
}
function kb() {
  return new Hs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: nS(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Co,
    depthTest: !1,
    depthWrite: !1
  });
}
function nS() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function LN(u) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(f) {
    if (f && f.isTexture) {
      const h = f.mapping, m = h === Qh || h === Kh, g = h === Fl || h === Bl;
      if (m || g)
        if (f.isRenderTargetTexture && f.needsPMREMUpdate === !0) {
          f.needsPMREMUpdate = !1;
          let _ = e.get(f);
          return t === null && (t = new Dx(u)), _ = m ? t.fromEquirectangular(f, _) : t.fromCubemap(f, _), e.set(f, _), _.texture;
        } else {
          if (e.has(f))
            return e.get(f).texture;
          {
            const _ = f.image;
            if (m && _ && _.height > 0 || g && _ && r(_)) {
              t === null && (t = new Dx(u));
              const x = m ? t.fromEquirectangular(f) : t.fromCubemap(f);
              return e.set(f, x), f.addEventListener("dispose", s), x.texture;
            } else
              return null;
          }
        }
    }
    return f;
  }
  function r(f) {
    let h = 0;
    const m = 6;
    for (let g = 0; g < m; g++)
      f[g] !== void 0 && h++;
    return h === m;
  }
  function s(f) {
    const h = f.target;
    h.removeEventListener("dispose", s);
    const m = e.get(h);
    m !== void 0 && (e.delete(h), m.dispose());
  }
  function c() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: c
  };
}
function DN(u) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r = u.getExtension("WEBGL_depth_texture") || u.getExtension("MOZ_WEBGL_depth_texture") || u.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = u.getExtension("WEBGL_compressed_texture_s3tc") || u.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || u.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = u.getExtension("WEBGL_compressed_texture_pvrtc") || u.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = u.getExtension(n);
    }
    return e[n] = r, r;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const r = t(n);
      return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r;
    }
  };
}
function PN(u, e, t, n) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function c(_) {
    const x = _.target;
    x.index !== null && e.remove(x.index);
    for (const b in x.attributes)
      e.remove(x.attributes[b]);
    x.removeEventListener("dispose", c), delete r[x.id];
    const M = s.get(x);
    M && (e.remove(M), s.delete(x)), n.releaseStatesOfGeometry(x), x.isInstancedBufferGeometry === !0 && delete x._maxInstanceCount, t.memory.geometries--;
  }
  function f(_, x) {
    return r[x.id] === !0 || (x.addEventListener("dispose", c), r[x.id] = !0, t.memory.geometries++), x;
  }
  function h(_) {
    const x = _.attributes;
    for (const b in x)
      e.update(x[b], 34962);
    const M = _.morphAttributes;
    for (const b in M) {
      const E = M[b];
      for (let w = 0, R = E.length; w < R; w++)
        e.update(E[w], 34962);
    }
  }
  function m(_) {
    const x = [], M = _.index, b = _.attributes.position;
    let E = 0;
    if (M !== null) {
      const A = M.array;
      E = M.version;
      for (let P = 0, N = A.length; P < N; P += 3) {
        const I = A[P + 0], B = A[P + 1], W = A[P + 2];
        x.push(I, B, B, W, W, I);
      }
    } else {
      const A = b.array;
      E = b.version;
      for (let P = 0, N = A.length / 3 - 1; P < N; P += 3) {
        const I = P + 0, B = P + 1, W = P + 2;
        x.push(I, B, B, W, W, I);
      }
    }
    const w = new (vT(x) ? tS : eS)(x, 1);
    w.version = E;
    const R = s.get(_);
    R && e.remove(R), s.set(_, w);
  }
  function g(_) {
    const x = s.get(_);
    if (x) {
      const M = _.index;
      M !== null && x.version < M.version && m(_);
    } else
      m(_);
    return s.get(_);
  }
  return {
    get: f,
    update: h,
    getWireframeAttribute: g
  };
}
function NN(u, e, t, n) {
  const r = n.isWebGL2;
  let s;
  function c(x) {
    s = x;
  }
  let f, h;
  function m(x) {
    f = x.type, h = x.bytesPerElement;
  }
  function g(x, M) {
    u.drawElements(s, M, f, x * h), t.update(M, s, 1);
  }
  function _(x, M, b) {
    if (b === 0)
      return;
    let E, w;
    if (r)
      E = u, w = "drawElementsInstanced";
    else if (E = e.get("ANGLE_instanced_arrays"), w = "drawElementsInstancedANGLE", E === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    E[w](s, M, f, x * h, b), t.update(M, s, b);
  }
  this.setMode = c, this.setIndex = m, this.render = g, this.renderInstances = _;
}
function zN(u) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(s, c, f) {
    switch (t.calls++, c) {
      case 4:
        t.triangles += f * (s / 3);
        break;
      case 1:
        t.lines += f * (s / 2);
        break;
      case 3:
        t.lines += f * (s - 1);
        break;
      case 2:
        t.lines += f * s;
        break;
      case 0:
        t.points += f * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", c);
        break;
    }
  }
  function r() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n
  };
}
function ON(u, e) {
  return u[0] - e[0];
}
function IN(u, e) {
  return Math.abs(e[1]) - Math.abs(u[1]);
}
function UN(u, e, t) {
  const n = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), c = new An(), f = [];
  for (let m = 0; m < 8; m++)
    f[m] = [m, 0];
  function h(m, g, _, x) {
    const M = m.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const b = g.morphAttributes.position || g.morphAttributes.normal || g.morphAttributes.color, E = b !== void 0 ? b.length : 0;
      let w = s.get(g);
      if (w === void 0 || w.count !== E) {
        let ye = function() {
          ne.dispose(), s.delete(g), g.removeEventListener("dispose", ye);
        };
        w !== void 0 && w.texture.dispose();
        const P = g.morphAttributes.position !== void 0, N = g.morphAttributes.normal !== void 0, I = g.morphAttributes.color !== void 0, B = g.morphAttributes.position || [], W = g.morphAttributes.normal || [], z = g.morphAttributes.color || [];
        let k = 0;
        P === !0 && (k = 1), N === !0 && (k = 2), I === !0 && (k = 3);
        let G = g.attributes.position.count * k, $ = 1;
        G > e.maxTextureSize && ($ = Math.ceil(G / e.maxTextureSize), G = e.maxTextureSize);
        const oe = new Float32Array(G * $ * 4 * E), ne = new vp(oe, G, $, E);
        ne.type = Eo, ne.needsUpdate = !0;
        const ee = k * 4;
        for (let Me = 0; Me < E; Me++) {
          const De = B[Me], V = W[Me], J = z[Me], Y = G * $ * 4 * Me;
          for (let de = 0; de < De.count; de++) {
            const le = de * ee;
            P === !0 && (c.fromBufferAttribute(De, de), oe[Y + le + 0] = c.x, oe[Y + le + 1] = c.y, oe[Y + le + 2] = c.z, oe[Y + le + 3] = 0), N === !0 && (c.fromBufferAttribute(V, de), oe[Y + le + 4] = c.x, oe[Y + le + 5] = c.y, oe[Y + le + 6] = c.z, oe[Y + le + 7] = 0), I === !0 && (c.fromBufferAttribute(J, de), oe[Y + le + 8] = c.x, oe[Y + le + 9] = c.y, oe[Y + le + 10] = c.z, oe[Y + le + 11] = J.itemSize === 4 ? c.w : 1);
          }
        }
        w = {
          count: E,
          texture: ne,
          size: new Ue(G, $)
        }, s.set(g, w), g.addEventListener("dispose", ye);
      }
      let R = 0;
      for (let P = 0; P < M.length; P++)
        R += M[P];
      const A = g.morphTargetsRelative ? 1 : 1 - R;
      x.getUniforms().setValue(u, "morphTargetBaseInfluence", A), x.getUniforms().setValue(u, "morphTargetInfluences", M), x.getUniforms().setValue(u, "morphTargetsTexture", w.texture, t), x.getUniforms().setValue(u, "morphTargetsTextureSize", w.size);
    } else {
      const b = M === void 0 ? 0 : M.length;
      let E = n[g.id];
      if (E === void 0 || E.length !== b) {
        E = [];
        for (let N = 0; N < b; N++)
          E[N] = [N, 0];
        n[g.id] = E;
      }
      for (let N = 0; N < b; N++) {
        const I = E[N];
        I[0] = N, I[1] = M[N];
      }
      E.sort(IN);
      for (let N = 0; N < 8; N++)
        N < b && E[N][1] ? (f[N][0] = E[N][0], f[N][1] = E[N][1]) : (f[N][0] = Number.MAX_SAFE_INTEGER, f[N][1] = 0);
      f.sort(ON);
      const w = g.morphAttributes.position, R = g.morphAttributes.normal;
      let A = 0;
      for (let N = 0; N < 8; N++) {
        const I = f[N], B = I[0], W = I[1];
        B !== Number.MAX_SAFE_INTEGER && W ? (w && g.getAttribute("morphTarget" + N) !== w[B] && g.setAttribute("morphTarget" + N, w[B]), R && g.getAttribute("morphNormal" + N) !== R[B] && g.setAttribute("morphNormal" + N, R[B]), r[N] = W, A += W) : (w && g.hasAttribute("morphTarget" + N) === !0 && g.deleteAttribute("morphTarget" + N), R && g.hasAttribute("morphNormal" + N) === !0 && g.deleteAttribute("morphNormal" + N), r[N] = 0);
      }
      const P = g.morphTargetsRelative ? 1 : 1 - A;
      x.getUniforms().setValue(u, "morphTargetBaseInfluence", P), x.getUniforms().setValue(u, "morphTargetInfluences", r);
    }
  }
  return {
    update: h
  };
}
function FN(u, e, t, n) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(h) {
    const m = n.render.frame, g = h.geometry, _ = e.get(h, g);
    return r.get(_) !== m && (e.update(_), r.set(_, m)), h.isInstancedMesh && (h.hasEventListener("dispose", f) === !1 && h.addEventListener("dispose", f), t.update(h.instanceMatrix, 34962), h.instanceColor !== null && t.update(h.instanceColor, 34962)), _;
  }
  function c() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function f(h) {
    const m = h.target;
    m.removeEventListener("dispose", f), t.remove(m.instanceMatrix), m.instanceColor !== null && t.remove(m.instanceColor);
  }
  return {
    update: s,
    dispose: c
  };
}
const MT = /* @__PURE__ */ new Mi(), bT = /* @__PURE__ */ new vp(), wT = /* @__PURE__ */ new Pg(), ET = /* @__PURE__ */ new _p(), Vb = [], Gb = [], Wb = new Float32Array(16), qb = new Float32Array(9), jb = new Float32Array(4);
function ld(u, e, t) {
  const n = u[0];
  if (n <= 0 || n > 0)
    return u;
  const r = e * t;
  let s = Vb[r];
  if (s === void 0 && (s = new Float32Array(r), Vb[r] = s), e !== 0) {
    n.toArray(s, 0);
    for (let c = 1, f = 0; c !== e; ++c)
      f += t, u[c].toArray(s, f);
  }
  return s;
}
function zi(u, e) {
  if (u.length !== e.length)
    return !1;
  for (let t = 0, n = u.length; t < n; t++)
    if (u[t] !== e[t])
      return !1;
  return !0;
}
function Oi(u, e) {
  for (let t = 0, n = e.length; t < n; t++)
    u[t] = e[t];
}
function zg(u, e) {
  let t = Gb[e];
  t === void 0 && (t = new Int32Array(e), Gb[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = u.allocateTextureUnit();
  return t;
}
function BN(u, e) {
  const t = this.cache;
  t[0] !== e && (u.uniform1f(this.addr, e), t[0] = e);
}
function HN(u, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (u.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (zi(t, e))
      return;
    u.uniform2fv(this.addr, e), Oi(t, e);
  }
}
function kN(u, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (u.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (u.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (zi(t, e))
      return;
    u.uniform3fv(this.addr, e), Oi(t, e);
  }
}
function VN(u, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (u.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (zi(t, e))
      return;
    u.uniform4fv(this.addr, e), Oi(t, e);
  }
}
function GN(u, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (zi(t, e))
      return;
    u.uniformMatrix2fv(this.addr, !1, e), Oi(t, e);
  } else {
    if (zi(t, n))
      return;
    jb.set(n), u.uniformMatrix2fv(this.addr, !1, jb), Oi(t, n);
  }
}
function WN(u, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (zi(t, e))
      return;
    u.uniformMatrix3fv(this.addr, !1, e), Oi(t, e);
  } else {
    if (zi(t, n))
      return;
    qb.set(n), u.uniformMatrix3fv(this.addr, !1, qb), Oi(t, n);
  }
}
function qN(u, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (zi(t, e))
      return;
    u.uniformMatrix4fv(this.addr, !1, e), Oi(t, e);
  } else {
    if (zi(t, n))
      return;
    Wb.set(n), u.uniformMatrix4fv(this.addr, !1, Wb), Oi(t, n);
  }
}
function jN(u, e) {
  const t = this.cache;
  t[0] !== e && (u.uniform1i(this.addr, e), t[0] = e);
}
function YN(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform2iv(this.addr, e), Oi(t, e));
}
function XN(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform3iv(this.addr, e), Oi(t, e));
}
function ZN(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform4iv(this.addr, e), Oi(t, e));
}
function JN(u, e) {
  const t = this.cache;
  t[0] !== e && (u.uniform1ui(this.addr, e), t[0] = e);
}
function QN(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform2uiv(this.addr, e), Oi(t, e));
}
function KN(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform3uiv(this.addr, e), Oi(t, e));
}
function $N(u, e) {
  const t = this.cache;
  zi(t, e) || (u.uniform4uiv(this.addr, e), Oi(t, e));
}
function ez(u, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (u.uniform1i(this.addr, r), n[0] = r), t.setTexture2D(e || MT, r);
}
function tz(u, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (u.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || wT, r);
}
function nz(u, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (u.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || ET, r);
}
function iz(u, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (u.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || bT, r);
}
function rz(u) {
  switch (u) {
    case 5126:
      return BN;
    case 35664:
      return HN;
    case 35665:
      return kN;
    case 35666:
      return VN;
    case 35674:
      return GN;
    case 35675:
      return WN;
    case 35676:
      return qN;
    case 5124:
    case 35670:
      return jN;
    case 35667:
    case 35671:
      return YN;
    case 35668:
    case 35672:
      return XN;
    case 35669:
    case 35673:
      return ZN;
    case 5125:
      return JN;
    case 36294:
      return QN;
    case 36295:
      return KN;
    case 36296:
      return $N;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return ez;
    case 35679:
    case 36299:
    case 36307:
      return tz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return nz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return iz;
  }
}
function az(u, e) {
  u.uniform1fv(this.addr, e);
}
function sz(u, e) {
  const t = ld(e, this.size, 2);
  u.uniform2fv(this.addr, t);
}
function oz(u, e) {
  const t = ld(e, this.size, 3);
  u.uniform3fv(this.addr, t);
}
function lz(u, e) {
  const t = ld(e, this.size, 4);
  u.uniform4fv(this.addr, t);
}
function uz(u, e) {
  const t = ld(e, this.size, 4);
  u.uniformMatrix2fv(this.addr, !1, t);
}
function cz(u, e) {
  const t = ld(e, this.size, 9);
  u.uniformMatrix3fv(this.addr, !1, t);
}
function fz(u, e) {
  const t = ld(e, this.size, 16);
  u.uniformMatrix4fv(this.addr, !1, t);
}
function dz(u, e) {
  u.uniform1iv(this.addr, e);
}
function hz(u, e) {
  u.uniform2iv(this.addr, e);
}
function pz(u, e) {
  u.uniform3iv(this.addr, e);
}
function mz(u, e) {
  u.uniform4iv(this.addr, e);
}
function vz(u, e) {
  u.uniform1uiv(this.addr, e);
}
function gz(u, e) {
  u.uniform2uiv(this.addr, e);
}
function yz(u, e) {
  u.uniform3uiv(this.addr, e);
}
function _z(u, e) {
  u.uniform4uiv(this.addr, e);
}
function xz(u, e, t) {
  const n = this.cache, r = e.length, s = zg(t, r);
  zi(n, s) || (u.uniform1iv(this.addr, s), Oi(n, s));
  for (let c = 0; c !== r; ++c)
    t.setTexture2D(e[c] || MT, s[c]);
}
function Sz(u, e, t) {
  const n = this.cache, r = e.length, s = zg(t, r);
  zi(n, s) || (u.uniform1iv(this.addr, s), Oi(n, s));
  for (let c = 0; c !== r; ++c)
    t.setTexture3D(e[c] || wT, s[c]);
}
function Mz(u, e, t) {
  const n = this.cache, r = e.length, s = zg(t, r);
  zi(n, s) || (u.uniform1iv(this.addr, s), Oi(n, s));
  for (let c = 0; c !== r; ++c)
    t.setTextureCube(e[c] || ET, s[c]);
}
function bz(u, e, t) {
  const n = this.cache, r = e.length, s = zg(t, r);
  zi(n, s) || (u.uniform1iv(this.addr, s), Oi(n, s));
  for (let c = 0; c !== r; ++c)
    t.setTexture2DArray(e[c] || bT, s[c]);
}
function wz(u) {
  switch (u) {
    case 5126:
      return az;
    case 35664:
      return sz;
    case 35665:
      return oz;
    case 35666:
      return lz;
    case 35674:
      return uz;
    case 35675:
      return cz;
    case 35676:
      return fz;
    case 5124:
    case 35670:
      return dz;
    case 35667:
    case 35671:
      return hz;
    case 35668:
    case 35672:
      return pz;
    case 35669:
    case 35673:
      return mz;
    case 5125:
      return vz;
    case 36294:
      return gz;
    case 36295:
      return yz;
    case 36296:
      return _z;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return xz;
    case 35679:
    case 36299:
    case 36307:
      return Sz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Mz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return bz;
  }
}
class Ez {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.setValue = rz(t.type);
  }
}
class Tz {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = wz(t.type);
  }
}
class Cz {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let s = 0, c = r.length; s !== c; ++s) {
      const f = r[s];
      f.setValue(e, t[f.id], n);
    }
  }
}
const R_ = /(\w+)(\])?(\[|\.)?/g;
function Yb(u, e) {
  u.seq.push(e), u.map[e.id] = e;
}
function Rz(u, e, t) {
  const n = u.name, r = n.length;
  for (R_.lastIndex = 0; ; ) {
    const s = R_.exec(n), c = R_.lastIndex;
    let f = s[1];
    const h = s[2] === "]", m = s[3];
    if (h && (f = f | 0), m === void 0 || m === "[" && c + 2 === r) {
      Yb(t, m === void 0 ? new Ez(f, u, e) : new Tz(f, u, e));
      break;
    } else {
      let _ = t.map[f];
      _ === void 0 && (_ = new Cz(f), Yb(t, _)), t = _;
    }
  }
}
class yg {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, 35718);
    for (let r = 0; r < n; ++r) {
      const s = e.getActiveUniform(t, r), c = e.getUniformLocation(t, s.name);
      Rz(s, c, this);
    }
  }
  setValue(e, t, n, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let s = 0, c = t.length; s !== c; ++s) {
      const f = t[s], h = n[f.id];
      h.needsUpdate !== !1 && f.setValue(e, h.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const c = e[r];
      c.id in t && n.push(c);
    }
    return n;
  }
}
function Xb(u, e, t) {
  const n = u.createShader(e);
  return u.shaderSource(n, t), u.compileShader(n), n;
}
let Az = 0;
function Lz(u, e) {
  const t = u.split(`
`), n = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let c = r; c < s; c++) {
    const f = c + 1;
    n.push(`${f === e ? ">" : " "} ${f}: ${t[c]}`);
  }
  return n.join(`
`);
}
function Dz(u) {
  switch (u) {
    case Hl:
      return ["Linear", "( value )"];
    case ti:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", u), ["Linear", "( value )"];
  }
}
function Zb(u, e, t) {
  const n = u.getShaderParameter(e, 35713), r = u.getShaderInfoLog(e).trim();
  if (n && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const c = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + Lz(u.getShaderSource(e), c);
  } else
    return r;
}
function Pz(u, e) {
  const t = Dz(e);
  return "vec4 " + u + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function Nz(u, e) {
  let t;
  switch (e) {
    case GE:
      t = "Linear";
      break;
    case WE:
      t = "Reinhard";
      break;
    case qE:
      t = "OptimizedCineon";
      break;
    case Xx:
      t = "ACESFilmic";
      break;
    case jE:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + u + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function zz(u) {
  return [
    u.extensionDerivatives || u.envMapCubeUVHeight || u.bumpMap || u.tangentSpaceNormalMap || u.clearcoatNormalMap || u.flatShading || u.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (u.extensionFragDepth || u.logarithmicDepthBuffer) && u.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    u.extensionDrawBuffers && u.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (u.extensionShaderTextureLOD || u.envMap || u.transmission) && u.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(jh).join(`
`);
}
function Oz(u) {
  const e = [];
  for (const t in u) {
    const n = u[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function Iz(u, e) {
  const t = {}, n = u.getProgramParameter(e, 35721);
  for (let r = 0; r < n; r++) {
    const s = u.getActiveAttrib(e, r), c = s.name;
    let f = 1;
    s.type === 35674 && (f = 2), s.type === 35675 && (f = 3), s.type === 35676 && (f = 4), t[c] = {
      type: s.type,
      location: u.getAttribLocation(e, c),
      locationSize: f
    };
  }
  return t;
}
function jh(u) {
  return u !== "";
}
function Jb(u, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return u.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Qb(u, e) {
  return u.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Uz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Px(u) {
  return u.replace(Uz, Fz);
}
function Fz(u, e) {
  const t = nn[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return Px(t);
}
const Bz = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Kb(u) {
  return u.replace(Bz, Hz);
}
function Hz(u, e, t, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function $b(u) {
  let e = "precision " + u.precision + ` float;
precision ` + u.precision + " int;";
  return u.precision === "highp" ? e += `
#define HIGH_PRECISION` : u.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : u.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function kz(u) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return u.shadowMapType === Ag ? e = "SHADOWMAP_TYPE_PCF" : u.shadowMapType === Yh ? e = "SHADOWMAP_TYPE_PCF_SOFT" : u.shadowMapType === Xu && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Vz(u) {
  let e = "ENVMAP_TYPE_CUBE";
  if (u.envMap)
    switch (u.envMapMode) {
      case Fl:
      case Bl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ad:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Gz(u) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (u.envMap)
    switch (u.envMapMode) {
      case Bl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Wz(u) {
  let e = "ENVMAP_BLENDING_NONE";
  if (u.envMap)
    switch (u.combine) {
      case mp:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case kE:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case VE:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function qz(u) {
  const e = u.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function jz(u, e, t, n) {
  const r = u.getContext(), s = t.defines;
  let c = t.vertexShader, f = t.fragmentShader;
  const h = kz(t), m = Vz(t), g = Gz(t), _ = Wz(t), x = qz(t), M = t.isWebGL2 ? "" : zz(t), b = Oz(s), E = r.createProgram();
  let w, R, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (w = [
    b
  ].filter(jh).join(`
`), w.length > 0 && (w += `
`), R = [
    M,
    b
  ].filter(jh).join(`
`), R.length > 0 && (R += `
`)) : (w = [
    $b(t),
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + g : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(jh).join(`
`), R = [
    M,
    $b(t),
    "#define SHADER_NAME " + t.shaderName,
    b,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + m : "",
    t.envMap ? "#define " + g : "",
    t.envMap ? "#define " + _ : "",
    x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "",
    x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "",
    x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== ds ? "#define TONE_MAPPING" : "",
    t.toneMapping !== ds ? nn.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== ds ? Nz("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    nn.encodings_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Pz("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(jh).join(`
`)), c = Px(c), c = Jb(c, t), c = Qb(c, t), f = Px(f), f = Jb(f, t), f = Qb(f, t), c = Kb(c), f = Kb(f), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`, w = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + w, R = [
    "#define varying in",
    t.glslVersion === Ax ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Ax ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + R);
  const P = A + w + c, N = A + R + f, I = Xb(r, 35633, P), B = Xb(r, 35632, N);
  if (r.attachShader(E, I), r.attachShader(E, B), t.index0AttributeName !== void 0 ? r.bindAttribLocation(E, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(E, 0, "position"), r.linkProgram(E), u.debug.checkShaderErrors) {
    const k = r.getProgramInfoLog(E).trim(), G = r.getShaderInfoLog(I).trim(), $ = r.getShaderInfoLog(B).trim();
    let oe = !0, ne = !0;
    if (r.getProgramParameter(E, 35714) === !1) {
      oe = !1;
      const ee = Zb(r, I, "vertex"), ye = Zb(r, B, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(E, 35715) + `

Program Info Log: ` + k + `
` + ee + `
` + ye
      );
    } else
      k !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", k) : (G === "" || $ === "") && (ne = !1);
    ne && (this.diagnostics = {
      runnable: oe,
      programLog: k,
      vertexShader: {
        log: G,
        prefix: w
      },
      fragmentShader: {
        log: $,
        prefix: R
      }
    });
  }
  r.deleteShader(I), r.deleteShader(B);
  let W;
  this.getUniforms = function() {
    return W === void 0 && (W = new yg(r, E)), W;
  };
  let z;
  return this.getAttributes = function() {
    return z === void 0 && (z = Iz(r, E)), z;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), r.deleteProgram(E), this.program = void 0;
  }, this.name = t.shaderName, this.id = Az++, this.cacheKey = e, this.usedTimes = 1, this.program = E, this.vertexShader = I, this.fragmentShader = B, this;
}
let Yz = 0;
class Xz {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(n), c = this._getShaderCacheForMaterial(e);
    return c.has(r) === !1 && (c.add(r), r.usedTimes++), c.has(s) === !1 && (c.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new Zz(e), t.set(e, n)), n;
  }
}
class Zz {
  constructor(e) {
    this.id = Yz++, this.code = e, this.usedTimes = 0;
  }
}
function Jz(u, e, t, n, r, s, c) {
  const f = new rc(), h = new Xz(), m = [], g = r.isWebGL2, _ = r.logarithmicDepthBuffer, x = r.vertexTextures;
  let M = r.precision;
  const b = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function E(z, k, G, $, oe) {
    const ne = $.fog, ee = oe.geometry, ye = z.isMeshStandardMaterial ? $.environment : null, Me = (z.isMeshStandardMaterial ? t : e).get(z.envMap || ye), De = Me && Me.mapping === ad ? Me.image.height : null, V = b[z.type];
    z.precision !== null && (M = r.getMaxPrecision(z.precision), M !== z.precision && console.warn("THREE.WebGLProgram.getParameters:", z.precision, "not supported, using", M, "instead."));
    const J = ee.morphAttributes.position || ee.morphAttributes.normal || ee.morphAttributes.color, Y = J !== void 0 ? J.length : 0;
    let de = 0;
    ee.morphAttributes.position !== void 0 && (de = 1), ee.morphAttributes.normal !== void 0 && (de = 2), ee.morphAttributes.color !== void 0 && (de = 3);
    let le, Pe, We, $e;
    if (V) {
      const At = fs[V];
      le = At.vertexShader, Pe = At.fragmentShader;
    } else
      le = z.vertexShader, Pe = z.fragmentShader, h.update(z), We = h.getVertexShaderID(z), $e = h.getFragmentShaderID(z);
    const ve = u.getRenderTarget(), gt = z.alphaTest > 0, ot = z.clearcoat > 0, _t = z.iridescence > 0;
    return {
      isWebGL2: g,
      shaderID: V,
      shaderName: z.type,
      vertexShader: le,
      fragmentShader: Pe,
      defines: z.defines,
      customVertexShaderID: We,
      customFragmentShaderID: $e,
      isRawShaderMaterial: z.isRawShaderMaterial === !0,
      glslVersion: z.glslVersion,
      precision: M,
      instancing: oe.isInstancedMesh === !0,
      instancingColor: oe.isInstancedMesh === !0 && oe.instanceColor !== null,
      supportsVertexTextures: x,
      outputEncoding: ve === null ? u.outputEncoding : ve.isXRRenderTarget === !0 ? ve.texture.encoding : Hl,
      map: !!z.map,
      matcap: !!z.matcap,
      envMap: !!Me,
      envMapMode: Me && Me.mapping,
      envMapCubeUVHeight: De,
      lightMap: !!z.lightMap,
      aoMap: !!z.aoMap,
      emissiveMap: !!z.emissiveMap,
      bumpMap: !!z.bumpMap,
      normalMap: !!z.normalMap,
      objectSpaceNormalMap: z.normalMapType === hT,
      tangentSpaceNormalMap: z.normalMapType === Gl,
      decodeVideoTexture: !!z.map && z.map.isVideoTexture === !0 && z.map.encoding === ti,
      clearcoat: ot,
      clearcoatMap: ot && !!z.clearcoatMap,
      clearcoatRoughnessMap: ot && !!z.clearcoatRoughnessMap,
      clearcoatNormalMap: ot && !!z.clearcoatNormalMap,
      iridescence: _t,
      iridescenceMap: _t && !!z.iridescenceMap,
      iridescenceThicknessMap: _t && !!z.iridescenceThicknessMap,
      displacementMap: !!z.displacementMap,
      roughnessMap: !!z.roughnessMap,
      metalnessMap: !!z.metalnessMap,
      specularMap: !!z.specularMap,
      specularIntensityMap: !!z.specularIntensityMap,
      specularColorMap: !!z.specularColorMap,
      opaque: z.transparent === !1 && z.blending === ec,
      alphaMap: !!z.alphaMap,
      alphaTest: gt,
      gradientMap: !!z.gradientMap,
      sheen: z.sheen > 0,
      sheenColorMap: !!z.sheenColorMap,
      sheenRoughnessMap: !!z.sheenRoughnessMap,
      transmission: z.transmission > 0,
      transmissionMap: !!z.transmissionMap,
      thicknessMap: !!z.thicknessMap,
      combine: z.combine,
      vertexTangents: !!z.normalMap && !!ee.attributes.tangent,
      vertexColors: z.vertexColors,
      vertexAlphas: z.vertexColors === !0 && !!ee.attributes.color && ee.attributes.color.itemSize === 4,
      vertexUvs: !!z.map || !!z.bumpMap || !!z.normalMap || !!z.specularMap || !!z.alphaMap || !!z.emissiveMap || !!z.roughnessMap || !!z.metalnessMap || !!z.clearcoatMap || !!z.clearcoatRoughnessMap || !!z.clearcoatNormalMap || !!z.iridescenceMap || !!z.iridescenceThicknessMap || !!z.displacementMap || !!z.transmissionMap || !!z.thicknessMap || !!z.specularIntensityMap || !!z.specularColorMap || !!z.sheenColorMap || !!z.sheenRoughnessMap,
      uvsVertexOnly: !(z.map || z.bumpMap || z.normalMap || z.specularMap || z.alphaMap || z.emissiveMap || z.roughnessMap || z.metalnessMap || z.clearcoatNormalMap || z.iridescenceMap || z.iridescenceThicknessMap || z.transmission > 0 || z.transmissionMap || z.thicknessMap || z.specularIntensityMap || z.specularColorMap || z.sheen > 0 || z.sheenColorMap || z.sheenRoughnessMap) && !!z.displacementMap,
      fog: !!ne,
      useFog: z.fog === !0,
      fogExp2: ne && ne.isFogExp2,
      flatShading: !!z.flatShading,
      sizeAttenuation: z.sizeAttenuation,
      logarithmicDepthBuffer: _,
      skinning: oe.isSkinnedMesh === !0,
      morphTargets: ee.morphAttributes.position !== void 0,
      morphNormals: ee.morphAttributes.normal !== void 0,
      morphColors: ee.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: de,
      numDirLights: k.directional.length,
      numPointLights: k.point.length,
      numSpotLights: k.spot.length,
      numSpotLightMaps: k.spotLightMap.length,
      numRectAreaLights: k.rectArea.length,
      numHemiLights: k.hemi.length,
      numDirLightShadows: k.directionalShadowMap.length,
      numPointLightShadows: k.pointShadowMap.length,
      numSpotLightShadows: k.spotShadowMap.length,
      numSpotLightShadowsWithMaps: k.numSpotLightShadowsWithMaps,
      numClippingPlanes: c.numPlanes,
      numClipIntersection: c.numIntersection,
      dithering: z.dithering,
      shadowMapEnabled: u.shadowMap.enabled && G.length > 0,
      shadowMapType: u.shadowMap.type,
      toneMapping: z.toneMapped ? u.toneMapping : ds,
      physicallyCorrectLights: u.physicallyCorrectLights,
      premultipliedAlpha: z.premultipliedAlpha,
      doubleSided: z.side === Fs,
      flipSided: z.side === ma,
      useDepthPacking: !!z.depthPacking,
      depthPacking: z.depthPacking || 0,
      index0AttributeName: z.index0AttributeName,
      extensionDerivatives: z.extensions && z.extensions.derivatives,
      extensionFragDepth: z.extensions && z.extensions.fragDepth,
      extensionDrawBuffers: z.extensions && z.extensions.drawBuffers,
      extensionShaderTextureLOD: z.extensions && z.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: g || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: g || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: g || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: z.customProgramCacheKey()
    };
  }
  function w(z) {
    const k = [];
    if (z.shaderID ? k.push(z.shaderID) : (k.push(z.customVertexShaderID), k.push(z.customFragmentShaderID)), z.defines !== void 0)
      for (const G in z.defines)
        k.push(G), k.push(z.defines[G]);
    return z.isRawShaderMaterial === !1 && (R(k, z), A(k, z), k.push(u.outputEncoding)), k.push(z.customProgramCacheKey), k.join();
  }
  function R(z, k) {
    z.push(k.precision), z.push(k.outputEncoding), z.push(k.envMapMode), z.push(k.envMapCubeUVHeight), z.push(k.combine), z.push(k.vertexUvs), z.push(k.fogExp2), z.push(k.sizeAttenuation), z.push(k.morphTargetsCount), z.push(k.morphAttributeCount), z.push(k.numDirLights), z.push(k.numPointLights), z.push(k.numSpotLights), z.push(k.numSpotLightMaps), z.push(k.numHemiLights), z.push(k.numRectAreaLights), z.push(k.numDirLightShadows), z.push(k.numPointLightShadows), z.push(k.numSpotLightShadows), z.push(k.numSpotLightShadowsWithMaps), z.push(k.shadowMapType), z.push(k.toneMapping), z.push(k.numClippingPlanes), z.push(k.numClipIntersection), z.push(k.depthPacking);
  }
  function A(z, k) {
    f.disableAll(), k.isWebGL2 && f.enable(0), k.supportsVertexTextures && f.enable(1), k.instancing && f.enable(2), k.instancingColor && f.enable(3), k.map && f.enable(4), k.matcap && f.enable(5), k.envMap && f.enable(6), k.lightMap && f.enable(7), k.aoMap && f.enable(8), k.emissiveMap && f.enable(9), k.bumpMap && f.enable(10), k.normalMap && f.enable(11), k.objectSpaceNormalMap && f.enable(12), k.tangentSpaceNormalMap && f.enable(13), k.clearcoat && f.enable(14), k.clearcoatMap && f.enable(15), k.clearcoatRoughnessMap && f.enable(16), k.clearcoatNormalMap && f.enable(17), k.iridescence && f.enable(18), k.iridescenceMap && f.enable(19), k.iridescenceThicknessMap && f.enable(20), k.displacementMap && f.enable(21), k.specularMap && f.enable(22), k.roughnessMap && f.enable(23), k.metalnessMap && f.enable(24), k.gradientMap && f.enable(25), k.alphaMap && f.enable(26), k.alphaTest && f.enable(27), k.vertexColors && f.enable(28), k.vertexAlphas && f.enable(29), k.vertexUvs && f.enable(30), k.vertexTangents && f.enable(31), k.uvsVertexOnly && f.enable(32), z.push(f.mask), f.disableAll(), k.fog && f.enable(0), k.useFog && f.enable(1), k.flatShading && f.enable(2), k.logarithmicDepthBuffer && f.enable(3), k.skinning && f.enable(4), k.morphTargets && f.enable(5), k.morphNormals && f.enable(6), k.morphColors && f.enable(7), k.premultipliedAlpha && f.enable(8), k.shadowMapEnabled && f.enable(9), k.physicallyCorrectLights && f.enable(10), k.doubleSided && f.enable(11), k.flipSided && f.enable(12), k.useDepthPacking && f.enable(13), k.dithering && f.enable(14), k.specularIntensityMap && f.enable(15), k.specularColorMap && f.enable(16), k.transmission && f.enable(17), k.transmissionMap && f.enable(18), k.thicknessMap && f.enable(19), k.sheen && f.enable(20), k.sheenColorMap && f.enable(21), k.sheenRoughnessMap && f.enable(22), k.decodeVideoTexture && f.enable(23), k.opaque && f.enable(24), z.push(f.mask);
  }
  function P(z) {
    const k = b[z.type];
    let G;
    if (k) {
      const $ = fs[k];
      G = yT.clone($.uniforms);
    } else
      G = z.uniforms;
    return G;
  }
  function N(z, k) {
    let G;
    for (let $ = 0, oe = m.length; $ < oe; $++) {
      const ne = m[$];
      if (ne.cacheKey === k) {
        G = ne, ++G.usedTimes;
        break;
      }
    }
    return G === void 0 && (G = new jz(u, k, z, s), m.push(G)), G;
  }
  function I(z) {
    if (--z.usedTimes === 0) {
      const k = m.indexOf(z);
      m[k] = m[m.length - 1], m.pop(), z.destroy();
    }
  }
  function B(z) {
    h.remove(z);
  }
  function W() {
    h.dispose();
  }
  return {
    getParameters: E,
    getProgramCacheKey: w,
    getUniforms: P,
    acquireProgram: N,
    releaseProgram: I,
    releaseShaderCache: B,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: m,
    dispose: W
  };
}
function Qz() {
  let u = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let c = u.get(s);
    return c === void 0 && (c = {}, u.set(s, c)), c;
  }
  function t(s) {
    u.delete(s);
  }
  function n(s, c, f) {
    u.get(s)[c] = f;
  }
  function r() {
    u = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: r
  };
}
function Kz(u, e) {
  return u.groupOrder !== e.groupOrder ? u.groupOrder - e.groupOrder : u.renderOrder !== e.renderOrder ? u.renderOrder - e.renderOrder : u.material.id !== e.material.id ? u.material.id - e.material.id : u.z !== e.z ? u.z - e.z : u.id - e.id;
}
function ew(u, e) {
  return u.groupOrder !== e.groupOrder ? u.groupOrder - e.groupOrder : u.renderOrder !== e.renderOrder ? u.renderOrder - e.renderOrder : u.z !== e.z ? e.z - u.z : u.id - e.id;
}
function tw() {
  const u = [];
  let e = 0;
  const t = [], n = [], r = [];
  function s() {
    e = 0, t.length = 0, n.length = 0, r.length = 0;
  }
  function c(_, x, M, b, E, w) {
    let R = u[e];
    return R === void 0 ? (R = {
      id: _.id,
      object: _,
      geometry: x,
      material: M,
      groupOrder: b,
      renderOrder: _.renderOrder,
      z: E,
      group: w
    }, u[e] = R) : (R.id = _.id, R.object = _, R.geometry = x, R.material = M, R.groupOrder = b, R.renderOrder = _.renderOrder, R.z = E, R.group = w), e++, R;
  }
  function f(_, x, M, b, E, w) {
    const R = c(_, x, M, b, E, w);
    M.transmission > 0 ? n.push(R) : M.transparent === !0 ? r.push(R) : t.push(R);
  }
  function h(_, x, M, b, E, w) {
    const R = c(_, x, M, b, E, w);
    M.transmission > 0 ? n.unshift(R) : M.transparent === !0 ? r.unshift(R) : t.unshift(R);
  }
  function m(_, x) {
    t.length > 1 && t.sort(_ || Kz), n.length > 1 && n.sort(x || ew), r.length > 1 && r.sort(x || ew);
  }
  function g() {
    for (let _ = e, x = u.length; _ < x; _++) {
      const M = u[_];
      if (M.id === null)
        break;
      M.id = null, M.object = null, M.geometry = null, M.material = null, M.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: r,
    init: s,
    push: f,
    unshift: h,
    finish: g,
    sort: m
  };
}
function $z() {
  let u = /* @__PURE__ */ new WeakMap();
  function e(n, r) {
    const s = u.get(n);
    let c;
    return s === void 0 ? (c = new tw(), u.set(n, [c])) : r >= s.length ? (c = new tw(), s.push(c)) : c = s[r], c;
  }
  function t() {
    u = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function eO() {
  const u = {};
  return {
    get: function(e) {
      if (u[e.id] !== void 0)
        return u[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new q(),
            color: new xt()
          };
          break;
        case "SpotLight":
          t = {
            position: new q(),
            direction: new q(),
            color: new xt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new q(),
            color: new xt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new q(),
            skyColor: new xt(),
            groundColor: new xt()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new xt(),
            position: new q(),
            halfWidth: new q(),
            halfHeight: new q()
          };
          break;
      }
      return u[e.id] = t, t;
    }
  };
}
function tO() {
  const u = {};
  return {
    get: function(e) {
      if (u[e.id] !== void 0)
        return u[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ue(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return u[e.id] = t, t;
    }
  };
}
let nO = 0;
function iO(u, e) {
  return (e.castShadow ? 2 : 0) - (u.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (u.map ? 1 : 0);
}
function rO(u, e) {
  const t = new eO(), n = tO(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let g = 0; g < 9; g++)
    r.probe.push(new q());
  const s = new q(), c = new Qt(), f = new Qt();
  function h(g, _) {
    let x = 0, M = 0, b = 0;
    for (let $ = 0; $ < 9; $++)
      r.probe[$].set(0, 0, 0);
    let E = 0, w = 0, R = 0, A = 0, P = 0, N = 0, I = 0, B = 0, W = 0, z = 0;
    g.sort(iO);
    const k = _ !== !0 ? Math.PI : 1;
    for (let $ = 0, oe = g.length; $ < oe; $++) {
      const ne = g[$], ee = ne.color, ye = ne.intensity, Me = ne.distance, De = ne.shadow && ne.shadow.map ? ne.shadow.map.texture : null;
      if (ne.isAmbientLight)
        x += ee.r * ye * k, M += ee.g * ye * k, b += ee.b * ye * k;
      else if (ne.isLightProbe)
        for (let V = 0; V < 9; V++)
          r.probe[V].addScaledVector(ne.sh.coefficients[V], ye);
      else if (ne.isDirectionalLight) {
        const V = t.get(ne);
        if (V.color.copy(ne.color).multiplyScalar(ne.intensity * k), ne.castShadow) {
          const J = ne.shadow, Y = n.get(ne);
          Y.shadowBias = J.bias, Y.shadowNormalBias = J.normalBias, Y.shadowRadius = J.radius, Y.shadowMapSize = J.mapSize, r.directionalShadow[E] = Y, r.directionalShadowMap[E] = De, r.directionalShadowMatrix[E] = ne.shadow.matrix, N++;
        }
        r.directional[E] = V, E++;
      } else if (ne.isSpotLight) {
        const V = t.get(ne);
        V.position.setFromMatrixPosition(ne.matrixWorld), V.color.copy(ee).multiplyScalar(ye * k), V.distance = Me, V.coneCos = Math.cos(ne.angle), V.penumbraCos = Math.cos(ne.angle * (1 - ne.penumbra)), V.decay = ne.decay, r.spot[R] = V;
        const J = ne.shadow;
        if (ne.map && (r.spotLightMap[W] = ne.map, W++, J.updateMatrices(ne), ne.castShadow && z++), r.spotLightMatrix[R] = J.matrix, ne.castShadow) {
          const Y = n.get(ne);
          Y.shadowBias = J.bias, Y.shadowNormalBias = J.normalBias, Y.shadowRadius = J.radius, Y.shadowMapSize = J.mapSize, r.spotShadow[R] = Y, r.spotShadowMap[R] = De, B++;
        }
        R++;
      } else if (ne.isRectAreaLight) {
        const V = t.get(ne);
        V.color.copy(ee).multiplyScalar(ye), V.halfWidth.set(ne.width * 0.5, 0, 0), V.halfHeight.set(0, ne.height * 0.5, 0), r.rectArea[A] = V, A++;
      } else if (ne.isPointLight) {
        const V = t.get(ne);
        if (V.color.copy(ne.color).multiplyScalar(ne.intensity * k), V.distance = ne.distance, V.decay = ne.decay, ne.castShadow) {
          const J = ne.shadow, Y = n.get(ne);
          Y.shadowBias = J.bias, Y.shadowNormalBias = J.normalBias, Y.shadowRadius = J.radius, Y.shadowMapSize = J.mapSize, Y.shadowCameraNear = J.camera.near, Y.shadowCameraFar = J.camera.far, r.pointShadow[w] = Y, r.pointShadowMap[w] = De, r.pointShadowMatrix[w] = ne.shadow.matrix, I++;
        }
        r.point[w] = V, w++;
      } else if (ne.isHemisphereLight) {
        const V = t.get(ne);
        V.skyColor.copy(ne.color).multiplyScalar(ye * k), V.groundColor.copy(ne.groundColor).multiplyScalar(ye * k), r.hemi[P] = V, P++;
      }
    }
    A > 0 && (e.isWebGL2 || u.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = lt.LTC_FLOAT_1, r.rectAreaLTC2 = lt.LTC_FLOAT_2) : u.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = lt.LTC_HALF_1, r.rectAreaLTC2 = lt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = x, r.ambient[1] = M, r.ambient[2] = b;
    const G = r.hash;
    (G.directionalLength !== E || G.pointLength !== w || G.spotLength !== R || G.rectAreaLength !== A || G.hemiLength !== P || G.numDirectionalShadows !== N || G.numPointShadows !== I || G.numSpotShadows !== B || G.numSpotMaps !== W) && (r.directional.length = E, r.spot.length = R, r.rectArea.length = A, r.point.length = w, r.hemi.length = P, r.directionalShadow.length = N, r.directionalShadowMap.length = N, r.pointShadow.length = I, r.pointShadowMap.length = I, r.spotShadow.length = B, r.spotShadowMap.length = B, r.directionalShadowMatrix.length = N, r.pointShadowMatrix.length = I, r.spotLightMatrix.length = B + W - z, r.spotLightMap.length = W, r.numSpotLightShadowsWithMaps = z, G.directionalLength = E, G.pointLength = w, G.spotLength = R, G.rectAreaLength = A, G.hemiLength = P, G.numDirectionalShadows = N, G.numPointShadows = I, G.numSpotShadows = B, G.numSpotMaps = W, r.version = nO++);
  }
  function m(g, _) {
    let x = 0, M = 0, b = 0, E = 0, w = 0;
    const R = _.matrixWorldInverse;
    for (let A = 0, P = g.length; A < P; A++) {
      const N = g[A];
      if (N.isDirectionalLight) {
        const I = r.directional[x];
        I.direction.setFromMatrixPosition(N.matrixWorld), s.setFromMatrixPosition(N.target.matrixWorld), I.direction.sub(s), I.direction.transformDirection(R), x++;
      } else if (N.isSpotLight) {
        const I = r.spot[b];
        I.position.setFromMatrixPosition(N.matrixWorld), I.position.applyMatrix4(R), I.direction.setFromMatrixPosition(N.matrixWorld), s.setFromMatrixPosition(N.target.matrixWorld), I.direction.sub(s), I.direction.transformDirection(R), b++;
      } else if (N.isRectAreaLight) {
        const I = r.rectArea[E];
        I.position.setFromMatrixPosition(N.matrixWorld), I.position.applyMatrix4(R), f.identity(), c.copy(N.matrixWorld), c.premultiply(R), f.extractRotation(c), I.halfWidth.set(N.width * 0.5, 0, 0), I.halfHeight.set(0, N.height * 0.5, 0), I.halfWidth.applyMatrix4(f), I.halfHeight.applyMatrix4(f), E++;
      } else if (N.isPointLight) {
        const I = r.point[M];
        I.position.setFromMatrixPosition(N.matrixWorld), I.position.applyMatrix4(R), M++;
      } else if (N.isHemisphereLight) {
        const I = r.hemi[w];
        I.direction.setFromMatrixPosition(N.matrixWorld), I.direction.transformDirection(R), w++;
      }
    }
  }
  return {
    setup: h,
    setupView: m,
    state: r
  };
}
function nw(u, e) {
  const t = new rO(u, e), n = [], r = [];
  function s() {
    n.length = 0, r.length = 0;
  }
  function c(_) {
    n.push(_);
  }
  function f(_) {
    r.push(_);
  }
  function h(_) {
    t.setup(n, _);
  }
  function m(_) {
    t.setupView(n, _);
  }
  return {
    init: s,
    state: {
      lightsArray: n,
      shadowsArray: r,
      lights: t
    },
    setupLights: h,
    setupLightsView: m,
    pushLight: c,
    pushShadow: f
  };
}
function aO(u, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(s, c = 0) {
    const f = t.get(s);
    let h;
    return f === void 0 ? (h = new nw(u, e), t.set(s, [h])) : c >= f.length ? (h = new nw(u, e), f.push(h)) : h = f[c], h;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class iS extends Ki {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = fT, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class rS extends Ki {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new q(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const sO = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, oO = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function lO(u, e, t) {
  let n = new Ng();
  const r = new Ue(), s = new Ue(), c = new An(), f = new iS({ depthPacking: dT }), h = new rS(), m = {}, g = t.maxTextureSize, _ = { 0: ma, 1: sc, 2: Fs }, x = new Hs({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ue() },
      radius: { value: 4 }
    },
    vertexShader: sO,
    fragmentShader: oO
  }), M = x.clone();
  M.defines.HORIZONTAL_PASS = 1;
  const b = new Kt();
  b.setAttribute(
    "position",
    new Fn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const E = new Qi(b, x), w = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Ag, this.render = function(N, I, B) {
    if (w.enabled === !1 || w.autoUpdate === !1 && w.needsUpdate === !1 || N.length === 0)
      return;
    const W = u.getRenderTarget(), z = u.getActiveCubeFace(), k = u.getActiveMipmapLevel(), G = u.state;
    G.setBlending(Co), G.buffers.color.setClear(1, 1, 1, 1), G.buffers.depth.setTest(!0), G.setScissorTest(!1);
    for (let $ = 0, oe = N.length; $ < oe; $++) {
      const ne = N[$], ee = ne.shadow;
      if (ee === void 0) {
        console.warn("THREE.WebGLShadowMap:", ne, "has no shadow.");
        continue;
      }
      if (ee.autoUpdate === !1 && ee.needsUpdate === !1)
        continue;
      r.copy(ee.mapSize);
      const ye = ee.getFrameExtents();
      if (r.multiply(ye), s.copy(ee.mapSize), (r.x > g || r.y > g) && (r.x > g && (s.x = Math.floor(g / ye.x), r.x = s.x * ye.x, ee.mapSize.x = s.x), r.y > g && (s.y = Math.floor(g / ye.y), r.y = s.y * ye.y, ee.mapSize.y = s.y)), ee.map === null) {
        const De = this.type !== Xu ? { minFilter: Si, magFilter: Si } : {};
        ee.map = new Wa(r.x, r.y, De), ee.map.texture.name = ne.name + ".shadowMap", ee.camera.updateProjectionMatrix();
      }
      u.setRenderTarget(ee.map), u.clear();
      const Me = ee.getViewportCount();
      for (let De = 0; De < Me; De++) {
        const V = ee.getViewport(De);
        c.set(
          s.x * V.x,
          s.y * V.y,
          s.x * V.z,
          s.y * V.w
        ), G.viewport(c), ee.updateMatrices(ne, De), n = ee.getFrustum(), P(I, B, ee.camera, ne, this.type);
      }
      ee.isPointLightShadow !== !0 && this.type === Xu && R(ee, B), ee.needsUpdate = !1;
    }
    w.needsUpdate = !1, u.setRenderTarget(W, z, k);
  };
  function R(N, I) {
    const B = e.update(E);
    x.defines.VSM_SAMPLES !== N.blurSamples && (x.defines.VSM_SAMPLES = N.blurSamples, M.defines.VSM_SAMPLES = N.blurSamples, x.needsUpdate = !0, M.needsUpdate = !0), N.mapPass === null && (N.mapPass = new Wa(r.x, r.y)), x.uniforms.shadow_pass.value = N.map.texture, x.uniforms.resolution.value = N.mapSize, x.uniforms.radius.value = N.radius, u.setRenderTarget(N.mapPass), u.clear(), u.renderBufferDirect(I, null, B, x, E, null), M.uniforms.shadow_pass.value = N.mapPass.texture, M.uniforms.resolution.value = N.mapSize, M.uniforms.radius.value = N.radius, u.setRenderTarget(N.map), u.clear(), u.renderBufferDirect(I, null, B, M, E, null);
  }
  function A(N, I, B, W, z, k) {
    let G = null;
    const $ = B.isPointLight === !0 ? N.customDistanceMaterial : N.customDepthMaterial;
    if ($ !== void 0 ? G = $ : G = B.isPointLight === !0 ? h : f, u.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0) {
      const oe = G.uuid, ne = I.uuid;
      let ee = m[oe];
      ee === void 0 && (ee = {}, m[oe] = ee);
      let ye = ee[ne];
      ye === void 0 && (ye = G.clone(), ee[ne] = ye), G = ye;
    }
    return G.visible = I.visible, G.wireframe = I.wireframe, k === Xu ? G.side = I.shadowSide !== null ? I.shadowSide : I.side : G.side = I.shadowSide !== null ? I.shadowSide : _[I.side], G.alphaMap = I.alphaMap, G.alphaTest = I.alphaTest, G.clipShadows = I.clipShadows, G.clippingPlanes = I.clippingPlanes, G.clipIntersection = I.clipIntersection, G.displacementMap = I.displacementMap, G.displacementScale = I.displacementScale, G.displacementBias = I.displacementBias, G.wireframeLinewidth = I.wireframeLinewidth, G.linewidth = I.linewidth, B.isPointLight === !0 && G.isMeshDistanceMaterial === !0 && (G.referencePosition.setFromMatrixPosition(B.matrixWorld), G.nearDistance = W, G.farDistance = z), G;
  }
  function P(N, I, B, W, z) {
    if (N.visible === !1)
      return;
    if (N.layers.test(I.layers) && (N.isMesh || N.isLine || N.isPoints) && (N.castShadow || N.receiveShadow && z === Xu) && (!N.frustumCulled || n.intersectsObject(N))) {
      N.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, N.matrixWorld);
      const $ = e.update(N), oe = N.material;
      if (Array.isArray(oe)) {
        const ne = $.groups;
        for (let ee = 0, ye = ne.length; ee < ye; ee++) {
          const Me = ne[ee], De = oe[Me.materialIndex];
          if (De && De.visible) {
            const V = A(N, De, W, B.near, B.far, z);
            u.renderBufferDirect(B, null, $, V, N, Me);
          }
        }
      } else if (oe.visible) {
        const ne = A(N, oe, W, B.near, B.far, z);
        u.renderBufferDirect(B, null, $, ne, N, null);
      }
    }
    const G = N.children;
    for (let $ = 0, oe = G.length; $ < oe; $++)
      P(G[$], I, B, W, z);
  }
}
function uO(u, e, t) {
  const n = t.isWebGL2;
  function r() {
    let ie = !1;
    const Re = new An();
    let fe = null;
    const Ae = new An(0, 0, 0, 0);
    return {
      setMask: function(Be) {
        fe !== Be && !ie && (u.colorMask(Be, Be, Be, Be), fe = Be);
      },
      setLocked: function(Be) {
        ie = Be;
      },
      setClear: function(Be, tt, hn, an, bi) {
        bi === !0 && (Be *= an, tt *= an, hn *= an), Re.set(Be, tt, hn, an), Ae.equals(Re) === !1 && (u.clearColor(Be, tt, hn, an), Ae.copy(Re));
      },
      reset: function() {
        ie = !1, fe = null, Ae.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let ie = !1, Re = null, fe = null, Ae = null;
    return {
      setTest: function(Be) {
        Be ? gt(2929) : ot(2929);
      },
      setMask: function(Be) {
        Re !== Be && !ie && (u.depthMask(Be), Re = Be);
      },
      setFunc: function(Be) {
        if (fe !== Be) {
          switch (Be) {
            case zE:
              u.depthFunc(512);
              break;
            case OE:
              u.depthFunc(519);
              break;
            case IE:
              u.depthFunc(513);
              break;
            case _g:
              u.depthFunc(515);
              break;
            case UE:
              u.depthFunc(514);
              break;
            case FE:
              u.depthFunc(518);
              break;
            case BE:
              u.depthFunc(516);
              break;
            case HE:
              u.depthFunc(517);
              break;
            default:
              u.depthFunc(515);
          }
          fe = Be;
        }
      },
      setLocked: function(Be) {
        ie = Be;
      },
      setClear: function(Be) {
        Ae !== Be && (u.clearDepth(Be), Ae = Be);
      },
      reset: function() {
        ie = !1, Re = null, fe = null, Ae = null;
      }
    };
  }
  function c() {
    let ie = !1, Re = null, fe = null, Ae = null, Be = null, tt = null, hn = null, an = null, bi = null;
    return {
      setTest: function(Sn) {
        ie || (Sn ? gt(2960) : ot(2960));
      },
      setMask: function(Sn) {
        Re !== Sn && !ie && (u.stencilMask(Sn), Re = Sn);
      },
      setFunc: function(Sn, Bt, Ln) {
        (fe !== Sn || Ae !== Bt || Be !== Ln) && (u.stencilFunc(Sn, Bt, Ln), fe = Sn, Ae = Bt, Be = Ln);
      },
      setOp: function(Sn, Bt, Ln) {
        (tt !== Sn || hn !== Bt || an !== Ln) && (u.stencilOp(Sn, Bt, Ln), tt = Sn, hn = Bt, an = Ln);
      },
      setLocked: function(Sn) {
        ie = Sn;
      },
      setClear: function(Sn) {
        bi !== Sn && (u.clearStencil(Sn), bi = Sn);
      },
      reset: function() {
        ie = !1, Re = null, fe = null, Ae = null, Be = null, tt = null, hn = null, an = null, bi = null;
      }
    };
  }
  const f = new r(), h = new s(), m = new c(), g = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
  let x = {}, M = {}, b = /* @__PURE__ */ new WeakMap(), E = [], w = null, R = !1, A = null, P = null, N = null, I = null, B = null, W = null, z = null, k = !1, G = null, $ = null, oe = null, ne = null, ee = null;
  const ye = u.getParameter(35661);
  let Me = !1, De = 0;
  const V = u.getParameter(7938);
  V.indexOf("WebGL") !== -1 ? (De = parseFloat(/^WebGL (\d)/.exec(V)[1]), Me = De >= 1) : V.indexOf("OpenGL ES") !== -1 && (De = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), Me = De >= 2);
  let J = null, Y = {};
  const de = u.getParameter(3088), le = u.getParameter(2978), Pe = new An().fromArray(de), We = new An().fromArray(le);
  function $e(ie, Re, fe) {
    const Ae = new Uint8Array(4), Be = u.createTexture();
    u.bindTexture(ie, Be), u.texParameteri(ie, 10241, 9728), u.texParameteri(ie, 10240, 9728);
    for (let tt = 0; tt < fe; tt++)
      u.texImage2D(Re + tt, 0, 6408, 1, 1, 0, 6408, 5121, Ae);
    return Be;
  }
  const ve = {};
  ve[3553] = $e(3553, 3553, 1), ve[34067] = $e(34067, 34069, 6), f.setClear(0, 0, 0, 1), h.setClear(1), m.setClear(0), gt(2929), h.setFunc(_g), Xe(!1), wt(nx), gt(2884), ke(Co);
  function gt(ie) {
    x[ie] !== !0 && (u.enable(ie), x[ie] = !0);
  }
  function ot(ie) {
    x[ie] !== !1 && (u.disable(ie), x[ie] = !1);
  }
  function _t(ie, Re) {
    return M[ie] !== Re ? (u.bindFramebuffer(ie, Re), M[ie] = Re, n && (ie === 36009 && (M[36160] = Re), ie === 36160 && (M[36009] = Re)), !0) : !1;
  }
  function Qe(ie, Re) {
    let fe = E, Ae = !1;
    if (ie)
      if (fe = b.get(Re), fe === void 0 && (fe = [], b.set(Re, fe)), ie.isWebGLMultipleRenderTargets) {
        const Be = ie.texture;
        if (fe.length !== Be.length || fe[0] !== 36064) {
          for (let tt = 0, hn = Be.length; tt < hn; tt++)
            fe[tt] = 36064 + tt;
          fe.length = Be.length, Ae = !0;
        }
      } else
        fe[0] !== 36064 && (fe[0] = 36064, Ae = !0);
    else
      fe[0] !== 1029 && (fe[0] = 1029, Ae = !0);
    Ae && (t.isWebGL2 ? u.drawBuffers(fe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(fe));
  }
  function At(ie) {
    return w !== ie ? (u.useProgram(ie), w = ie, !0) : !1;
  }
  const Ne = {
    [ju]: 32774,
    [bE]: 32778,
    [wE]: 32779
  };
  if (n)
    Ne[sx] = 32775, Ne[ox] = 32776;
  else {
    const ie = e.get("EXT_blend_minmax");
    ie !== null && (Ne[sx] = ie.MIN_EXT, Ne[ox] = ie.MAX_EXT);
  }
  const we = {
    [EE]: 0,
    [TE]: 1,
    [CE]: 768,
    [jx]: 770,
    [NE]: 776,
    [DE]: 774,
    [AE]: 772,
    [RE]: 769,
    [Yx]: 771,
    [PE]: 775,
    [LE]: 773
  };
  function ke(ie, Re, fe, Ae, Be, tt, hn, an) {
    if (ie === Co) {
      R === !0 && (ot(3042), R = !1);
      return;
    }
    if (R === !1 && (gt(3042), R = !0), ie !== ME) {
      if (ie !== A || an !== k) {
        if ((P !== ju || B !== ju) && (u.blendEquation(32774), P = ju, B = ju), an)
          switch (ie) {
            case ec:
              u.blendFuncSeparate(1, 771, 1, 771);
              break;
            case ix:
              u.blendFunc(1, 1);
              break;
            case rx:
              u.blendFuncSeparate(0, 769, 0, 1);
              break;
            case ax:
              u.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ie);
              break;
          }
        else
          switch (ie) {
            case ec:
              u.blendFuncSeparate(770, 771, 1, 771);
              break;
            case ix:
              u.blendFunc(770, 1);
              break;
            case rx:
              u.blendFuncSeparate(0, 769, 0, 1);
              break;
            case ax:
              u.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ie);
              break;
          }
        N = null, I = null, W = null, z = null, A = ie, k = an;
      }
      return;
    }
    Be = Be || Re, tt = tt || fe, hn = hn || Ae, (Re !== P || Be !== B) && (u.blendEquationSeparate(Ne[Re], Ne[Be]), P = Re, B = Be), (fe !== N || Ae !== I || tt !== W || hn !== z) && (u.blendFuncSeparate(we[fe], we[Ae], we[tt], we[hn]), N = fe, I = Ae, W = tt, z = hn), A = ie, k = null;
  }
  function rt(ie, Re) {
    ie.side === Fs ? ot(2884) : gt(2884);
    let fe = ie.side === ma;
    Re && (fe = !fe), Xe(fe), ie.blending === ec && ie.transparent === !1 ? ke(Co) : ke(ie.blending, ie.blendEquation, ie.blendSrc, ie.blendDst, ie.blendEquationAlpha, ie.blendSrcAlpha, ie.blendDstAlpha, ie.premultipliedAlpha), h.setFunc(ie.depthFunc), h.setTest(ie.depthTest), h.setMask(ie.depthWrite), f.setMask(ie.colorWrite);
    const Ae = ie.stencilWrite;
    m.setTest(Ae), Ae && (m.setMask(ie.stencilWriteMask), m.setFunc(ie.stencilFunc, ie.stencilRef, ie.stencilFuncMask), m.setOp(ie.stencilFail, ie.stencilZFail, ie.stencilZPass)), pt(ie.polygonOffset, ie.polygonOffsetFactor, ie.polygonOffsetUnits), ie.alphaToCoverage === !0 ? gt(32926) : ot(32926);
  }
  function Xe(ie) {
    G !== ie && (ie ? u.frontFace(2304) : u.frontFace(2305), G = ie);
  }
  function wt(ie) {
    ie !== _E ? (gt(2884), ie !== $ && (ie === nx ? u.cullFace(1029) : ie === xE ? u.cullFace(1028) : u.cullFace(1032))) : ot(2884), $ = ie;
  }
  function St(ie) {
    ie !== oe && (Me && u.lineWidth(ie), oe = ie);
  }
  function pt(ie, Re, fe) {
    ie ? (gt(32823), (ne !== Re || ee !== fe) && (u.polygonOffset(Re, fe), ne = Re, ee = fe)) : ot(32823);
  }
  function kt(ie) {
    ie ? gt(3089) : ot(3089);
  }
  function Gt(ie) {
    ie === void 0 && (ie = 33984 + ye - 1), J !== ie && (u.activeTexture(ie), J = ie);
  }
  function X(ie, Re, fe) {
    fe === void 0 && (J === null ? fe = 33984 + ye - 1 : fe = J);
    let Ae = Y[fe];
    Ae === void 0 && (Ae = { type: void 0, texture: void 0 }, Y[fe] = Ae), (Ae.type !== ie || Ae.texture !== Re) && (J !== fe && (u.activeTexture(fe), J = fe), u.bindTexture(ie, Re || ve[ie]), Ae.type = ie, Ae.texture = Re);
  }
  function H() {
    const ie = Y[J];
    ie !== void 0 && ie.type !== void 0 && (u.bindTexture(ie.type, null), ie.type = void 0, ie.texture = void 0);
  }
  function be() {
    try {
      u.compressedTexImage2D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function qe() {
    try {
      u.texSubImage2D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Ye() {
    try {
      u.texSubImage3D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Ke() {
    try {
      u.compressedTexSubImage2D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function Et() {
    try {
      u.texStorage2D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function te() {
    try {
      u.texStorage3D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function he() {
    try {
      u.texImage2D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function ae() {
    try {
      u.texImage3D.apply(u, arguments);
    } catch (ie) {
      console.error("THREE.WebGLState:", ie);
    }
  }
  function pe(ie) {
    Pe.equals(ie) === !1 && (u.scissor(ie.x, ie.y, ie.z, ie.w), Pe.copy(ie));
  }
  function Ee(ie) {
    We.equals(ie) === !1 && (u.viewport(ie.x, ie.y, ie.z, ie.w), We.copy(ie));
  }
  function He(ie, Re) {
    let fe = _.get(Re);
    fe === void 0 && (fe = /* @__PURE__ */ new WeakMap(), _.set(Re, fe));
    let Ae = fe.get(ie);
    Ae === void 0 && (Ae = u.getUniformBlockIndex(Re, ie.name), fe.set(ie, Ae));
  }
  function Fe(ie, Re) {
    const Ae = _.get(Re).get(ie);
    g.get(ie) !== Ae && (u.uniformBlockBinding(Re, Ae, ie.__bindingPointIndex), g.set(ie, Ae));
  }
  function Tt() {
    u.disable(3042), u.disable(2884), u.disable(2929), u.disable(32823), u.disable(3089), u.disable(2960), u.disable(32926), u.blendEquation(32774), u.blendFunc(1, 0), u.blendFuncSeparate(1, 0, 1, 0), u.colorMask(!0, !0, !0, !0), u.clearColor(0, 0, 0, 0), u.depthMask(!0), u.depthFunc(513), u.clearDepth(1), u.stencilMask(4294967295), u.stencilFunc(519, 0, 4294967295), u.stencilOp(7680, 7680, 7680), u.clearStencil(0), u.cullFace(1029), u.frontFace(2305), u.polygonOffset(0, 0), u.activeTexture(33984), u.bindFramebuffer(36160, null), n === !0 && (u.bindFramebuffer(36009, null), u.bindFramebuffer(36008, null)), u.useProgram(null), u.lineWidth(1), u.scissor(0, 0, u.canvas.width, u.canvas.height), u.viewport(0, 0, u.canvas.width, u.canvas.height), x = {}, J = null, Y = {}, M = {}, b = /* @__PURE__ */ new WeakMap(), E = [], w = null, R = !1, A = null, P = null, N = null, I = null, B = null, W = null, z = null, k = !1, G = null, $ = null, oe = null, ne = null, ee = null, Pe.set(0, 0, u.canvas.width, u.canvas.height), We.set(0, 0, u.canvas.width, u.canvas.height), f.reset(), h.reset(), m.reset();
  }
  return {
    buffers: {
      color: f,
      depth: h,
      stencil: m
    },
    enable: gt,
    disable: ot,
    bindFramebuffer: _t,
    drawBuffers: Qe,
    useProgram: At,
    setBlending: ke,
    setMaterial: rt,
    setFlipSided: Xe,
    setCullFace: wt,
    setLineWidth: St,
    setPolygonOffset: pt,
    setScissorTest: kt,
    activeTexture: Gt,
    bindTexture: X,
    unbindTexture: H,
    compressedTexImage2D: be,
    texImage2D: he,
    texImage3D: ae,
    updateUBOMapping: He,
    uniformBlockBinding: Fe,
    texStorage2D: Et,
    texStorage3D: te,
    texSubImage2D: qe,
    texSubImage3D: Ye,
    compressedTexSubImage2D: Ke,
    scissor: pe,
    viewport: Ee,
    reset: Tt
  };
}
function cO(u, e, t, n, r, s, c) {
  const f = r.isWebGL2, h = r.maxTextures, m = r.maxCubemapSize, g = r.maxTextureSize, _ = r.maxSamples, x = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, M = /OculusBrowser/g.test(navigator.userAgent), b = /* @__PURE__ */ new WeakMap();
  let E;
  const w = /* @__PURE__ */ new WeakMap();
  let R = !1;
  try {
    R = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function A(X, H) {
    return R ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(X, H)
    ) : sp("canvas");
  }
  function P(X, H, be, qe) {
    let Ye = 1;
    if ((X.width > qe || X.height > qe) && (Ye = qe / Math.max(X.width, X.height)), Ye < 1 || H === !0)
      if (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && X instanceof ImageBitmap) {
        const Ke = H ? bg : Math.floor, Et = Ke(Ye * X.width), te = Ke(Ye * X.height);
        E === void 0 && (E = A(Et, te));
        const he = be ? A(Et, te) : E;
        return he.width = Et, he.height = te, he.getContext("2d").drawImage(X, 0, 0, Et, te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + X.width + "x" + X.height + ") to (" + Et + "x" + te + ")."), he;
      } else
        return "data" in X && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + X.width + "x" + X.height + ")."), X;
    return X;
  }
  function N(X) {
    return Lx(X.width) && Lx(X.height);
  }
  function I(X) {
    return f ? !1 : X.wrapS !== Lr || X.wrapT !== Lr || X.minFilter !== Si && X.minFilter !== vi;
  }
  function B(X, H) {
    return X.generateMipmaps && H && X.minFilter !== Si && X.minFilter !== vi;
  }
  function W(X) {
    u.generateMipmap(X);
  }
  function z(X, H, be, qe, Ye = !1) {
    if (f === !1)
      return H;
    if (X !== null) {
      if (u[X] !== void 0)
        return u[X];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + X + "'");
    }
    let Ke = H;
    return H === 6403 && (be === 5126 && (Ke = 33326), be === 5131 && (Ke = 33325), be === 5121 && (Ke = 33321)), H === 33319 && (be === 5126 && (Ke = 33328), be === 5131 && (Ke = 33327), be === 5121 && (Ke = 33323)), H === 6408 && (be === 5126 && (Ke = 34836), be === 5131 && (Ke = 34842), be === 5121 && (Ke = qe === ti && Ye === !1 ? 35907 : 32856), be === 32819 && (Ke = 32854), be === 32820 && (Ke = 32855)), (Ke === 33325 || Ke === 33326 || Ke === 33327 || Ke === 33328 || Ke === 34842 || Ke === 34836) && e.get("EXT_color_buffer_float"), Ke;
  }
  function k(X, H, be) {
    return B(X, be) === !0 || X.isFramebufferTexture && X.minFilter !== Si && X.minFilter !== vi ? Math.log2(Math.max(H.width, H.height)) + 1 : X.mipmaps !== void 0 && X.mipmaps.length > 0 ? X.mipmaps.length : X.isCompressedTexture && Array.isArray(X.image) ? H.mipmaps.length : 1;
  }
  function G(X) {
    return X === Si || X === xg || X === Sg ? 9728 : 9729;
  }
  function $(X) {
    const H = X.target;
    H.removeEventListener("dispose", $), ne(H), H.isVideoTexture && b.delete(H);
  }
  function oe(X) {
    const H = X.target;
    H.removeEventListener("dispose", oe), ye(H);
  }
  function ne(X) {
    const H = n.get(X);
    if (H.__webglInit === void 0)
      return;
    const be = X.source, qe = w.get(be);
    if (qe) {
      const Ye = qe[H.__cacheKey];
      Ye.usedTimes--, Ye.usedTimes === 0 && ee(X), Object.keys(qe).length === 0 && w.delete(be);
    }
    n.remove(X);
  }
  function ee(X) {
    const H = n.get(X);
    u.deleteTexture(H.__webglTexture);
    const be = X.source, qe = w.get(be);
    delete qe[H.__cacheKey], c.memory.textures--;
  }
  function ye(X) {
    const H = X.texture, be = n.get(X), qe = n.get(H);
    if (qe.__webglTexture !== void 0 && (u.deleteTexture(qe.__webglTexture), c.memory.textures--), X.depthTexture && X.depthTexture.dispose(), X.isWebGLCubeRenderTarget)
      for (let Ye = 0; Ye < 6; Ye++)
        u.deleteFramebuffer(be.__webglFramebuffer[Ye]), be.__webglDepthbuffer && u.deleteRenderbuffer(be.__webglDepthbuffer[Ye]);
    else {
      if (u.deleteFramebuffer(be.__webglFramebuffer), be.__webglDepthbuffer && u.deleteRenderbuffer(be.__webglDepthbuffer), be.__webglMultisampledFramebuffer && u.deleteFramebuffer(be.__webglMultisampledFramebuffer), be.__webglColorRenderbuffer)
        for (let Ye = 0; Ye < be.__webglColorRenderbuffer.length; Ye++)
          be.__webglColorRenderbuffer[Ye] && u.deleteRenderbuffer(be.__webglColorRenderbuffer[Ye]);
      be.__webglDepthRenderbuffer && u.deleteRenderbuffer(be.__webglDepthRenderbuffer);
    }
    if (X.isWebGLMultipleRenderTargets)
      for (let Ye = 0, Ke = H.length; Ye < Ke; Ye++) {
        const Et = n.get(H[Ye]);
        Et.__webglTexture && (u.deleteTexture(Et.__webglTexture), c.memory.textures--), n.remove(H[Ye]);
      }
    n.remove(H), n.remove(X);
  }
  let Me = 0;
  function De() {
    Me = 0;
  }
  function V() {
    const X = Me;
    return X >= h && console.warn("THREE.WebGLTextures: Trying to use " + X + " texture units while this GPU supports only " + h), Me += 1, X;
  }
  function J(X) {
    const H = [];
    return H.push(X.wrapS), H.push(X.wrapT), H.push(X.magFilter), H.push(X.minFilter), H.push(X.anisotropy), H.push(X.internalFormat), H.push(X.format), H.push(X.type), H.push(X.generateMipmaps), H.push(X.premultiplyAlpha), H.push(X.flipY), H.push(X.unpackAlignment), H.push(X.encoding), H.join();
  }
  function Y(X, H) {
    const be = n.get(X);
    if (X.isVideoTexture && kt(X), X.isRenderTargetTexture === !1 && X.version > 0 && be.__version !== X.version) {
      const qe = X.image;
      if (qe === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (qe.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ot(be, X, H);
        return;
      }
    }
    t.bindTexture(3553, be.__webglTexture, 33984 + H);
  }
  function de(X, H) {
    const be = n.get(X);
    if (X.version > 0 && be.__version !== X.version) {
      ot(be, X, H);
      return;
    }
    t.bindTexture(35866, be.__webglTexture, 33984 + H);
  }
  function le(X, H) {
    const be = n.get(X);
    if (X.version > 0 && be.__version !== X.version) {
      ot(be, X, H);
      return;
    }
    t.bindTexture(32879, be.__webglTexture, 33984 + H);
  }
  function Pe(X, H) {
    const be = n.get(X);
    if (X.version > 0 && be.__version !== X.version) {
      _t(be, X, H);
      return;
    }
    t.bindTexture(34067, be.__webglTexture, 33984 + H);
  }
  const We = {
    [$h]: 10497,
    [Lr]: 33071,
    [ep]: 33648
  }, $e = {
    [Si]: 9728,
    [xg]: 9984,
    [Sg]: 9986,
    [vi]: 9729,
    [Zx]: 9985,
    [cc]: 9987
  };
  function ve(X, H, be) {
    if (be ? (u.texParameteri(X, 10242, We[H.wrapS]), u.texParameteri(X, 10243, We[H.wrapT]), (X === 32879 || X === 35866) && u.texParameteri(X, 32882, We[H.wrapR]), u.texParameteri(X, 10240, $e[H.magFilter]), u.texParameteri(X, 10241, $e[H.minFilter])) : (u.texParameteri(X, 10242, 33071), u.texParameteri(X, 10243, 33071), (X === 32879 || X === 35866) && u.texParameteri(X, 32882, 33071), (H.wrapS !== Lr || H.wrapT !== Lr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), u.texParameteri(X, 10240, G(H.magFilter)), u.texParameteri(X, 10241, G(H.minFilter)), H.minFilter !== Si && H.minFilter !== vi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const qe = e.get("EXT_texture_filter_anisotropic");
      if (H.type === Eo && e.has("OES_texture_float_linear") === !1 || f === !1 && H.type === td && e.has("OES_texture_half_float_linear") === !1)
        return;
      (H.anisotropy > 1 || n.get(H).__currentAnisotropy) && (u.texParameterf(X, qe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(H.anisotropy, r.getMaxAnisotropy())), n.get(H).__currentAnisotropy = H.anisotropy);
    }
  }
  function gt(X, H) {
    let be = !1;
    X.__webglInit === void 0 && (X.__webglInit = !0, H.addEventListener("dispose", $));
    const qe = H.source;
    let Ye = w.get(qe);
    Ye === void 0 && (Ye = {}, w.set(qe, Ye));
    const Ke = J(H);
    if (Ke !== X.__cacheKey) {
      Ye[Ke] === void 0 && (Ye[Ke] = {
        texture: u.createTexture(),
        usedTimes: 0
      }, c.memory.textures++, be = !0), Ye[Ke].usedTimes++;
      const Et = Ye[X.__cacheKey];
      Et !== void 0 && (Ye[X.__cacheKey].usedTimes--, Et.usedTimes === 0 && ee(H)), X.__cacheKey = Ke, X.__webglTexture = Ye[Ke].texture;
    }
    return be;
  }
  function ot(X, H, be) {
    let qe = 3553;
    H.isDataArrayTexture && (qe = 35866), H.isData3DTexture && (qe = 32879);
    const Ye = gt(X, H), Ke = H.source;
    t.bindTexture(qe, X.__webglTexture, 33984 + be);
    const Et = n.get(Ke);
    if (Ke.version !== Et.__version || Ye === !0) {
      t.activeTexture(33984 + be), u.pixelStorei(37440, H.flipY), u.pixelStorei(37441, H.premultiplyAlpha), u.pixelStorei(3317, H.unpackAlignment), u.pixelStorei(37443, 0);
      const te = I(H) && N(H.image) === !1;
      let he = P(H.image, te, !1, g);
      he = Gt(H, he);
      const ae = N(he) || f, pe = s.convert(H.format, H.encoding);
      let Ee = s.convert(H.type), He = z(H.internalFormat, pe, Ee, H.encoding, H.isVideoTexture);
      ve(qe, H, ae);
      let Fe;
      const Tt = H.mipmaps, ie = f && H.isVideoTexture !== !0, Re = Et.__version === void 0 || Ye === !0, fe = k(H, he, ae);
      if (H.isDepthTexture)
        He = 6402, f ? H.type === Eo ? He = 36012 : H.type === Ol ? He = 33190 : H.type === tc ? He = 35056 : He = 33189 : H.type === Eo && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), H.format === Ul && He === 6402 && H.type !== Jx && H.type !== Ol && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), H.type = Ol, Ee = s.convert(H.type)), H.format === oc && He === 6402 && (He = 34041, H.type !== tc && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), H.type = tc, Ee = s.convert(H.type))), Re && (ie ? t.texStorage2D(3553, 1, He, he.width, he.height) : t.texImage2D(3553, 0, He, he.width, he.height, 0, pe, Ee, null));
      else if (H.isDataTexture)
        if (Tt.length > 0 && ae) {
          ie && Re && t.texStorage2D(3553, fe, He, Tt[0].width, Tt[0].height);
          for (let Ae = 0, Be = Tt.length; Ae < Be; Ae++)
            Fe = Tt[Ae], ie ? t.texSubImage2D(3553, Ae, 0, 0, Fe.width, Fe.height, pe, Ee, Fe.data) : t.texImage2D(3553, Ae, He, Fe.width, Fe.height, 0, pe, Ee, Fe.data);
          H.generateMipmaps = !1;
        } else
          ie ? (Re && t.texStorage2D(3553, fe, He, he.width, he.height), t.texSubImage2D(3553, 0, 0, 0, he.width, he.height, pe, Ee, he.data)) : t.texImage2D(3553, 0, He, he.width, he.height, 0, pe, Ee, he.data);
      else if (H.isCompressedTexture) {
        ie && Re && t.texStorage2D(3553, fe, He, Tt[0].width, Tt[0].height);
        for (let Ae = 0, Be = Tt.length; Ae < Be; Ae++)
          Fe = Tt[Ae], H.format !== pa ? pe !== null ? ie ? t.compressedTexSubImage2D(3553, Ae, 0, 0, Fe.width, Fe.height, pe, Fe.data) : t.compressedTexImage2D(3553, Ae, He, Fe.width, Fe.height, 0, Fe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ie ? t.texSubImage2D(3553, Ae, 0, 0, Fe.width, Fe.height, pe, Ee, Fe.data) : t.texImage2D(3553, Ae, He, Fe.width, Fe.height, 0, pe, Ee, Fe.data);
      } else if (H.isDataArrayTexture)
        ie ? (Re && t.texStorage3D(35866, fe, He, he.width, he.height, he.depth), t.texSubImage3D(35866, 0, 0, 0, 0, he.width, he.height, he.depth, pe, Ee, he.data)) : t.texImage3D(35866, 0, He, he.width, he.height, he.depth, 0, pe, Ee, he.data);
      else if (H.isData3DTexture)
        ie ? (Re && t.texStorage3D(32879, fe, He, he.width, he.height, he.depth), t.texSubImage3D(32879, 0, 0, 0, 0, he.width, he.height, he.depth, pe, Ee, he.data)) : t.texImage3D(32879, 0, He, he.width, he.height, he.depth, 0, pe, Ee, he.data);
      else if (H.isFramebufferTexture) {
        if (Re)
          if (ie)
            t.texStorage2D(3553, fe, He, he.width, he.height);
          else {
            let Ae = he.width, Be = he.height;
            for (let tt = 0; tt < fe; tt++)
              t.texImage2D(3553, tt, He, Ae, Be, 0, pe, Ee, null), Ae >>= 1, Be >>= 1;
          }
      } else if (Tt.length > 0 && ae) {
        ie && Re && t.texStorage2D(3553, fe, He, Tt[0].width, Tt[0].height);
        for (let Ae = 0, Be = Tt.length; Ae < Be; Ae++)
          Fe = Tt[Ae], ie ? t.texSubImage2D(3553, Ae, 0, 0, pe, Ee, Fe) : t.texImage2D(3553, Ae, He, pe, Ee, Fe);
        H.generateMipmaps = !1;
      } else
        ie ? (Re && t.texStorage2D(3553, fe, He, he.width, he.height), t.texSubImage2D(3553, 0, 0, 0, pe, Ee, he)) : t.texImage2D(3553, 0, He, pe, Ee, he);
      B(H, ae) && W(qe), Et.__version = Ke.version, H.onUpdate && H.onUpdate(H);
    }
    X.__version = H.version;
  }
  function _t(X, H, be) {
    if (H.image.length !== 6)
      return;
    const qe = gt(X, H), Ye = H.source;
    t.bindTexture(34067, X.__webglTexture, 33984 + be);
    const Ke = n.get(Ye);
    if (Ye.version !== Ke.__version || qe === !0) {
      t.activeTexture(33984 + be), u.pixelStorei(37440, H.flipY), u.pixelStorei(37441, H.premultiplyAlpha), u.pixelStorei(3317, H.unpackAlignment), u.pixelStorei(37443, 0);
      const Et = H.isCompressedTexture || H.image[0].isCompressedTexture, te = H.image[0] && H.image[0].isDataTexture, he = [];
      for (let Ae = 0; Ae < 6; Ae++)
        !Et && !te ? he[Ae] = P(H.image[Ae], !1, !0, m) : he[Ae] = te ? H.image[Ae].image : H.image[Ae], he[Ae] = Gt(H, he[Ae]);
      const ae = he[0], pe = N(ae) || f, Ee = s.convert(H.format, H.encoding), He = s.convert(H.type), Fe = z(H.internalFormat, Ee, He, H.encoding), Tt = f && H.isVideoTexture !== !0, ie = Ke.__version === void 0 || qe === !0;
      let Re = k(H, ae, pe);
      ve(34067, H, pe);
      let fe;
      if (Et) {
        Tt && ie && t.texStorage2D(34067, Re, Fe, ae.width, ae.height);
        for (let Ae = 0; Ae < 6; Ae++) {
          fe = he[Ae].mipmaps;
          for (let Be = 0; Be < fe.length; Be++) {
            const tt = fe[Be];
            H.format !== pa ? Ee !== null ? Tt ? t.compressedTexSubImage2D(34069 + Ae, Be, 0, 0, tt.width, tt.height, Ee, tt.data) : t.compressedTexImage2D(34069 + Ae, Be, Fe, tt.width, tt.height, 0, tt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Tt ? t.texSubImage2D(34069 + Ae, Be, 0, 0, tt.width, tt.height, Ee, He, tt.data) : t.texImage2D(34069 + Ae, Be, Fe, tt.width, tt.height, 0, Ee, He, tt.data);
          }
        }
      } else {
        fe = H.mipmaps, Tt && ie && (fe.length > 0 && Re++, t.texStorage2D(34067, Re, Fe, he[0].width, he[0].height));
        for (let Ae = 0; Ae < 6; Ae++)
          if (te) {
            Tt ? t.texSubImage2D(34069 + Ae, 0, 0, 0, he[Ae].width, he[Ae].height, Ee, He, he[Ae].data) : t.texImage2D(34069 + Ae, 0, Fe, he[Ae].width, he[Ae].height, 0, Ee, He, he[Ae].data);
            for (let Be = 0; Be < fe.length; Be++) {
              const hn = fe[Be].image[Ae].image;
              Tt ? t.texSubImage2D(34069 + Ae, Be + 1, 0, 0, hn.width, hn.height, Ee, He, hn.data) : t.texImage2D(34069 + Ae, Be + 1, Fe, hn.width, hn.height, 0, Ee, He, hn.data);
            }
          } else {
            Tt ? t.texSubImage2D(34069 + Ae, 0, 0, 0, Ee, He, he[Ae]) : t.texImage2D(34069 + Ae, 0, Fe, Ee, He, he[Ae]);
            for (let Be = 0; Be < fe.length; Be++) {
              const tt = fe[Be];
              Tt ? t.texSubImage2D(34069 + Ae, Be + 1, 0, 0, Ee, He, tt.image[Ae]) : t.texImage2D(34069 + Ae, Be + 1, Fe, Ee, He, tt.image[Ae]);
            }
          }
      }
      B(H, pe) && W(34067), Ke.__version = Ye.version, H.onUpdate && H.onUpdate(H);
    }
    X.__version = H.version;
  }
  function Qe(X, H, be, qe, Ye) {
    const Ke = s.convert(be.format, be.encoding), Et = s.convert(be.type), te = z(be.internalFormat, Ke, Et, be.encoding);
    n.get(H).__hasExternalTextures || (Ye === 32879 || Ye === 35866 ? t.texImage3D(Ye, 0, te, H.width, H.height, H.depth, 0, Ke, Et, null) : t.texImage2D(Ye, 0, te, H.width, H.height, 0, Ke, Et, null)), t.bindFramebuffer(36160, X), pt(H) ? x.framebufferTexture2DMultisampleEXT(36160, qe, Ye, n.get(be).__webglTexture, 0, St(H)) : u.framebufferTexture2D(36160, qe, Ye, n.get(be).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function At(X, H, be) {
    if (u.bindRenderbuffer(36161, X), H.depthBuffer && !H.stencilBuffer) {
      let qe = 33189;
      if (be || pt(H)) {
        const Ye = H.depthTexture;
        Ye && Ye.isDepthTexture && (Ye.type === Eo ? qe = 36012 : Ye.type === Ol && (qe = 33190));
        const Ke = St(H);
        pt(H) ? x.renderbufferStorageMultisampleEXT(36161, Ke, qe, H.width, H.height) : u.renderbufferStorageMultisample(36161, Ke, qe, H.width, H.height);
      } else
        u.renderbufferStorage(36161, qe, H.width, H.height);
      u.framebufferRenderbuffer(36160, 36096, 36161, X);
    } else if (H.depthBuffer && H.stencilBuffer) {
      const qe = St(H);
      be && pt(H) === !1 ? u.renderbufferStorageMultisample(36161, qe, 35056, H.width, H.height) : pt(H) ? x.renderbufferStorageMultisampleEXT(36161, qe, 35056, H.width, H.height) : u.renderbufferStorage(36161, 34041, H.width, H.height), u.framebufferRenderbuffer(36160, 33306, 36161, X);
    } else {
      const qe = H.isWebGLMultipleRenderTargets === !0 ? H.texture : [H.texture];
      for (let Ye = 0; Ye < qe.length; Ye++) {
        const Ke = qe[Ye], Et = s.convert(Ke.format, Ke.encoding), te = s.convert(Ke.type), he = z(Ke.internalFormat, Et, te, Ke.encoding), ae = St(H);
        be && pt(H) === !1 ? u.renderbufferStorageMultisample(36161, ae, he, H.width, H.height) : pt(H) ? x.renderbufferStorageMultisampleEXT(36161, ae, he, H.width, H.height) : u.renderbufferStorage(36161, he, H.width, H.height);
      }
    }
    u.bindRenderbuffer(36161, null);
  }
  function Ne(X, H) {
    if (H && H.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, X), !(H.depthTexture && H.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(H.depthTexture).__webglTexture || H.depthTexture.image.width !== H.width || H.depthTexture.image.height !== H.height) && (H.depthTexture.image.width = H.width, H.depthTexture.image.height = H.height, H.depthTexture.needsUpdate = !0), Y(H.depthTexture, 0);
    const qe = n.get(H.depthTexture).__webglTexture, Ye = St(H);
    if (H.depthTexture.format === Ul)
      pt(H) ? x.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, qe, 0, Ye) : u.framebufferTexture2D(36160, 36096, 3553, qe, 0);
    else if (H.depthTexture.format === oc)
      pt(H) ? x.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, qe, 0, Ye) : u.framebufferTexture2D(36160, 33306, 3553, qe, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function we(X) {
    const H = n.get(X), be = X.isWebGLCubeRenderTarget === !0;
    if (X.depthTexture && !H.__autoAllocateDepthBuffer) {
      if (be)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Ne(H.__webglFramebuffer, X);
    } else if (be) {
      H.__webglDepthbuffer = [];
      for (let qe = 0; qe < 6; qe++)
        t.bindFramebuffer(36160, H.__webglFramebuffer[qe]), H.__webglDepthbuffer[qe] = u.createRenderbuffer(), At(H.__webglDepthbuffer[qe], X, !1);
    } else
      t.bindFramebuffer(36160, H.__webglFramebuffer), H.__webglDepthbuffer = u.createRenderbuffer(), At(H.__webglDepthbuffer, X, !1);
    t.bindFramebuffer(36160, null);
  }
  function ke(X, H, be) {
    const qe = n.get(X);
    H !== void 0 && Qe(qe.__webglFramebuffer, X, X.texture, 36064, 3553), be !== void 0 && we(X);
  }
  function rt(X) {
    const H = X.texture, be = n.get(X), qe = n.get(H);
    X.addEventListener("dispose", oe), X.isWebGLMultipleRenderTargets !== !0 && (qe.__webglTexture === void 0 && (qe.__webglTexture = u.createTexture()), qe.__version = H.version, c.memory.textures++);
    const Ye = X.isWebGLCubeRenderTarget === !0, Ke = X.isWebGLMultipleRenderTargets === !0, Et = N(X) || f;
    if (Ye) {
      be.__webglFramebuffer = [];
      for (let te = 0; te < 6; te++)
        be.__webglFramebuffer[te] = u.createFramebuffer();
    } else {
      if (be.__webglFramebuffer = u.createFramebuffer(), Ke)
        if (r.drawBuffers) {
          const te = X.texture;
          for (let he = 0, ae = te.length; he < ae; he++) {
            const pe = n.get(te[he]);
            pe.__webglTexture === void 0 && (pe.__webglTexture = u.createTexture(), c.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (f && X.samples > 0 && pt(X) === !1) {
        const te = Ke ? H : [H];
        be.__webglMultisampledFramebuffer = u.createFramebuffer(), be.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, be.__webglMultisampledFramebuffer);
        for (let he = 0; he < te.length; he++) {
          const ae = te[he];
          be.__webglColorRenderbuffer[he] = u.createRenderbuffer(), u.bindRenderbuffer(36161, be.__webglColorRenderbuffer[he]);
          const pe = s.convert(ae.format, ae.encoding), Ee = s.convert(ae.type), He = z(ae.internalFormat, pe, Ee, ae.encoding, X.isXRRenderTarget === !0), Fe = St(X);
          u.renderbufferStorageMultisample(36161, Fe, He, X.width, X.height), u.framebufferRenderbuffer(36160, 36064 + he, 36161, be.__webglColorRenderbuffer[he]);
        }
        u.bindRenderbuffer(36161, null), X.depthBuffer && (be.__webglDepthRenderbuffer = u.createRenderbuffer(), At(be.__webglDepthRenderbuffer, X, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (Ye) {
      t.bindTexture(34067, qe.__webglTexture), ve(34067, H, Et);
      for (let te = 0; te < 6; te++)
        Qe(be.__webglFramebuffer[te], X, H, 36064, 34069 + te);
      B(H, Et) && W(34067), t.unbindTexture();
    } else if (Ke) {
      const te = X.texture;
      for (let he = 0, ae = te.length; he < ae; he++) {
        const pe = te[he], Ee = n.get(pe);
        t.bindTexture(3553, Ee.__webglTexture), ve(3553, pe, Et), Qe(be.__webglFramebuffer, X, pe, 36064 + he, 3553), B(pe, Et) && W(3553);
      }
      t.unbindTexture();
    } else {
      let te = 3553;
      (X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) && (f ? te = X.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(te, qe.__webglTexture), ve(te, H, Et), Qe(be.__webglFramebuffer, X, H, 36064, te), B(H, Et) && W(te), t.unbindTexture();
    }
    X.depthBuffer && we(X);
  }
  function Xe(X) {
    const H = N(X) || f, be = X.isWebGLMultipleRenderTargets === !0 ? X.texture : [X.texture];
    for (let qe = 0, Ye = be.length; qe < Ye; qe++) {
      const Ke = be[qe];
      if (B(Ke, H)) {
        const Et = X.isWebGLCubeRenderTarget ? 34067 : 3553, te = n.get(Ke).__webglTexture;
        t.bindTexture(Et, te), W(Et), t.unbindTexture();
      }
    }
  }
  function wt(X) {
    if (f && X.samples > 0 && pt(X) === !1) {
      const H = X.isWebGLMultipleRenderTargets ? X.texture : [X.texture], be = X.width, qe = X.height;
      let Ye = 16384;
      const Ke = [], Et = X.stencilBuffer ? 33306 : 36096, te = n.get(X), he = X.isWebGLMultipleRenderTargets === !0;
      if (he)
        for (let ae = 0; ae < H.length; ae++)
          t.bindFramebuffer(36160, te.__webglMultisampledFramebuffer), u.framebufferRenderbuffer(36160, 36064 + ae, 36161, null), t.bindFramebuffer(36160, te.__webglFramebuffer), u.framebufferTexture2D(36009, 36064 + ae, 3553, null, 0);
      t.bindFramebuffer(36008, te.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, te.__webglFramebuffer);
      for (let ae = 0; ae < H.length; ae++) {
        Ke.push(36064 + ae), X.depthBuffer && Ke.push(Et);
        const pe = te.__ignoreDepthValues !== void 0 ? te.__ignoreDepthValues : !1;
        if (pe === !1 && (X.depthBuffer && (Ye |= 256), X.stencilBuffer && (Ye |= 1024)), he && u.framebufferRenderbuffer(36008, 36064, 36161, te.__webglColorRenderbuffer[ae]), pe === !0 && (u.invalidateFramebuffer(36008, [Et]), u.invalidateFramebuffer(36009, [Et])), he) {
          const Ee = n.get(H[ae]).__webglTexture;
          u.framebufferTexture2D(36009, 36064, 3553, Ee, 0);
        }
        u.blitFramebuffer(0, 0, be, qe, 0, 0, be, qe, Ye, 9728), M && u.invalidateFramebuffer(36008, Ke);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), he)
        for (let ae = 0; ae < H.length; ae++) {
          t.bindFramebuffer(36160, te.__webglMultisampledFramebuffer), u.framebufferRenderbuffer(36160, 36064 + ae, 36161, te.__webglColorRenderbuffer[ae]);
          const pe = n.get(H[ae]).__webglTexture;
          t.bindFramebuffer(36160, te.__webglFramebuffer), u.framebufferTexture2D(36009, 36064 + ae, 3553, pe, 0);
        }
      t.bindFramebuffer(36009, te.__webglMultisampledFramebuffer);
    }
  }
  function St(X) {
    return Math.min(_, X.samples);
  }
  function pt(X) {
    const H = n.get(X);
    return f && X.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && H.__useRenderToTexture !== !1;
  }
  function kt(X) {
    const H = c.render.frame;
    b.get(X) !== H && (b.set(X, H), X.update());
  }
  function Gt(X, H) {
    const be = X.encoding, qe = X.format, Ye = X.type;
    return X.isCompressedTexture === !0 || X.isVideoTexture === !0 || X.format === Mg || be !== Hl && (be === ti ? f === !1 ? e.has("EXT_sRGB") === !0 && qe === pa ? (X.format = Mg, X.minFilter = vi, X.generateMipmaps = !1) : H = $x.sRGBToLinear(H) : (qe !== pa || Ye !== Ro) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", be)), H;
  }
  this.allocateTextureUnit = V, this.resetTextureUnits = De, this.setTexture2D = Y, this.setTexture2DArray = de, this.setTexture3D = le, this.setTextureCube = Pe, this.rebindTextures = ke, this.setupRenderTarget = rt, this.updateRenderTargetMipmap = Xe, this.updateMultisampleRenderTarget = wt, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = Qe, this.useMultisampledRTT = pt;
}
function TT(u, e, t) {
  const n = t.isWebGL2;
  function r(s, c = null) {
    let f;
    if (s === Ro)
      return 5121;
    if (s === JE)
      return 32819;
    if (s === QE)
      return 32820;
    if (s === YE)
      return 5120;
    if (s === XE)
      return 5122;
    if (s === Jx)
      return 5123;
    if (s === ZE)
      return 5124;
    if (s === Ol)
      return 5125;
    if (s === Eo)
      return 5126;
    if (s === td)
      return n ? 5131 : (f = e.get("OES_texture_half_float"), f !== null ? f.HALF_FLOAT_OES : null);
    if (s === KE)
      return 6406;
    if (s === pa)
      return 6408;
    if (s === eT)
      return 6409;
    if (s === tT)
      return 6410;
    if (s === Ul)
      return 6402;
    if (s === oc)
      return 34041;
    if (s === nT)
      return 6403;
    if (s === $E)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (s === Mg)
      return f = e.get("EXT_sRGB"), f !== null ? f.SRGB_ALPHA_EXT : null;
    if (s === iT)
      return 36244;
    if (s === rT)
      return 33319;
    if (s === aT)
      return 33320;
    if (s === sT)
      return 36249;
    if (s === fg || s === dg || s === hg || s === pg)
      if (c === ti)
        if (f = e.get("WEBGL_compressed_texture_s3tc_srgb"), f !== null) {
          if (s === fg)
            return f.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === dg)
            return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === hg)
            return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === pg)
            return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (f = e.get("WEBGL_compressed_texture_s3tc"), f !== null) {
        if (s === fg)
          return f.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === dg)
          return f.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === hg)
          return f.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === pg)
          return f.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === lx || s === ux || s === cx || s === fx)
      if (f = e.get("WEBGL_compressed_texture_pvrtc"), f !== null) {
        if (s === lx)
          return f.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === ux)
          return f.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === cx)
          return f.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === fx)
          return f.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === oT)
      return f = e.get("WEBGL_compressed_texture_etc1"), f !== null ? f.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === dx || s === hx)
      if (f = e.get("WEBGL_compressed_texture_etc"), f !== null) {
        if (s === dx)
          return c === ti ? f.COMPRESSED_SRGB8_ETC2 : f.COMPRESSED_RGB8_ETC2;
        if (s === hx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : f.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === px || s === mx || s === vx || s === gx || s === yx || s === _x || s === xx || s === Sx || s === Mx || s === bx || s === wx || s === Ex || s === Tx || s === Cx)
      if (f = e.get("WEBGL_compressed_texture_astc"), f !== null) {
        if (s === px)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : f.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === mx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : f.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === vx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : f.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === gx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : f.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === yx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : f.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === _x)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : f.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === xx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : f.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Sx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : f.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Mx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : f.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === bx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : f.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === wx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : f.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Ex)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : f.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === Tx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : f.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === Cx)
          return c === ti ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : f.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === Rx)
      if (f = e.get("EXT_texture_compression_bptc"), f !== null) {
        if (s === Rx)
          return c === ti ? f.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : f.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return s === tc ? n ? 34042 : (f = e.get("WEBGL_depth_texture"), f !== null ? f.UNSIGNED_INT_24_8_WEBGL : null) : u[s] !== void 0 ? u[s] : null;
  }
  return { convert: r };
}
class CT extends Vi {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Qf extends xn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const fO = { type: "move" };
class A_ {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Qf(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Qf(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new q(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new q()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Qf(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new q(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new q()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let r = null, s = null, c = null;
    const f = this._targetRay, h = this._grip, m = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (m && e.hand) {
        c = !0;
        for (const E of e.hand.values()) {
          const w = t.getJointPose(E, n);
          if (m.joints[E.jointName] === void 0) {
            const A = new Qf();
            A.matrixAutoUpdate = !1, A.visible = !1, m.joints[E.jointName] = A, m.add(A);
          }
          const R = m.joints[E.jointName];
          w !== null && (R.matrix.fromArray(w.transform.matrix), R.matrix.decompose(R.position, R.rotation, R.scale), R.jointRadius = w.radius), R.visible = w !== null;
        }
        const g = m.joints["index-finger-tip"], _ = m.joints["thumb-tip"], x = g.position.distanceTo(_.position), M = 0.02, b = 5e-3;
        m.inputState.pinching && x > M + b ? (m.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !m.inputState.pinching && x <= M - b && (m.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        h !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (h.matrix.fromArray(s.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), s.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(s.linearVelocity)) : h.hasLinearVelocity = !1, s.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(s.angularVelocity)) : h.hasAngularVelocity = !1));
      f !== null && (r = t.getPose(e.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (f.matrix.fromArray(r.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), r.linearVelocity ? (f.hasLinearVelocity = !0, f.linearVelocity.copy(r.linearVelocity)) : f.hasLinearVelocity = !1, r.angularVelocity ? (f.hasAngularVelocity = !0, f.angularVelocity.copy(r.angularVelocity)) : f.hasAngularVelocity = !1, this.dispatchEvent(fO)));
    }
    return f !== null && (f.visible = r !== null), h !== null && (h.visible = s !== null), m !== null && (m.visible = c !== null), this;
  }
}
class RT extends Mi {
  constructor(e, t, n, r, s, c, f, h, m, g) {
    if (g = g !== void 0 ? g : Ul, g !== Ul && g !== oc)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && g === Ul && (n = Ol), n === void 0 && g === oc && (n = tc), super(null, r, s, c, f, h, g, n, m), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = f !== void 0 ? f : Si, this.minFilter = h !== void 0 ? h : Si, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class dO extends ks {
  constructor(e, t) {
    super();
    const n = this;
    let r = null, s = 1, c = null, f = "local-floor", h = null, m = null, g = null, _ = null, x = null, M = null;
    const b = t.getContextAttributes();
    let E = null, w = null;
    const R = [], A = [], P = new Vi();
    P.layers.enable(1), P.viewport = new An();
    const N = new Vi();
    N.layers.enable(2), N.viewport = new An();
    const I = [P, N], B = new CT();
    B.layers.enable(1), B.layers.enable(2);
    let W = null, z = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(J) {
      let Y = R[J];
      return Y === void 0 && (Y = new A_(), R[J] = Y), Y.getTargetRaySpace();
    }, this.getControllerGrip = function(J) {
      let Y = R[J];
      return Y === void 0 && (Y = new A_(), R[J] = Y), Y.getGripSpace();
    }, this.getHand = function(J) {
      let Y = R[J];
      return Y === void 0 && (Y = new A_(), R[J] = Y), Y.getHandSpace();
    };
    function k(J) {
      const Y = A.indexOf(J.inputSource);
      if (Y === -1)
        return;
      const de = R[Y];
      de !== void 0 && de.dispatchEvent({ type: J.type, data: J.inputSource });
    }
    function G() {
      r.removeEventListener("select", k), r.removeEventListener("selectstart", k), r.removeEventListener("selectend", k), r.removeEventListener("squeeze", k), r.removeEventListener("squeezestart", k), r.removeEventListener("squeezeend", k), r.removeEventListener("end", G), r.removeEventListener("inputsourceschange", $);
      for (let J = 0; J < R.length; J++) {
        const Y = A[J];
        Y !== null && (A[J] = null, R[J].disconnect(Y));
      }
      W = null, z = null, e.setRenderTarget(E), x = null, _ = null, g = null, r = null, w = null, V.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(J) {
      s = J, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(J) {
      f = J, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return h || c;
    }, this.setReferenceSpace = function(J) {
      h = J;
    }, this.getBaseLayer = function() {
      return _ !== null ? _ : x;
    }, this.getBinding = function() {
      return g;
    }, this.getFrame = function() {
      return M;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(J) {
      if (r = J, r !== null) {
        if (E = e.getRenderTarget(), r.addEventListener("select", k), r.addEventListener("selectstart", k), r.addEventListener("selectend", k), r.addEventListener("squeeze", k), r.addEventListener("squeezestart", k), r.addEventListener("squeezeend", k), r.addEventListener("end", G), r.addEventListener("inputsourceschange", $), b.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const Y = {
            antialias: r.renderState.layers === void 0 ? b.antialias : !0,
            alpha: b.alpha,
            depth: b.depth,
            stencil: b.stencil,
            framebufferScaleFactor: s
          };
          x = new XRWebGLLayer(r, t, Y), r.updateRenderState({ baseLayer: x }), w = new Wa(
            x.framebufferWidth,
            x.framebufferHeight,
            {
              format: pa,
              type: Ro,
              encoding: e.outputEncoding,
              stencilBuffer: b.stencil
            }
          );
        } else {
          let Y = null, de = null, le = null;
          b.depth && (le = b.stencil ? 35056 : 33190, Y = b.stencil ? oc : Ul, de = b.stencil ? tc : Ol);
          const Pe = {
            colorFormat: 32856,
            depthFormat: le,
            scaleFactor: s
          };
          g = new XRWebGLBinding(r, t), _ = g.createProjectionLayer(Pe), r.updateRenderState({ layers: [_] }), w = new Wa(
            _.textureWidth,
            _.textureHeight,
            {
              format: pa,
              type: Ro,
              depthTexture: new RT(_.textureWidth, _.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, Y),
              stencilBuffer: b.stencil,
              encoding: e.outputEncoding,
              samples: b.antialias ? 4 : 0
            }
          );
          const We = e.properties.get(w);
          We.__ignoreDepthValues = _.ignoreDepthValues;
        }
        w.isXRRenderTarget = !0, this.setFoveation(1), h = null, c = await r.requestReferenceSpace(f), V.setContext(r), V.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    };
    function $(J) {
      for (let Y = 0; Y < J.removed.length; Y++) {
        const de = J.removed[Y], le = A.indexOf(de);
        le >= 0 && (A[le] = null, R[le].dispatchEvent({ type: "disconnected", data: de }));
      }
      for (let Y = 0; Y < J.added.length; Y++) {
        const de = J.added[Y];
        let le = A.indexOf(de);
        if (le === -1) {
          for (let We = 0; We < R.length; We++)
            if (We >= A.length) {
              A.push(de), le = We;
              break;
            } else if (A[We] === null) {
              A[We] = de, le = We;
              break;
            }
          if (le === -1)
            break;
        }
        const Pe = R[le];
        Pe && Pe.dispatchEvent({ type: "connected", data: de });
      }
    }
    const oe = new q(), ne = new q();
    function ee(J, Y, de) {
      oe.setFromMatrixPosition(Y.matrixWorld), ne.setFromMatrixPosition(de.matrixWorld);
      const le = oe.distanceTo(ne), Pe = Y.projectionMatrix.elements, We = de.projectionMatrix.elements, $e = Pe[14] / (Pe[10] - 1), ve = Pe[14] / (Pe[10] + 1), gt = (Pe[9] + 1) / Pe[5], ot = (Pe[9] - 1) / Pe[5], _t = (Pe[8] - 1) / Pe[0], Qe = (We[8] + 1) / We[0], At = $e * _t, Ne = $e * Qe, we = le / (-_t + Qe), ke = we * -_t;
      Y.matrixWorld.decompose(J.position, J.quaternion, J.scale), J.translateX(ke), J.translateZ(we), J.matrixWorld.compose(J.position, J.quaternion, J.scale), J.matrixWorldInverse.copy(J.matrixWorld).invert();
      const rt = $e + we, Xe = ve + we, wt = At - ke, St = Ne + (le - ke), pt = gt * ve / Xe * rt, kt = ot * ve / Xe * rt;
      J.projectionMatrix.makePerspective(wt, St, pt, kt, rt, Xe);
    }
    function ye(J, Y) {
      Y === null ? J.matrixWorld.copy(J.matrix) : J.matrixWorld.multiplyMatrices(Y.matrixWorld, J.matrix), J.matrixWorldInverse.copy(J.matrixWorld).invert();
    }
    this.updateCamera = function(J) {
      if (r === null)
        return;
      B.near = N.near = P.near = J.near, B.far = N.far = P.far = J.far, (W !== B.near || z !== B.far) && (r.updateRenderState({
        depthNear: B.near,
        depthFar: B.far
      }), W = B.near, z = B.far);
      const Y = J.parent, de = B.cameras;
      ye(B, Y);
      for (let Pe = 0; Pe < de.length; Pe++)
        ye(de[Pe], Y);
      B.matrixWorld.decompose(B.position, B.quaternion, B.scale), J.matrix.copy(B.matrix), J.matrix.decompose(J.position, J.quaternion, J.scale);
      const le = J.children;
      for (let Pe = 0, We = le.length; Pe < We; Pe++)
        le[Pe].updateMatrixWorld(!0);
      de.length === 2 ? ee(B, P, N) : B.projectionMatrix.copy(P.projectionMatrix);
    }, this.getCamera = function() {
      return B;
    }, this.getFoveation = function() {
      if (_ !== null)
        return _.fixedFoveation;
      if (x !== null)
        return x.fixedFoveation;
    }, this.setFoveation = function(J) {
      _ !== null && (_.fixedFoveation = J), x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = J);
    };
    let Me = null;
    function De(J, Y) {
      if (m = Y.getViewerPose(h || c), M = Y, m !== null) {
        const de = m.views;
        x !== null && (e.setRenderTargetFramebuffer(w, x.framebuffer), e.setRenderTarget(w));
        let le = !1;
        de.length !== B.cameras.length && (B.cameras.length = 0, le = !0);
        for (let Pe = 0; Pe < de.length; Pe++) {
          const We = de[Pe];
          let $e = null;
          if (x !== null)
            $e = x.getViewport(We);
          else {
            const gt = g.getViewSubImage(_, We);
            $e = gt.viewport, Pe === 0 && (e.setRenderTargetTextures(
              w,
              gt.colorTexture,
              _.ignoreDepthValues ? void 0 : gt.depthStencilTexture
            ), e.setRenderTarget(w));
          }
          let ve = I[Pe];
          ve === void 0 && (ve = new Vi(), ve.layers.enable(Pe), ve.viewport = new An(), I[Pe] = ve), ve.matrix.fromArray(We.transform.matrix), ve.projectionMatrix.fromArray(We.projectionMatrix), ve.viewport.set($e.x, $e.y, $e.width, $e.height), Pe === 0 && B.matrix.copy(ve.matrix), le === !0 && B.cameras.push(ve);
        }
      }
      for (let de = 0; de < R.length; de++) {
        const le = A[de], Pe = R[de];
        le !== null && Pe !== void 0 && Pe.update(le, Y, h || c);
      }
      Me && Me(J, Y), M = null;
    }
    const V = new ST();
    V.setAnimationLoop(De), this.setAnimationLoop = function(J) {
      Me = J;
    }, this.dispose = function() {
    };
  }
}
function hO(u, e) {
  function t(E, w) {
    E.fogColor.value.copy(w.color), w.isFog ? (E.fogNear.value = w.near, E.fogFar.value = w.far) : w.isFogExp2 && (E.fogDensity.value = w.density);
  }
  function n(E, w, R, A, P) {
    w.isMeshBasicMaterial || w.isMeshLambertMaterial ? r(E, w) : w.isMeshToonMaterial ? (r(E, w), g(E, w)) : w.isMeshPhongMaterial ? (r(E, w), m(E, w)) : w.isMeshStandardMaterial ? (r(E, w), _(E, w), w.isMeshPhysicalMaterial && x(E, w, P)) : w.isMeshMatcapMaterial ? (r(E, w), M(E, w)) : w.isMeshDepthMaterial ? r(E, w) : w.isMeshDistanceMaterial ? (r(E, w), b(E, w)) : w.isMeshNormalMaterial ? r(E, w) : w.isLineBasicMaterial ? (s(E, w), w.isLineDashedMaterial && c(E, w)) : w.isPointsMaterial ? f(E, w, R, A) : w.isSpriteMaterial ? h(E, w) : w.isShadowMaterial ? (E.color.value.copy(w.color), E.opacity.value = w.opacity) : w.isShaderMaterial && (w.uniformsNeedUpdate = !1);
  }
  function r(E, w) {
    E.opacity.value = w.opacity, w.color && E.diffuse.value.copy(w.color), w.emissive && E.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity), w.map && (E.map.value = w.map), w.alphaMap && (E.alphaMap.value = w.alphaMap), w.bumpMap && (E.bumpMap.value = w.bumpMap, E.bumpScale.value = w.bumpScale, w.side === ma && (E.bumpScale.value *= -1)), w.displacementMap && (E.displacementMap.value = w.displacementMap, E.displacementScale.value = w.displacementScale, E.displacementBias.value = w.displacementBias), w.emissiveMap && (E.emissiveMap.value = w.emissiveMap), w.normalMap && (E.normalMap.value = w.normalMap, E.normalScale.value.copy(w.normalScale), w.side === ma && E.normalScale.value.negate()), w.specularMap && (E.specularMap.value = w.specularMap), w.alphaTest > 0 && (E.alphaTest.value = w.alphaTest);
    const R = e.get(w).envMap;
    if (R && (E.envMap.value = R, E.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1, E.reflectivity.value = w.reflectivity, E.ior.value = w.ior, E.refractionRatio.value = w.refractionRatio), w.lightMap) {
      E.lightMap.value = w.lightMap;
      const N = u.physicallyCorrectLights !== !0 ? Math.PI : 1;
      E.lightMapIntensity.value = w.lightMapIntensity * N;
    }
    w.aoMap && (E.aoMap.value = w.aoMap, E.aoMapIntensity.value = w.aoMapIntensity);
    let A;
    w.map ? A = w.map : w.specularMap ? A = w.specularMap : w.displacementMap ? A = w.displacementMap : w.normalMap ? A = w.normalMap : w.bumpMap ? A = w.bumpMap : w.roughnessMap ? A = w.roughnessMap : w.metalnessMap ? A = w.metalnessMap : w.alphaMap ? A = w.alphaMap : w.emissiveMap ? A = w.emissiveMap : w.clearcoatMap ? A = w.clearcoatMap : w.clearcoatNormalMap ? A = w.clearcoatNormalMap : w.clearcoatRoughnessMap ? A = w.clearcoatRoughnessMap : w.iridescenceMap ? A = w.iridescenceMap : w.iridescenceThicknessMap ? A = w.iridescenceThicknessMap : w.specularIntensityMap ? A = w.specularIntensityMap : w.specularColorMap ? A = w.specularColorMap : w.transmissionMap ? A = w.transmissionMap : w.thicknessMap ? A = w.thicknessMap : w.sheenColorMap ? A = w.sheenColorMap : w.sheenRoughnessMap && (A = w.sheenRoughnessMap), A !== void 0 && (A.isWebGLRenderTarget && (A = A.texture), A.matrixAutoUpdate === !0 && A.updateMatrix(), E.uvTransform.value.copy(A.matrix));
    let P;
    w.aoMap ? P = w.aoMap : w.lightMap && (P = w.lightMap), P !== void 0 && (P.isWebGLRenderTarget && (P = P.texture), P.matrixAutoUpdate === !0 && P.updateMatrix(), E.uv2Transform.value.copy(P.matrix));
  }
  function s(E, w) {
    E.diffuse.value.copy(w.color), E.opacity.value = w.opacity;
  }
  function c(E, w) {
    E.dashSize.value = w.dashSize, E.totalSize.value = w.dashSize + w.gapSize, E.scale.value = w.scale;
  }
  function f(E, w, R, A) {
    E.diffuse.value.copy(w.color), E.opacity.value = w.opacity, E.size.value = w.size * R, E.scale.value = A * 0.5, w.map && (E.map.value = w.map), w.alphaMap && (E.alphaMap.value = w.alphaMap), w.alphaTest > 0 && (E.alphaTest.value = w.alphaTest);
    let P;
    w.map ? P = w.map : w.alphaMap && (P = w.alphaMap), P !== void 0 && (P.matrixAutoUpdate === !0 && P.updateMatrix(), E.uvTransform.value.copy(P.matrix));
  }
  function h(E, w) {
    E.diffuse.value.copy(w.color), E.opacity.value = w.opacity, E.rotation.value = w.rotation, w.map && (E.map.value = w.map), w.alphaMap && (E.alphaMap.value = w.alphaMap), w.alphaTest > 0 && (E.alphaTest.value = w.alphaTest);
    let R;
    w.map ? R = w.map : w.alphaMap && (R = w.alphaMap), R !== void 0 && (R.matrixAutoUpdate === !0 && R.updateMatrix(), E.uvTransform.value.copy(R.matrix));
  }
  function m(E, w) {
    E.specular.value.copy(w.specular), E.shininess.value = Math.max(w.shininess, 1e-4);
  }
  function g(E, w) {
    w.gradientMap && (E.gradientMap.value = w.gradientMap);
  }
  function _(E, w) {
    E.roughness.value = w.roughness, E.metalness.value = w.metalness, w.roughnessMap && (E.roughnessMap.value = w.roughnessMap), w.metalnessMap && (E.metalnessMap.value = w.metalnessMap), e.get(w).envMap && (E.envMapIntensity.value = w.envMapIntensity);
  }
  function x(E, w, R) {
    E.ior.value = w.ior, w.sheen > 0 && (E.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen), E.sheenRoughness.value = w.sheenRoughness, w.sheenColorMap && (E.sheenColorMap.value = w.sheenColorMap), w.sheenRoughnessMap && (E.sheenRoughnessMap.value = w.sheenRoughnessMap)), w.clearcoat > 0 && (E.clearcoat.value = w.clearcoat, E.clearcoatRoughness.value = w.clearcoatRoughness, w.clearcoatMap && (E.clearcoatMap.value = w.clearcoatMap), w.clearcoatRoughnessMap && (E.clearcoatRoughnessMap.value = w.clearcoatRoughnessMap), w.clearcoatNormalMap && (E.clearcoatNormalScale.value.copy(w.clearcoatNormalScale), E.clearcoatNormalMap.value = w.clearcoatNormalMap, w.side === ma && E.clearcoatNormalScale.value.negate())), w.iridescence > 0 && (E.iridescence.value = w.iridescence, E.iridescenceIOR.value = w.iridescenceIOR, E.iridescenceThicknessMinimum.value = w.iridescenceThicknessRange[0], E.iridescenceThicknessMaximum.value = w.iridescenceThicknessRange[1], w.iridescenceMap && (E.iridescenceMap.value = w.iridescenceMap), w.iridescenceThicknessMap && (E.iridescenceThicknessMap.value = w.iridescenceThicknessMap)), w.transmission > 0 && (E.transmission.value = w.transmission, E.transmissionSamplerMap.value = R.texture, E.transmissionSamplerSize.value.set(R.width, R.height), w.transmissionMap && (E.transmissionMap.value = w.transmissionMap), E.thickness.value = w.thickness, w.thicknessMap && (E.thicknessMap.value = w.thicknessMap), E.attenuationDistance.value = w.attenuationDistance, E.attenuationColor.value.copy(w.attenuationColor)), E.specularIntensity.value = w.specularIntensity, E.specularColor.value.copy(w.specularColor), w.specularIntensityMap && (E.specularIntensityMap.value = w.specularIntensityMap), w.specularColorMap && (E.specularColorMap.value = w.specularColorMap);
  }
  function M(E, w) {
    w.matcap && (E.matcap.value = w.matcap);
  }
  function b(E, w) {
    E.referencePosition.value.copy(w.referencePosition), E.nearDistance.value = w.nearDistance, E.farDistance.value = w.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: n
  };
}
function pO(u, e, t, n) {
  let r = {}, s = {}, c = [];
  const f = t.isWebGL2 ? u.getParameter(35375) : 0;
  function h(A, P) {
    const N = P.program;
    n.uniformBlockBinding(A, N);
  }
  function m(A, P) {
    let N = r[A.id];
    N === void 0 && (b(A), N = g(A), r[A.id] = N, A.addEventListener("dispose", w));
    const I = P.program;
    n.updateUBOMapping(A, I);
    const B = e.render.frame;
    s[A.id] !== B && (x(A), s[A.id] = B);
  }
  function g(A) {
    const P = _();
    A.__bindingPointIndex = P;
    const N = u.createBuffer(), I = A.__size, B = A.usage;
    return u.bindBuffer(35345, N), u.bufferData(35345, I, B), u.bindBuffer(35345, null), u.bindBufferBase(35345, P, N), N;
  }
  function _() {
    for (let A = 0; A < f; A++)
      if (c.indexOf(A) === -1)
        return c.push(A), A;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function x(A) {
    const P = r[A.id], N = A.uniforms, I = A.__cache;
    u.bindBuffer(35345, P);
    for (let B = 0, W = N.length; B < W; B++) {
      const z = N[B];
      if (M(z, B, I) === !0) {
        const k = z.value, G = z.__offset;
        typeof k == "number" ? (z.__data[0] = k, u.bufferSubData(35345, G, z.__data)) : (z.value.isMatrix3 ? (z.__data[0] = z.value.elements[0], z.__data[1] = z.value.elements[1], z.__data[2] = z.value.elements[2], z.__data[3] = z.value.elements[0], z.__data[4] = z.value.elements[3], z.__data[5] = z.value.elements[4], z.__data[6] = z.value.elements[5], z.__data[7] = z.value.elements[0], z.__data[8] = z.value.elements[6], z.__data[9] = z.value.elements[7], z.__data[10] = z.value.elements[8], z.__data[11] = z.value.elements[0]) : k.toArray(z.__data), u.bufferSubData(35345, G, z.__data));
      }
    }
    u.bindBuffer(35345, null);
  }
  function M(A, P, N) {
    const I = A.value;
    if (N[P] === void 0)
      return typeof I == "number" ? N[P] = I : N[P] = I.clone(), !0;
    if (typeof I == "number") {
      if (N[P] !== I)
        return N[P] = I, !0;
    } else {
      const B = N[P];
      if (B.equals(I) === !1)
        return B.copy(I), !0;
    }
    return !1;
  }
  function b(A) {
    const P = A.uniforms;
    let N = 0;
    const I = 16;
    let B = 0;
    for (let W = 0, z = P.length; W < z; W++) {
      const k = P[W], G = E(k);
      if (k.__data = new Float32Array(G.storage / Float32Array.BYTES_PER_ELEMENT), k.__offset = N, W > 0) {
        B = N % I;
        const $ = I - B;
        B !== 0 && $ - G.boundary < 0 && (N += I - B, k.__offset = N);
      }
      N += G.storage;
    }
    return B = N % I, B > 0 && (N += I - B), A.__size = N, A.__cache = {}, this;
  }
  function E(A) {
    const P = A.value, N = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof P == "number" ? (N.boundary = 4, N.storage = 4) : P.isVector2 ? (N.boundary = 8, N.storage = 8) : P.isVector3 || P.isColor ? (N.boundary = 16, N.storage = 12) : P.isVector4 ? (N.boundary = 16, N.storage = 16) : P.isMatrix3 ? (N.boundary = 48, N.storage = 48) : P.isMatrix4 ? (N.boundary = 64, N.storage = 64) : P.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", P), N;
  }
  function w(A) {
    const P = A.target;
    P.removeEventListener("dispose", w);
    const N = c.indexOf(P.__bindingPointIndex);
    c.splice(N, 1), u.deleteBuffer(r[P.id]), delete r[P.id], delete s[P.id];
  }
  function R() {
    for (const A in r)
      u.deleteBuffer(r[A]);
    c = [], r = {}, s = {};
  }
  return {
    bind: h,
    update: m,
    dispose: R
  };
}
function mO() {
  const u = sp("canvas");
  return u.style.display = "block", u;
}
function aS(u = {}) {
  this.isWebGLRenderer = !0;
  const e = u.canvas !== void 0 ? u.canvas : mO(), t = u.context !== void 0 ? u.context : null, n = u.depth !== void 0 ? u.depth : !0, r = u.stencil !== void 0 ? u.stencil : !0, s = u.antialias !== void 0 ? u.antialias : !1, c = u.premultipliedAlpha !== void 0 ? u.premultipliedAlpha : !0, f = u.preserveDrawingBuffer !== void 0 ? u.preserveDrawingBuffer : !1, h = u.powerPreference !== void 0 ? u.powerPreference : "default", m = u.failIfMajorPerformanceCaveat !== void 0 ? u.failIfMajorPerformanceCaveat : !1;
  let g;
  t !== null ? g = t.getContextAttributes().alpha : g = u.alpha !== void 0 ? u.alpha : !1;
  let _ = null, x = null;
  const M = [], b = [];
  this.domElement = e, this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Hl, this.physicallyCorrectLights = !1, this.toneMapping = ds, this.toneMappingExposure = 1, Object.defineProperties(this, {
    // @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d
    gammaFactor: {
      get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const E = this;
  let w = !1, R = 0, A = 0, P = null, N = -1, I = null;
  const B = new An(), W = new An();
  let z = null, k = e.width, G = e.height, $ = 1, oe = null, ne = null;
  const ee = new An(0, 0, k, G), ye = new An(0, 0, k, G);
  let Me = !1;
  const De = new Ng();
  let V = !1, J = !1, Y = null;
  const de = new Qt(), le = new Ue(), Pe = new q(), We = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function $e() {
    return P === null ? $ : 1;
  }
  let ve = t;
  function gt(j, ge) {
    for (let U = 0; U < j.length; U++) {
      const Q = j[U], se = e.getContext(Q, ge);
      if (se !== null)
        return se;
    }
    return null;
  }
  try {
    const j = {
      alpha: !0,
      depth: n,
      stencil: r,
      antialias: s,
      premultipliedAlpha: c,
      preserveDrawingBuffer: f,
      powerPreference: h,
      failIfMajorPerformanceCaveat: m
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Rg}`), e.addEventListener("webglcontextlost", He, !1), e.addEventListener("webglcontextrestored", Fe, !1), e.addEventListener("webglcontextcreationerror", Tt, !1), ve === null) {
      const ge = ["webgl2", "webgl", "experimental-webgl"];
      if (E.isWebGL1Renderer === !0 && ge.shift(), ve = gt(ge, j), ve === null)
        throw gt(ge) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    ve.getShaderPrecisionFormat === void 0 && (ve.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (j) {
    throw console.error("THREE.WebGLRenderer: " + j.message), j;
  }
  let ot, _t, Qe, At, Ne, we, ke, rt, Xe, wt, St, pt, kt, Gt, X, H, be, qe, Ye, Ke, Et, te, he, ae;
  function pe() {
    ot = new DN(ve), _t = new EN(ve, ot, u), ot.init(_t), te = new TT(ve, ot, _t), Qe = new uO(ve, ot, _t), At = new zN(), Ne = new Qz(), we = new cO(ve, ot, Qe, Ne, _t, te, At), ke = new CN(E), rt = new LN(E), Xe = new qL(ve, _t), he = new bN(ve, ot, Xe, _t), wt = new PN(ve, Xe, At, he), St = new FN(ve, wt, Xe, At), Ye = new UN(ve, _t, we), H = new TN(Ne), pt = new Jz(E, ke, rt, ot, _t, he, H), kt = new hO(E, Ne), Gt = new $z(), X = new aO(ot, _t), qe = new MN(E, ke, Qe, St, g, c), be = new lO(E, St, _t), ae = new pO(ve, At, _t, Qe), Ke = new wN(ve, ot, At, _t), Et = new NN(ve, ot, At, _t), At.programs = pt.programs, E.capabilities = _t, E.extensions = ot, E.properties = Ne, E.renderLists = Gt, E.shadowMap = be, E.state = Qe, E.info = At;
  }
  pe();
  const Ee = new dO(E, ve);
  this.xr = Ee, this.getContext = function() {
    return ve;
  }, this.getContextAttributes = function() {
    return ve.getContextAttributes();
  }, this.forceContextLoss = function() {
    const j = ot.get("WEBGL_lose_context");
    j && j.loseContext();
  }, this.forceContextRestore = function() {
    const j = ot.get("WEBGL_lose_context");
    j && j.restoreContext();
  }, this.getPixelRatio = function() {
    return $;
  }, this.setPixelRatio = function(j) {
    j !== void 0 && ($ = j, this.setSize(k, G, !1));
  }, this.getSize = function(j) {
    return j.set(k, G);
  }, this.setSize = function(j, ge, U) {
    if (Ee.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    k = j, G = ge, e.width = Math.floor(j * $), e.height = Math.floor(ge * $), U !== !1 && (e.style.width = j + "px", e.style.height = ge + "px"), this.setViewport(0, 0, j, ge);
  }, this.getDrawingBufferSize = function(j) {
    return j.set(k * $, G * $).floor();
  }, this.setDrawingBufferSize = function(j, ge, U) {
    k = j, G = ge, $ = U, e.width = Math.floor(j * U), e.height = Math.floor(ge * U), this.setViewport(0, 0, j, ge);
  }, this.getCurrentViewport = function(j) {
    return j.copy(B);
  }, this.getViewport = function(j) {
    return j.copy(ee);
  }, this.setViewport = function(j, ge, U, Q) {
    j.isVector4 ? ee.set(j.x, j.y, j.z, j.w) : ee.set(j, ge, U, Q), Qe.viewport(B.copy(ee).multiplyScalar($).floor());
  }, this.getScissor = function(j) {
    return j.copy(ye);
  }, this.setScissor = function(j, ge, U, Q) {
    j.isVector4 ? ye.set(j.x, j.y, j.z, j.w) : ye.set(j, ge, U, Q), Qe.scissor(W.copy(ye).multiplyScalar($).floor());
  }, this.getScissorTest = function() {
    return Me;
  }, this.setScissorTest = function(j) {
    Qe.setScissorTest(Me = j);
  }, this.setOpaqueSort = function(j) {
    oe = j;
  }, this.setTransparentSort = function(j) {
    ne = j;
  }, this.getClearColor = function(j) {
    return j.copy(qe.getClearColor());
  }, this.setClearColor = function() {
    qe.setClearColor.apply(qe, arguments);
  }, this.getClearAlpha = function() {
    return qe.getClearAlpha();
  }, this.setClearAlpha = function() {
    qe.setClearAlpha.apply(qe, arguments);
  }, this.clear = function(j = !0, ge = !0, U = !0) {
    let Q = 0;
    j && (Q |= 16384), ge && (Q |= 256), U && (Q |= 1024), ve.clear(Q);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", He, !1), e.removeEventListener("webglcontextrestored", Fe, !1), e.removeEventListener("webglcontextcreationerror", Tt, !1), Gt.dispose(), X.dispose(), Ne.dispose(), ke.dispose(), rt.dispose(), St.dispose(), he.dispose(), ae.dispose(), pt.dispose(), Ee.dispose(), Ee.removeEventListener("sessionstart", tt), Ee.removeEventListener("sessionend", hn), Y && (Y.dispose(), Y = null), an.stop();
  };
  function He(j) {
    j.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), w = !0;
  }
  function Fe() {
    console.log("THREE.WebGLRenderer: Context Restored."), w = !1;
    const j = At.autoReset, ge = be.enabled, U = be.autoUpdate, Q = be.needsUpdate, se = be.type;
    pe(), At.autoReset = j, be.enabled = ge, be.autoUpdate = U, be.needsUpdate = Q, be.type = se;
  }
  function Tt(j) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", j.statusMessage);
  }
  function ie(j) {
    const ge = j.target;
    ge.removeEventListener("dispose", ie), Re(ge);
  }
  function Re(j) {
    fe(j), Ne.remove(j);
  }
  function fe(j) {
    const ge = Ne.get(j).programs;
    ge !== void 0 && (ge.forEach(function(U) {
      pt.releaseProgram(U);
    }), j.isShaderMaterial && pt.releaseShaderCache(j));
  }
  this.renderBufferDirect = function(j, ge, U, Q, se, Ve) {
    ge === null && (ge = We);
    const at = se.isMesh && se.matrixWorld.determinant() < 0, mt = wi(j, ge, U, Q, se);
    Qe.setMaterial(Q, at);
    let nt = U.index;
    const ht = U.attributes.position;
    if (nt === null) {
      if (ht === void 0 || ht.count === 0)
        return;
    } else if (nt.count === 0)
      return;
    let Ct = 1;
    Q.wireframe === !0 && (nt = wt.getWireframeAttribute(U), Ct = 2), he.setup(se, Q, mt, U, nt);
    let Mt, Ut = Ke;
    nt !== null && (Mt = Xe.get(nt), Ut = Et, Ut.setIndex(Mt));
    const Dn = nt !== null ? nt.count : ht.count, oi = U.drawRange.start * Ct, Ui = U.drawRange.count * Ct, fn = Ve !== null ? Ve.start * Ct : 0, tn = Ve !== null ? Ve.count * Ct : 1 / 0, gr = Math.max(oi, fn), Bn = Math.min(Dn, oi + Ui, fn + tn) - 1, er = Math.max(0, Bn - gr + 1);
    if (er !== 0) {
      if (se.isMesh)
        Q.wireframe === !0 ? (Qe.setLineWidth(Q.wireframeLinewidth * $e()), Ut.setMode(1)) : Ut.setMode(4);
      else if (se.isLine) {
        let yr = Q.linewidth;
        yr === void 0 && (yr = 1), Qe.setLineWidth(yr * $e()), se.isLineSegments ? Ut.setMode(1) : se.isLineLoop ? Ut.setMode(2) : Ut.setMode(3);
      } else
        se.isPoints ? Ut.setMode(0) : se.isSprite && Ut.setMode(4);
      if (se.isInstancedMesh)
        Ut.renderInstances(gr, er, se.count);
      else if (U.isInstancedBufferGeometry) {
        const yr = Math.min(U.instanceCount, U._maxInstanceCount);
        Ut.renderInstances(gr, er, yr);
      } else
        Ut.render(gr, er);
    }
  }, this.compile = function(j, ge) {
    function U(Q, se, Ve) {
      Q.transparent === !0 && Q.side === Fs ? (Q.side = ma, Q.needsUpdate = !0, $i(Q, se, Ve), Q.side = sc, Q.needsUpdate = !0, $i(Q, se, Ve), Q.side = Fs) : $i(Q, se, Ve);
    }
    x = X.get(j), x.init(), b.push(x), j.traverseVisible(function(Q) {
      Q.isLight && Q.layers.test(ge.layers) && (x.pushLight(Q), Q.castShadow && x.pushShadow(Q));
    }), x.setupLights(E.physicallyCorrectLights), j.traverse(function(Q) {
      const se = Q.material;
      if (se)
        if (Array.isArray(se))
          for (let Ve = 0; Ve < se.length; Ve++) {
            const at = se[Ve];
            U(at, j, Q);
          }
        else
          U(se, j, Q);
    }), b.pop(), x = null;
  };
  let Ae = null;
  function Be(j) {
    Ae && Ae(j);
  }
  function tt() {
    an.stop();
  }
  function hn() {
    an.start();
  }
  const an = new ST();
  an.setAnimationLoop(Be), typeof self < "u" && an.setContext(self), this.setAnimationLoop = function(j) {
    Ae = j, Ee.setAnimationLoop(j), j === null ? an.stop() : an.start();
  }, Ee.addEventListener("sessionstart", tt), Ee.addEventListener("sessionend", hn), this.render = function(j, ge) {
    if (ge !== void 0 && ge.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (w === !0)
      return;
    j.matrixWorldAutoUpdate === !0 && j.updateMatrixWorld(), ge.parent === null && ge.matrixWorldAutoUpdate === !0 && ge.updateMatrixWorld(), Ee.enabled === !0 && Ee.isPresenting === !0 && (Ee.cameraAutoUpdate === !0 && Ee.updateCamera(ge), ge = Ee.getCamera()), j.isScene === !0 && j.onBeforeRender(E, j, ge, P), x = X.get(j, b.length), x.init(), b.push(x), de.multiplyMatrices(ge.projectionMatrix, ge.matrixWorldInverse), De.setFromProjectionMatrix(de), J = this.localClippingEnabled, V = H.init(this.clippingPlanes, J, ge), _ = Gt.get(j, M.length), _.init(), M.push(_), bi(j, ge, 0, E.sortObjects), _.finish(), E.sortObjects === !0 && _.sort(oe, ne), V === !0 && H.beginShadows();
    const U = x.state.shadowsArray;
    if (be.render(U, j, ge), V === !0 && H.endShadows(), this.info.autoReset === !0 && this.info.reset(), qe.render(_, j), x.setupLights(E.physicallyCorrectLights), ge.isArrayCamera) {
      const Q = ge.cameras;
      for (let se = 0, Ve = Q.length; se < Ve; se++) {
        const at = Q[se];
        Sn(_, j, at, at.viewport);
      }
    } else
      Sn(_, j, ge);
    P !== null && (we.updateMultisampleRenderTarget(P), we.updateRenderTargetMipmap(P)), j.isScene === !0 && j.onAfterRender(E, j, ge), he.resetDefaultState(), N = -1, I = null, b.pop(), b.length > 0 ? x = b[b.length - 1] : x = null, M.pop(), M.length > 0 ? _ = M[M.length - 1] : _ = null;
  };
  function bi(j, ge, U, Q) {
    if (j.visible === !1)
      return;
    if (j.layers.test(ge.layers)) {
      if (j.isGroup)
        U = j.renderOrder;
      else if (j.isLOD)
        j.autoUpdate === !0 && j.update(ge);
      else if (j.isLight)
        x.pushLight(j), j.castShadow && x.pushShadow(j);
      else if (j.isSprite) {
        if (!j.frustumCulled || De.intersectsSprite(j)) {
          Q && Pe.setFromMatrixPosition(j.matrixWorld).applyMatrix4(de);
          const at = St.update(j), mt = j.material;
          mt.visible && _.push(j, at, mt, U, Pe.z, null);
        }
      } else if ((j.isMesh || j.isLine || j.isPoints) && (j.isSkinnedMesh && j.skeleton.frame !== At.render.frame && (j.skeleton.update(), j.skeleton.frame = At.render.frame), !j.frustumCulled || De.intersectsObject(j))) {
        Q && Pe.setFromMatrixPosition(j.matrixWorld).applyMatrix4(de);
        const at = St.update(j), mt = j.material;
        if (Array.isArray(mt)) {
          const nt = at.groups;
          for (let ht = 0, Ct = nt.length; ht < Ct; ht++) {
            const Mt = nt[ht], Ut = mt[Mt.materialIndex];
            Ut && Ut.visible && _.push(j, at, Ut, U, Pe.z, Mt);
          }
        } else
          mt.visible && _.push(j, at, mt, U, Pe.z, null);
      }
    }
    const Ve = j.children;
    for (let at = 0, mt = Ve.length; at < mt; at++)
      bi(Ve[at], ge, U, Q);
  }
  function Sn(j, ge, U, Q) {
    const se = j.opaque, Ve = j.transmissive, at = j.transparent;
    x.setupLightsView(U), Ve.length > 0 && Bt(se, ge, U), Q && Qe.viewport(B.copy(Q)), se.length > 0 && Ln(se, ge, U), Ve.length > 0 && Ln(Ve, ge, U), at.length > 0 && Ln(at, ge, U), Qe.buffers.depth.setTest(!0), Qe.buffers.depth.setMask(!0), Qe.buffers.color.setMask(!0), Qe.setPolygonOffset(!1);
  }
  function Bt(j, ge, U) {
    const Q = _t.isWebGL2;
    Y === null && (Y = new Wa(1, 1, {
      generateMipmaps: !0,
      type: ot.has("EXT_color_buffer_half_float") ? td : Ro,
      minFilter: cc,
      samples: Q && s === !0 ? 4 : 0
    })), E.getDrawingBufferSize(le), Q ? Y.setSize(le.x, le.y) : Y.setSize(bg(le.x), bg(le.y));
    const se = E.getRenderTarget();
    E.setRenderTarget(Y), E.clear();
    const Ve = E.toneMapping;
    E.toneMapping = ds, Ln(j, ge, U), E.toneMapping = Ve, we.updateMultisampleRenderTarget(Y), we.updateRenderTargetMipmap(Y), E.setRenderTarget(se);
  }
  function Ln(j, ge, U) {
    const Q = ge.isScene === !0 ? ge.overrideMaterial : null;
    for (let se = 0, Ve = j.length; se < Ve; se++) {
      const at = j[se], mt = at.object, nt = at.geometry, ht = Q === null ? at.material : Q, Ct = at.group;
      mt.layers.test(U.layers) && vr(mt, ge, U, nt, ht, Ct);
    }
  }
  function vr(j, ge, U, Q, se, Ve) {
    j.onBeforeRender(E, ge, U, Q, se, Ve), j.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, j.matrixWorld), j.normalMatrix.getNormalMatrix(j.modelViewMatrix), se.onBeforeRender(E, ge, U, Q, j, Ve), se.transparent === !0 && se.side === Fs ? (se.side = ma, se.needsUpdate = !0, E.renderBufferDirect(U, ge, Q, se, j, Ve), se.side = sc, se.needsUpdate = !0, E.renderBufferDirect(U, ge, Q, se, j, Ve), se.side = Fs) : E.renderBufferDirect(U, ge, Q, se, j, Ve), j.onAfterRender(E, ge, U, Q, se, Ve);
  }
  function $i(j, ge, U) {
    ge.isScene !== !0 && (ge = We);
    const Q = Ne.get(j), se = x.state.lights, Ve = x.state.shadowsArray, at = se.state.version, mt = pt.getParameters(j, se.state, Ve, ge, U), nt = pt.getProgramCacheKey(mt);
    let ht = Q.programs;
    Q.environment = j.isMeshStandardMaterial ? ge.environment : null, Q.fog = ge.fog, Q.envMap = (j.isMeshStandardMaterial ? rt : ke).get(j.envMap || Q.environment), ht === void 0 && (j.addEventListener("dispose", ie), ht = /* @__PURE__ */ new Map(), Q.programs = ht);
    let Ct = ht.get(nt);
    if (Ct !== void 0) {
      if (Q.currentProgram === Ct && Q.lightsStateVersion === at)
        return Ii(j, mt), Ct;
    } else
      mt.uniforms = pt.getUniforms(j), j.onBuild(U, mt, E), j.onBeforeCompile(mt, E), Ct = pt.acquireProgram(mt, nt), ht.set(nt, Ct), Q.uniforms = mt.uniforms;
    const Mt = Q.uniforms;
    (!j.isShaderMaterial && !j.isRawShaderMaterial || j.clipping === !0) && (Mt.clippingPlanes = H.uniform), Ii(j, mt), Q.needsLights = Pr(j), Q.lightsStateVersion = at, Q.needsLights && (Mt.ambientLightColor.value = se.state.ambient, Mt.lightProbe.value = se.state.probe, Mt.directionalLights.value = se.state.directional, Mt.directionalLightShadows.value = se.state.directionalShadow, Mt.spotLights.value = se.state.spot, Mt.spotLightShadows.value = se.state.spotShadow, Mt.rectAreaLights.value = se.state.rectArea, Mt.ltc_1.value = se.state.rectAreaLTC1, Mt.ltc_2.value = se.state.rectAreaLTC2, Mt.pointLights.value = se.state.point, Mt.pointLightShadows.value = se.state.pointShadow, Mt.hemisphereLights.value = se.state.hemi, Mt.directionalShadowMap.value = se.state.directionalShadowMap, Mt.directionalShadowMatrix.value = se.state.directionalShadowMatrix, Mt.spotShadowMap.value = se.state.spotShadowMap, Mt.spotLightMatrix.value = se.state.spotLightMatrix, Mt.spotLightMap.value = se.state.spotLightMap, Mt.pointShadowMap.value = se.state.pointShadowMap, Mt.pointShadowMatrix.value = se.state.pointShadowMatrix);
    const Ut = Ct.getUniforms(), Dn = yg.seqWithValue(Ut.seq, Mt);
    return Q.currentProgram = Ct, Q.uniformsList = Dn, Ct;
  }
  function Ii(j, ge) {
    const U = Ne.get(j);
    U.outputEncoding = ge.outputEncoding, U.instancing = ge.instancing, U.skinning = ge.skinning, U.morphTargets = ge.morphTargets, U.morphNormals = ge.morphNormals, U.morphColors = ge.morphColors, U.morphTargetsCount = ge.morphTargetsCount, U.numClippingPlanes = ge.numClippingPlanes, U.numIntersection = ge.numClipIntersection, U.vertexAlphas = ge.vertexAlphas, U.vertexTangents = ge.vertexTangents, U.toneMapping = ge.toneMapping;
  }
  function wi(j, ge, U, Q, se) {
    ge.isScene !== !0 && (ge = We), we.resetTextureUnits();
    const Ve = ge.fog, at = Q.isMeshStandardMaterial ? ge.environment : null, mt = P === null ? E.outputEncoding : P.isXRRenderTarget === !0 ? P.texture.encoding : Hl, nt = (Q.isMeshStandardMaterial ? rt : ke).get(Q.envMap || at), ht = Q.vertexColors === !0 && !!U.attributes.color && U.attributes.color.itemSize === 4, Ct = !!Q.normalMap && !!U.attributes.tangent, Mt = !!U.morphAttributes.position, Ut = !!U.morphAttributes.normal, Dn = !!U.morphAttributes.color, oi = Q.toneMapped ? E.toneMapping : ds, Ui = U.morphAttributes.position || U.morphAttributes.normal || U.morphAttributes.color, fn = Ui !== void 0 ? Ui.length : 0, tn = Ne.get(Q), gr = x.state.lights;
    if (V === !0 && (J === !0 || j !== I)) {
      const gn = j === I && Q.id === N;
      H.setState(Q, j, gn);
    }
    let Bn = !1;
    Q.version === tn.__version ? (tn.needsLights && tn.lightsStateVersion !== gr.state.version || tn.outputEncoding !== mt || se.isInstancedMesh && tn.instancing === !1 || !se.isInstancedMesh && tn.instancing === !0 || se.isSkinnedMesh && tn.skinning === !1 || !se.isSkinnedMesh && tn.skinning === !0 || tn.envMap !== nt || Q.fog === !0 && tn.fog !== Ve || tn.numClippingPlanes !== void 0 && (tn.numClippingPlanes !== H.numPlanes || tn.numIntersection !== H.numIntersection) || tn.vertexAlphas !== ht || tn.vertexTangents !== Ct || tn.morphTargets !== Mt || tn.morphNormals !== Ut || tn.morphColors !== Dn || tn.toneMapping !== oi || _t.isWebGL2 === !0 && tn.morphTargetsCount !== fn) && (Bn = !0) : (Bn = !0, tn.__version = Q.version);
    let er = tn.currentProgram;
    Bn === !0 && (er = $i(Q, ge, se));
    let yr = !1, _r = !1, tr = !1;
    const Vt = er.getUniforms(), sn = tn.uniforms;
    if (Qe.useProgram(er.program) && (yr = !0, _r = !0, tr = !0), Q.id !== N && (N = Q.id, _r = !0), yr || I !== j) {
      if (Vt.setValue(ve, "projectionMatrix", j.projectionMatrix), _t.logarithmicDepthBuffer && Vt.setValue(
        ve,
        "logDepthBufFC",
        2 / (Math.log(j.far + 1) / Math.LN2)
      ), I !== j && (I = j, _r = !0, tr = !0), Q.isShaderMaterial || Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshStandardMaterial || Q.envMap) {
        const gn = Vt.map.cameraPosition;
        gn !== void 0 && gn.setValue(
          ve,
          Pe.setFromMatrixPosition(j.matrixWorld)
        );
      }
      (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial) && Vt.setValue(ve, "isOrthographic", j.isOrthographicCamera === !0), (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial || Q.isShadowMaterial || se.isSkinnedMesh) && Vt.setValue(ve, "viewMatrix", j.matrixWorldInverse);
    }
    if (se.isSkinnedMesh) {
      Vt.setOptional(ve, se, "bindMatrix"), Vt.setOptional(ve, se, "bindMatrixInverse");
      const gn = se.skeleton;
      gn && (_t.floatVertexTextures ? (gn.boneTexture === null && gn.computeBoneTexture(), Vt.setValue(ve, "boneTexture", gn.boneTexture, we), Vt.setValue(ve, "boneTextureSize", gn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const xr = U.morphAttributes;
    if ((xr.position !== void 0 || xr.normal !== void 0 || xr.color !== void 0 && _t.isWebGL2 === !0) && Ye.update(se, U, Q, er), (_r || tn.receiveShadow !== se.receiveShadow) && (tn.receiveShadow = se.receiveShadow, Vt.setValue(ve, "receiveShadow", se.receiveShadow)), Q.isMeshGouraudMaterial && Q.envMap !== null && (sn.envMap.value = nt, sn.flipEnvMap.value = nt.isCubeTexture && nt.isRenderTargetTexture === !1 ? -1 : 1), _r && (Vt.setValue(ve, "toneMappingExposure", E.toneMappingExposure), tn.needsLights && Do(sn, tr), Ve && Q.fog === !0 && kt.refreshFogUniforms(sn, Ve), kt.refreshMaterialUniforms(sn, Q, $, G, Y), yg.upload(ve, tn.uniformsList, sn, we)), Q.isShaderMaterial && Q.uniformsNeedUpdate === !0 && (yg.upload(ve, tn.uniformsList, sn, we), Q.uniformsNeedUpdate = !1), Q.isSpriteMaterial && Vt.setValue(ve, "center", se.center), Vt.setValue(ve, "modelViewMatrix", se.modelViewMatrix), Vt.setValue(ve, "normalMatrix", se.normalMatrix), Vt.setValue(ve, "modelMatrix", se.matrixWorld), Q.isShaderMaterial || Q.isRawShaderMaterial) {
      const gn = Q.uniformsGroups;
      for (let yn = 0, Jr = gn.length; yn < Jr; yn++)
        if (_t.isWebGL2) {
          const qa = gn[yn];
          ae.update(qa, er), ae.bind(qa, er);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return er;
  }
  function Do(j, ge) {
    j.ambientLightColor.needsUpdate = ge, j.lightProbe.needsUpdate = ge, j.directionalLights.needsUpdate = ge, j.directionalLightShadows.needsUpdate = ge, j.pointLights.needsUpdate = ge, j.pointLightShadows.needsUpdate = ge, j.spotLights.needsUpdate = ge, j.spotLightShadows.needsUpdate = ge, j.rectAreaLights.needsUpdate = ge, j.hemisphereLights.needsUpdate = ge;
  }
  function Pr(j) {
    return j.isMeshLambertMaterial || j.isMeshToonMaterial || j.isMeshPhongMaterial || j.isMeshStandardMaterial || j.isShadowMaterial || j.isShaderMaterial && j.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return R;
  }, this.getActiveMipmapLevel = function() {
    return A;
  }, this.getRenderTarget = function() {
    return P;
  }, this.setRenderTargetTextures = function(j, ge, U) {
    Ne.get(j.texture).__webglTexture = ge, Ne.get(j.depthTexture).__webglTexture = U;
    const Q = Ne.get(j);
    Q.__hasExternalTextures = !0, Q.__hasExternalTextures && (Q.__autoAllocateDepthBuffer = U === void 0, Q.__autoAllocateDepthBuffer || ot.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Q.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(j, ge) {
    const U = Ne.get(j);
    U.__webglFramebuffer = ge, U.__useDefaultFramebuffer = ge === void 0;
  }, this.setRenderTarget = function(j, ge = 0, U = 0) {
    P = j, R = ge, A = U;
    let Q = !0;
    if (j) {
      const nt = Ne.get(j);
      nt.__useDefaultFramebuffer !== void 0 ? (Qe.bindFramebuffer(36160, null), Q = !1) : nt.__webglFramebuffer === void 0 ? we.setupRenderTarget(j) : nt.__hasExternalTextures && we.rebindTextures(j, Ne.get(j.texture).__webglTexture, Ne.get(j.depthTexture).__webglTexture);
    }
    let se = null, Ve = !1, at = !1;
    if (j) {
      const nt = j.texture;
      (nt.isData3DTexture || nt.isDataArrayTexture) && (at = !0);
      const ht = Ne.get(j).__webglFramebuffer;
      j.isWebGLCubeRenderTarget ? (se = ht[ge], Ve = !0) : _t.isWebGL2 && j.samples > 0 && we.useMultisampledRTT(j) === !1 ? se = Ne.get(j).__webglMultisampledFramebuffer : se = ht, B.copy(j.viewport), W.copy(j.scissor), z = j.scissorTest;
    } else
      B.copy(ee).multiplyScalar($).floor(), W.copy(ye).multiplyScalar($).floor(), z = Me;
    if (Qe.bindFramebuffer(36160, se) && _t.drawBuffers && Q && Qe.drawBuffers(j, se), Qe.viewport(B), Qe.scissor(W), Qe.setScissorTest(z), Ve) {
      const nt = Ne.get(j.texture);
      ve.framebufferTexture2D(36160, 36064, 34069 + ge, nt.__webglTexture, U);
    } else if (at) {
      const nt = Ne.get(j.texture), ht = ge || 0;
      ve.framebufferTextureLayer(36160, 36064, nt.__webglTexture, U || 0, ht);
    }
    N = -1;
  }, this.readRenderTargetPixels = function(j, ge, U, Q, se, Ve, at) {
    if (!(j && j.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let mt = Ne.get(j).__webglFramebuffer;
    if (j.isWebGLCubeRenderTarget && at !== void 0 && (mt = mt[at]), mt) {
      Qe.bindFramebuffer(36160, mt);
      try {
        const nt = j.texture, ht = nt.format, Ct = nt.type;
        if (ht !== pa && te.convert(ht) !== ve.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const Mt = Ct === td && (ot.has("EXT_color_buffer_half_float") || _t.isWebGL2 && ot.has("EXT_color_buffer_float"));
        if (Ct !== Ro && te.convert(Ct) !== ve.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(Ct === Eo && (_t.isWebGL2 || ot.has("OES_texture_float") || ot.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !Mt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        ge >= 0 && ge <= j.width - Q && U >= 0 && U <= j.height - se && ve.readPixels(ge, U, Q, se, te.convert(ht), te.convert(Ct), Ve);
      } finally {
        const nt = P !== null ? Ne.get(P).__webglFramebuffer : null;
        Qe.bindFramebuffer(36160, nt);
      }
    }
  }, this.copyFramebufferToTexture = function(j, ge, U = 0) {
    const Q = Math.pow(2, -U), se = Math.floor(ge.image.width * Q), Ve = Math.floor(ge.image.height * Q);
    we.setTexture2D(ge, 0), ve.copyTexSubImage2D(3553, U, 0, 0, j.x, j.y, se, Ve), Qe.unbindTexture();
  }, this.copyTextureToTexture = function(j, ge, U, Q = 0) {
    const se = ge.image.width, Ve = ge.image.height, at = te.convert(U.format), mt = te.convert(U.type);
    we.setTexture2D(U, 0), ve.pixelStorei(37440, U.flipY), ve.pixelStorei(37441, U.premultiplyAlpha), ve.pixelStorei(3317, U.unpackAlignment), ge.isDataTexture ? ve.texSubImage2D(3553, Q, j.x, j.y, se, Ve, at, mt, ge.image.data) : ge.isCompressedTexture ? ve.compressedTexSubImage2D(3553, Q, j.x, j.y, ge.mipmaps[0].width, ge.mipmaps[0].height, at, ge.mipmaps[0].data) : ve.texSubImage2D(3553, Q, j.x, j.y, at, mt, ge.image), Q === 0 && U.generateMipmaps && ve.generateMipmap(3553), Qe.unbindTexture();
  }, this.copyTextureToTexture3D = function(j, ge, U, Q, se = 0) {
    if (E.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const Ve = j.max.x - j.min.x + 1, at = j.max.y - j.min.y + 1, mt = j.max.z - j.min.z + 1, nt = te.convert(Q.format), ht = te.convert(Q.type);
    let Ct;
    if (Q.isData3DTexture)
      we.setTexture3D(Q, 0), Ct = 32879;
    else if (Q.isDataArrayTexture)
      we.setTexture2DArray(Q, 0), Ct = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    ve.pixelStorei(37440, Q.flipY), ve.pixelStorei(37441, Q.premultiplyAlpha), ve.pixelStorei(3317, Q.unpackAlignment);
    const Mt = ve.getParameter(3314), Ut = ve.getParameter(32878), Dn = ve.getParameter(3316), oi = ve.getParameter(3315), Ui = ve.getParameter(32877), fn = U.isCompressedTexture ? U.mipmaps[0] : U.image;
    ve.pixelStorei(3314, fn.width), ve.pixelStorei(32878, fn.height), ve.pixelStorei(3316, j.min.x), ve.pixelStorei(3315, j.min.y), ve.pixelStorei(32877, j.min.z), U.isDataTexture || U.isData3DTexture ? ve.texSubImage3D(Ct, se, ge.x, ge.y, ge.z, Ve, at, mt, nt, ht, fn.data) : U.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ve.compressedTexSubImage3D(Ct, se, ge.x, ge.y, ge.z, Ve, at, mt, nt, fn.data)) : ve.texSubImage3D(Ct, se, ge.x, ge.y, ge.z, Ve, at, mt, nt, ht, fn), ve.pixelStorei(3314, Mt), ve.pixelStorei(32878, Ut), ve.pixelStorei(3316, Dn), ve.pixelStorei(3315, oi), ve.pixelStorei(32877, Ui), se === 0 && Q.generateMipmaps && ve.generateMipmap(Ct), Qe.unbindTexture();
  }, this.initTexture = function(j) {
    j.isCubeTexture ? we.setTextureCube(j, 0) : j.isData3DTexture ? we.setTexture3D(j, 0) : j.isDataArrayTexture ? we.setTexture2DArray(j, 0) : we.setTexture2D(j, 0), Qe.unbindTexture();
  }, this.resetState = function() {
    R = 0, A = 0, P = null, Qe.reset(), he.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class AT extends aS {
}
AT.prototype.isWebGL1Renderer = !0;
class Og {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new xt(e), this.density = t;
  }
  clone() {
    return new Og(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Ig {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new xt(e), this.near = t, this.far = n;
  }
  clone() {
    return new Ig(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class wg extends xn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
  // @deprecated
  get autoUpdate() {
    return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
  }
  set autoUpdate(e) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
  }
}
class Ug {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = rp, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = va();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = va()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = va()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Ar = /* @__PURE__ */ new q();
class lc {
  constructor(e, t, n, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Ar.fromBufferAttribute(this, t), Ar.applyMatrix4(e), this.setXYZ(t, Ar.x, Ar.y, Ar.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ar.fromBufferAttribute(this, t), Ar.applyNormalMatrix(e), this.setXYZ(t, Ar.x, Ar.y, Ar.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ar.fromBufferAttribute(this, t), Ar.transformDirection(e), this.setXYZ(t, Ar.x, Ar.y, Ar.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Un(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = To(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = To(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = To(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = To(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Un(t, this.array), n = Un(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Un(t, this.array), n = Un(n, this.array), r = Un(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, n, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Un(t, this.array), n = Un(n, this.array), r = Un(r, this.array), s = Un(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new Fn(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new lc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class sS extends Ki {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new xt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let kf;
const Bh = /* @__PURE__ */ new q(), Vf = /* @__PURE__ */ new q(), Gf = /* @__PURE__ */ new q(), Wf = /* @__PURE__ */ new Ue(), Hh = /* @__PURE__ */ new Ue(), LT = /* @__PURE__ */ new Qt(), kv = /* @__PURE__ */ new q(), kh = /* @__PURE__ */ new q(), Vv = /* @__PURE__ */ new q(), iw = /* @__PURE__ */ new Ue(), L_ = /* @__PURE__ */ new Ue(), rw = /* @__PURE__ */ new Ue();
class DT extends xn {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", kf === void 0) {
      kf = new Kt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Ug(t, 5);
      kf.setIndex([0, 1, 2, 0, 2, 3]), kf.setAttribute("position", new lc(n, 3, 0, !1)), kf.setAttribute("uv", new lc(n, 2, 3, !1));
    }
    this.geometry = kf, this.material = e !== void 0 ? e : new sS(), this.center = new Ue(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Vf.setFromMatrixScale(this.matrixWorld), LT.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Gf.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Vf.multiplyScalar(-Gf.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const c = this.center;
    Gv(kv.set(-0.5, -0.5, 0), Gf, c, Vf, r, s), Gv(kh.set(0.5, -0.5, 0), Gf, c, Vf, r, s), Gv(Vv.set(0.5, 0.5, 0), Gf, c, Vf, r, s), iw.set(0, 0), L_.set(1, 0), rw.set(1, 1);
    let f = e.ray.intersectTriangle(kv, kh, Vv, !1, Bh);
    if (f === null && (Gv(kh.set(-0.5, 0.5, 0), Gf, c, Vf, r, s), L_.set(0, 1), f = e.ray.intersectTriangle(kv, Vv, kh, !1, Bh), f === null))
      return;
    const h = e.ray.origin.distanceTo(Bh);
    h < e.near || h > e.far || t.push({
      distance: h,
      point: Bh.clone(),
      uv: Ga.getUV(Bh, kv, kh, Vv, iw, L_, rw, new Ue()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Gv(u, e, t, n, r, s) {
  Wf.subVectors(u, t).addScalar(0.5).multiply(n), r !== void 0 ? (Hh.x = s * Wf.x - r * Wf.y, Hh.y = r * Wf.x + s * Wf.y) : Hh.copy(Wf), u.copy(e), u.x += Hh.x, u.y += Hh.y, u.applyMatrix4(LT);
}
const Wv = /* @__PURE__ */ new q(), aw = /* @__PURE__ */ new q();
class PT extends xn {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0) {
    t = Math.abs(t);
    const n = this.levels;
    let r;
    for (r = 0; r < n.length && !(t < n[r].distance); r++)
      ;
    return n.splice(r, 0, { distance: t, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, r;
      for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++)
        ;
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Wv.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Wv);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Wv.setFromMatrixPosition(e.matrixWorld), aw.setFromMatrixPosition(this.matrixWorld);
      const n = Wv.distanceTo(aw) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s && n >= t[r].distance; r++)
        t[r - 1].object.visible = !1, t[r].object.visible = !0;
      for (this._currentLevel = r - 1; r < s; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const c = n[r];
      t.object.levels.push({
        object: c.object.uuid,
        distance: c.distance
      });
    }
    return t;
  }
}
const sw = /* @__PURE__ */ new q(), ow = /* @__PURE__ */ new An(), lw = /* @__PURE__ */ new An(), vO = /* @__PURE__ */ new q(), uw = /* @__PURE__ */ new Qt();
class NT extends Qi {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Qt(), this.bindMatrixInverse = new Qt();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new An(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, r = t.count; n < r; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const n = this.skeleton, r = this.geometry;
    ow.fromBufferAttribute(r.attributes.skinIndex, e), lw.fromBufferAttribute(r.attributes.skinWeight, e), sw.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const c = lw.getComponent(s);
      if (c !== 0) {
        const f = ow.getComponent(s);
        uw.multiplyMatrices(n.bones[f].matrixWorld, n.boneInverses[f]), t.addScaledVector(vO.copy(sw).applyMatrix4(uw), c);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class oS extends xn {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class ed extends Mi {
  constructor(e = null, t = 1, n = 1, r, s, c, f, h, m = Si, g = Si, _, x) {
    super(null, c, f, h, m, g, r, s, _, x), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const cw = /* @__PURE__ */ new Qt(), gO = /* @__PURE__ */ new Qt();
class Fg {
  constructor(e = [], t = []) {
    this.uuid = va(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new Qt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Qt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, c = e.length; s < c; s++) {
      const f = e[s] ? e[s].matrixWorld : gO;
      cw.multiplyMatrices(f, t[s]), cw.toArray(n, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Fg(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = mT(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new ed(t, e, e, pa, Eo);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const s = e.bones[n];
      let c = t[s];
      c === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), c = new oS()), this.bones.push(c), this.boneInverses.push(new Qt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const c = t[r];
      e.bones.push(c.uuid);
      const f = n[r];
      e.boneInverses.push(f.toArray());
    }
    return e;
  }
}
class id extends Fn {
  constructor(e, t, n, r = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const fw = /* @__PURE__ */ new Qt(), dw = /* @__PURE__ */ new Qt(), qv = [], Vh = /* @__PURE__ */ new Qi();
class zT extends Qi {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new id(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, r = this.count;
    if (Vh.geometry = this.geometry, Vh.material = this.material, Vh.material !== void 0)
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, fw), dw.multiplyMatrices(n, fw), Vh.matrixWorld = dw, Vh.raycast(e, qv);
        for (let c = 0, f = qv.length; c < f; c++) {
          const h = qv[c];
          h.instanceId = s, h.object = this, t.push(h);
        }
        qv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new id(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Dr extends Ki {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new xt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const hw = /* @__PURE__ */ new q(), pw = /* @__PURE__ */ new q(), mw = /* @__PURE__ */ new Qt(), D_ = /* @__PURE__ */ new gp(), jv = /* @__PURE__ */ new dc();
class kl extends xn {
  constructor(e = new Kt(), t = new Dr()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let r = 1, s = t.count; r < s; r++)
        hw.fromBufferAttribute(t, r - 1), pw.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += hw.distanceTo(pw);
      e.setAttribute("lineDistance", new Rt(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, c = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), jv.copy(n.boundingSphere), jv.applyMatrix4(r), jv.radius += s, e.ray.intersectsSphere(jv) === !1)
      return;
    mw.copy(r).invert(), D_.copy(e.ray).applyMatrix4(mw);
    const f = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = f * f, m = new q(), g = new q(), _ = new q(), x = new q(), M = this.isLineSegments ? 2 : 1, b = n.index, w = n.attributes.position;
    if (b !== null) {
      const R = Math.max(0, c.start), A = Math.min(b.count, c.start + c.count);
      for (let P = R, N = A - 1; P < N; P += M) {
        const I = b.getX(P), B = b.getX(P + 1);
        if (m.fromBufferAttribute(w, I), g.fromBufferAttribute(w, B), D_.distanceSqToSegment(m, g, x, _) > h)
          continue;
        x.applyMatrix4(this.matrixWorld);
        const z = e.ray.origin.distanceTo(x);
        z < e.near || z > e.far || t.push({
          distance: z,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: _.clone().applyMatrix4(this.matrixWorld),
          index: P,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const R = Math.max(0, c.start), A = Math.min(w.count, c.start + c.count);
      for (let P = R, N = A - 1; P < N; P += M) {
        if (m.fromBufferAttribute(w, P), g.fromBufferAttribute(w, P + 1), D_.distanceSqToSegment(m, g, x, _) > h)
          continue;
        x.applyMatrix4(this.matrixWorld);
        const B = e.ray.origin.distanceTo(x);
        B < e.near || B > e.far || t.push({
          distance: B,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: _.clone().applyMatrix4(this.matrixWorld),
          index: P,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, c = r.length; s < c; s++) {
          const f = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = s;
        }
      }
    }
  }
}
const vw = /* @__PURE__ */ new q(), gw = /* @__PURE__ */ new q();
class Vs extends kl {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        vw.fromBufferAttribute(t, r), gw.fromBufferAttribute(t, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + vw.distanceTo(gw);
      e.setAttribute("lineDistance", new Rt(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class OT extends kl {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class lS extends Ki {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new xt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const yw = /* @__PURE__ */ new Qt(), Nx = /* @__PURE__ */ new gp(), Yv = /* @__PURE__ */ new dc(), Xv = /* @__PURE__ */ new q();
class IT extends xn {
  constructor(e = new Kt(), t = new lS()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, c = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Yv.copy(n.boundingSphere), Yv.applyMatrix4(r), Yv.radius += s, e.ray.intersectsSphere(Yv) === !1)
      return;
    yw.copy(r).invert(), Nx.copy(e.ray).applyMatrix4(yw);
    const f = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = f * f, m = n.index, _ = n.attributes.position;
    if (m !== null) {
      const x = Math.max(0, c.start), M = Math.min(m.count, c.start + c.count);
      for (let b = x, E = M; b < E; b++) {
        const w = m.getX(b);
        Xv.fromBufferAttribute(_, w), _w(Xv, w, h, r, e, t, this);
      }
    } else {
      const x = Math.max(0, c.start), M = Math.min(_.count, c.start + c.count);
      for (let b = x, E = M; b < E; b++)
        Xv.fromBufferAttribute(_, b), _w(Xv, b, h, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, c = r.length; s < c; s++) {
          const f = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = s;
        }
      }
    }
  }
}
function _w(u, e, t, n, r, s, c) {
  const f = Nx.distanceSqToPoint(u);
  if (f < t) {
    const h = new q();
    Nx.closestPointToPoint(u, h), h.applyMatrix4(n);
    const m = r.ray.origin.distanceTo(h);
    if (m < r.near || m > r.far)
      return;
    s.push({
      distance: m,
      distanceToRay: Math.sqrt(f),
      point: h,
      index: e,
      face: null,
      object: c
    });
  }
}
class yO extends Mi {
  constructor(e, t, n, r, s, c, f, h, m) {
    super(e, t, n, r, s, c, f, h, m), this.isVideoTexture = !0, this.minFilter = c !== void 0 ? c : vi, this.magFilter = s !== void 0 ? s : vi, this.generateMipmaps = !1;
    const g = this;
    function _() {
      g.needsUpdate = !0, e.requestVideoFrameCallback(_);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(_);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class _O extends Mi {
  constructor(e, t, n) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = Si, this.minFilter = Si, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class UT extends Mi {
  constructor(e, t, n, r, s, c, f, h, m, g, _, x) {
    super(null, c, f, h, m, g, r, s, _, x), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class xO extends Mi {
  constructor(e, t, n, r, s, c, f, h, m) {
    super(e, t, n, r, s, c, f, h, m), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class hs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let c = 1; c <= e; c++)
      n = this.getPoint(c / e), s += n.distanceTo(r), t.push(s), r = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let c;
    t ? c = t : c = e * n[s - 1];
    let f = 0, h = s - 1, m;
    for (; f <= h; )
      if (r = Math.floor(f + (h - f) / 2), m = n[r] - c, m < 0)
        f = r + 1;
      else if (m > 0)
        h = r - 1;
      else {
        h = r;
        break;
      }
    if (r = h, n[r] === c)
      return r / (s - 1);
    const g = n[r], x = n[r + 1] - g, M = (c - g) / x;
    return (r + M) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const c = this.getPoint(r), f = this.getPoint(s), h = t || (c.isVector2 ? new Ue() : new q());
    return h.copy(f).sub(c).normalize(), h;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new q(), r = [], s = [], c = [], f = new q(), h = new Qt();
    for (let M = 0; M <= e; M++) {
      const b = M / e;
      r[M] = this.getTangentAt(b, new q());
    }
    s[0] = new q(), c[0] = new q();
    let m = Number.MAX_VALUE;
    const g = Math.abs(r[0].x), _ = Math.abs(r[0].y), x = Math.abs(r[0].z);
    g <= m && (m = g, n.set(1, 0, 0)), _ <= m && (m = _, n.set(0, 1, 0)), x <= m && n.set(0, 0, 1), f.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], f), c[0].crossVectors(r[0], s[0]);
    for (let M = 1; M <= e; M++) {
      if (s[M] = s[M - 1].clone(), c[M] = c[M - 1].clone(), f.crossVectors(r[M - 1], r[M]), f.length() > Number.EPSILON) {
        f.normalize();
        const b = Math.acos(gi(r[M - 1].dot(r[M]), -1, 1));
        s[M].applyMatrix4(h.makeRotationAxis(f, b));
      }
      c[M].crossVectors(r[M], s[M]);
    }
    if (t === !0) {
      let M = Math.acos(gi(s[0].dot(s[e]), -1, 1));
      M /= e, r[0].dot(f.crossVectors(s[0], s[e])) > 0 && (M = -M);
      for (let b = 1; b <= e; b++)
        s[b].applyMatrix4(h.makeRotationAxis(r[b], M * b)), c[b].crossVectors(r[b], s[b]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: c
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Bg extends hs {
  constructor(e = 0, t = 0, n = 1, r = 1, s = 0, c = Math.PI * 2, f = !1, h = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = c, this.aClockwise = f, this.aRotation = h;
  }
  getPoint(e, t) {
    const n = t || new Ue(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const c = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (c ? s = 0 : s = r), this.aClockwise === !0 && !c && (s === r ? s = -r : s = s - r);
    const f = this.aStartAngle + e * s;
    let h = this.aX + this.xRadius * Math.cos(f), m = this.aY + this.yRadius * Math.sin(f);
    if (this.aRotation !== 0) {
      const g = Math.cos(this.aRotation), _ = Math.sin(this.aRotation), x = h - this.aX, M = m - this.aY;
      h = x * g - M * _ + this.aX, m = x * _ + M * g + this.aY;
    }
    return n.set(h, m);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class FT extends Bg {
  constructor(e, t, n, r, s, c) {
    super(e, t, n, n, r, s, c), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function uS() {
  let u = 0, e = 0, t = 0, n = 0;
  function r(s, c, f, h) {
    u = s, e = f, t = -3 * s + 3 * c - 2 * f - h, n = 2 * s - 2 * c + f + h;
  }
  return {
    initCatmullRom: function(s, c, f, h, m) {
      r(c, f, m * (f - s), m * (h - c));
    },
    initNonuniformCatmullRom: function(s, c, f, h, m, g, _) {
      let x = (c - s) / m - (f - s) / (m + g) + (f - c) / g, M = (f - c) / g - (h - c) / (g + _) + (h - f) / _;
      x *= g, M *= g, r(c, f, x, M);
    },
    calc: function(s) {
      const c = s * s, f = c * s;
      return u + e * s + t * c + n * f;
    }
  };
}
const Zv = /* @__PURE__ */ new q(), P_ = /* @__PURE__ */ new uS(), N_ = /* @__PURE__ */ new uS(), z_ = /* @__PURE__ */ new uS();
class BT extends hs {
  constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r;
  }
  getPoint(e, t = new q()) {
    const n = t, r = this.points, s = r.length, c = (s - (this.closed ? 0 : 1)) * e;
    let f = Math.floor(c), h = c - f;
    this.closed ? f += f > 0 ? 0 : (Math.floor(Math.abs(f) / s) + 1) * s : h === 0 && f === s - 1 && (f = s - 2, h = 1);
    let m, g;
    this.closed || f > 0 ? m = r[(f - 1) % s] : (Zv.subVectors(r[0], r[1]).add(r[0]), m = Zv);
    const _ = r[f % s], x = r[(f + 1) % s];
    if (this.closed || f + 2 < s ? g = r[(f + 2) % s] : (Zv.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), g = Zv), this.curveType === "centripetal" || this.curveType === "chordal") {
      const M = this.curveType === "chordal" ? 0.5 : 0.25;
      let b = Math.pow(m.distanceToSquared(_), M), E = Math.pow(_.distanceToSquared(x), M), w = Math.pow(x.distanceToSquared(g), M);
      E < 1e-4 && (E = 1), b < 1e-4 && (b = E), w < 1e-4 && (w = E), P_.initNonuniformCatmullRom(m.x, _.x, x.x, g.x, b, E, w), N_.initNonuniformCatmullRom(m.y, _.y, x.y, g.y, b, E, w), z_.initNonuniformCatmullRom(m.z, _.z, x.z, g.z, b, E, w);
    } else
      this.curveType === "catmullrom" && (P_.initCatmullRom(m.x, _.x, x.x, g.x, this.tension), N_.initCatmullRom(m.y, _.y, x.y, g.y, this.tension), z_.initCatmullRom(m.z, _.z, x.z, g.z, this.tension));
    return n.set(
      P_.calc(h),
      N_.calc(h),
      z_.calc(h)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new q().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function xw(u, e, t, n, r) {
  const s = (n - e) * 0.5, c = (r - t) * 0.5, f = u * u, h = u * f;
  return (2 * t - 2 * n + s + c) * h + (-3 * t + 3 * n - 2 * s - c) * f + s * u + t;
}
function SO(u, e) {
  const t = 1 - u;
  return t * t * e;
}
function MO(u, e) {
  return 2 * (1 - u) * u * e;
}
function bO(u, e) {
  return u * u * e;
}
function Zh(u, e, t, n) {
  return SO(u, e) + MO(u, t) + bO(u, n);
}
function wO(u, e) {
  const t = 1 - u;
  return t * t * t * e;
}
function EO(u, e) {
  const t = 1 - u;
  return 3 * t * t * u * e;
}
function TO(u, e) {
  return 3 * (1 - u) * u * u * e;
}
function CO(u, e) {
  return u * u * u * e;
}
function Jh(u, e, t, n, r) {
  return wO(u, e) + EO(u, t) + TO(u, n) + CO(u, r);
}
class cS extends hs {
  constructor(e = new Ue(), t = new Ue(), n = new Ue(), r = new Ue()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new Ue()) {
    const n = t, r = this.v0, s = this.v1, c = this.v2, f = this.v3;
    return n.set(
      Jh(e, r.x, s.x, c.x, f.x),
      Jh(e, r.y, s.y, c.y, f.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class HT extends hs {
  constructor(e = new q(), t = new q(), n = new q(), r = new q()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  getPoint(e, t = new q()) {
    const n = t, r = this.v0, s = this.v1, c = this.v2, f = this.v3;
    return n.set(
      Jh(e, r.x, s.x, c.x, f.x),
      Jh(e, r.y, s.y, c.y, f.y),
      Jh(e, r.z, s.z, c.z, f.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Hg extends hs {
  constructor(e = new Ue(), t = new Ue()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ue()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const n = t || new Ue();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class kT extends hs {
  constructor(e = new q(), t = new q()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new q()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class fS extends hs {
  constructor(e = new Ue(), t = new Ue(), n = new Ue()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new Ue()) {
    const n = t, r = this.v0, s = this.v1, c = this.v2;
    return n.set(
      Zh(e, r.x, s.x, c.x),
      Zh(e, r.y, s.y, c.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class dS extends hs {
  constructor(e = new q(), t = new q(), n = new q()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new q()) {
    const n = t, r = this.v0, s = this.v1, c = this.v2;
    return n.set(
      Zh(e, r.x, s.x, c.x),
      Zh(e, r.y, s.y, c.y),
      Zh(e, r.z, s.z, c.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class hS extends hs {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Ue()) {
    const n = t, r = this.points, s = (r.length - 1) * e, c = Math.floor(s), f = s - c, h = r[c === 0 ? c : c - 1], m = r[c], g = r[c > r.length - 2 ? r.length - 1 : c + 1], _ = r[c > r.length - 3 ? r.length - 1 : c + 2];
    return n.set(
      xw(f, h.x, m.x, g.x, _.x),
      xw(f, h.y, m.y, g.y, _.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new Ue().fromArray(r));
    }
    return this;
  }
}
var pS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: FT,
  CatmullRomCurve3: BT,
  CubicBezierCurve: cS,
  CubicBezierCurve3: HT,
  EllipseCurve: Bg,
  LineCurve: Hg,
  LineCurve3: kT,
  QuadraticBezierCurve: fS,
  QuadraticBezierCurve3: dS,
  SplineCurve: hS
});
class VT extends hs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Hg(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const c = r[s] - n, f = this.curves[s], h = f.getLength(), m = h === 0 ? 0 : 1 - c / h;
        return f.getPointAt(m, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const c = s[r], f = c.isEllipseCurve ? e * 2 : c.isLineCurve || c.isLineCurve3 ? 1 : c.isSplineCurve ? e * c.points.length : e, h = c.getPoints(f);
      for (let m = 0; m < h.length; m++) {
        const g = h[m];
        n && n.equals(g) || (t.push(g), n = g);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(new pS[r.type]().fromJSON(r));
    }
    return this;
  }
}
class op extends VT {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ue(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new Hg(this.currentPoint.clone(), new Ue(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    const s = new fS(
      this.currentPoint.clone(),
      new Ue(e, t),
      new Ue(n, r)
    );
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  bezierCurveTo(e, t, n, r, s, c) {
    const f = new cS(
      this.currentPoint.clone(),
      new Ue(e, t),
      new Ue(n, r),
      new Ue(s, c)
    );
    return this.curves.push(f), this.currentPoint.set(s, c), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new hS(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, r, s, c) {
    const f = this.currentPoint.x, h = this.currentPoint.y;
    return this.absarc(
      e + f,
      t + h,
      n,
      r,
      s,
      c
    ), this;
  }
  absarc(e, t, n, r, s, c) {
    return this.absellipse(e, t, n, n, r, s, c), this;
  }
  ellipse(e, t, n, r, s, c, f, h) {
    const m = this.currentPoint.x, g = this.currentPoint.y;
    return this.absellipse(e + m, t + g, n, r, s, c, f, h), this;
  }
  absellipse(e, t, n, r, s, c, f, h) {
    const m = new Bg(e, t, n, r, s, c, f, h);
    if (this.curves.length > 0) {
      const _ = m.getPoint(0);
      _.equals(this.currentPoint) || this.lineTo(_.x, _.y);
    }
    this.curves.push(m);
    const g = m.getPoint(1);
    return this.currentPoint.copy(g), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class ud extends Kt {
  constructor(e = [new Ue(0, -0.5), new Ue(0.5, 0), new Ue(0, 0.5)], t = 12, n = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: r
    }, t = Math.floor(t), r = gi(r, 0, Math.PI * 2);
    const s = [], c = [], f = [], h = [], m = [], g = 1 / t, _ = new q(), x = new Ue(), M = new q(), b = new q(), E = new q();
    let w = 0, R = 0;
    for (let A = 0; A <= e.length - 1; A++)
      switch (A) {
        case 0:
          w = e[A + 1].x - e[A].x, R = e[A + 1].y - e[A].y, M.x = R * 1, M.y = -w, M.z = R * 0, E.copy(M), M.normalize(), h.push(M.x, M.y, M.z);
          break;
        case e.length - 1:
          h.push(E.x, E.y, E.z);
          break;
        default:
          w = e[A + 1].x - e[A].x, R = e[A + 1].y - e[A].y, M.x = R * 1, M.y = -w, M.z = R * 0, b.copy(M), M.x += E.x, M.y += E.y, M.z += E.z, M.normalize(), h.push(M.x, M.y, M.z), E.copy(b);
      }
    for (let A = 0; A <= t; A++) {
      const P = n + A * g * r, N = Math.sin(P), I = Math.cos(P);
      for (let B = 0; B <= e.length - 1; B++) {
        _.x = e[B].x * N, _.y = e[B].y, _.z = e[B].x * I, c.push(_.x, _.y, _.z), x.x = A / t, x.y = B / (e.length - 1), f.push(x.x, x.y);
        const W = h[3 * B + 0] * N, z = h[3 * B + 1], k = h[3 * B + 0] * I;
        m.push(W, z, k);
      }
    }
    for (let A = 0; A < t; A++)
      for (let P = 0; P < e.length - 1; P++) {
        const N = P + A * e.length, I = N, B = N + e.length, W = N + e.length + 1, z = N + 1;
        s.push(I, B, z), s.push(W, z, B);
      }
    this.setIndex(s), this.setAttribute("position", new Rt(c, 3)), this.setAttribute("uv", new Rt(f, 2)), this.setAttribute("normal", new Rt(m, 3));
  }
  static fromJSON(e) {
    return new ud(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Sp extends ud {
  constructor(e = 1, t = 1, n = 4, r = 8) {
    const s = new op();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: n,
      radialSegments: r
    };
  }
  static fromJSON(e) {
    return new Sp(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Mp extends Kt {
  constructor(e = 1, t = 8, n = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: r
    }, t = Math.max(3, t);
    const s = [], c = [], f = [], h = [], m = new q(), g = new Ue();
    c.push(0, 0, 0), f.push(0, 0, 1), h.push(0.5, 0.5);
    for (let _ = 0, x = 3; _ <= t; _++, x += 3) {
      const M = n + _ / t * r;
      m.x = e * Math.cos(M), m.y = e * Math.sin(M), c.push(m.x, m.y, m.z), f.push(0, 0, 1), g.x = (c[x] / e + 1) / 2, g.y = (c[x + 1] / e + 1) / 2, h.push(g.x, g.y);
    }
    for (let _ = 1; _ <= t; _++)
      s.push(_, _ + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Rt(c, 3)), this.setAttribute("normal", new Rt(f, 3)), this.setAttribute("uv", new Rt(h, 2));
  }
  static fromJSON(e) {
    return new Mp(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class hc extends Kt {
  constructor(e = 1, t = 1, n = 1, r = 8, s = 1, c = !1, f = 0, h = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: r,
      heightSegments: s,
      openEnded: c,
      thetaStart: f,
      thetaLength: h
    };
    const m = this;
    r = Math.floor(r), s = Math.floor(s);
    const g = [], _ = [], x = [], M = [];
    let b = 0;
    const E = [], w = n / 2;
    let R = 0;
    A(), c === !1 && (e > 0 && P(!0), t > 0 && P(!1)), this.setIndex(g), this.setAttribute("position", new Rt(_, 3)), this.setAttribute("normal", new Rt(x, 3)), this.setAttribute("uv", new Rt(M, 2));
    function A() {
      const N = new q(), I = new q();
      let B = 0;
      const W = (t - e) / n;
      for (let z = 0; z <= s; z++) {
        const k = [], G = z / s, $ = G * (t - e) + e;
        for (let oe = 0; oe <= r; oe++) {
          const ne = oe / r, ee = ne * h + f, ye = Math.sin(ee), Me = Math.cos(ee);
          I.x = $ * ye, I.y = -G * n + w, I.z = $ * Me, _.push(I.x, I.y, I.z), N.set(ye, W, Me).normalize(), x.push(N.x, N.y, N.z), M.push(ne, 1 - G), k.push(b++);
        }
        E.push(k);
      }
      for (let z = 0; z < r; z++)
        for (let k = 0; k < s; k++) {
          const G = E[k][z], $ = E[k + 1][z], oe = E[k + 1][z + 1], ne = E[k][z + 1];
          g.push(G, $, ne), g.push($, oe, ne), B += 6;
        }
      m.addGroup(R, B, 0), R += B;
    }
    function P(N) {
      const I = b, B = new Ue(), W = new q();
      let z = 0;
      const k = N === !0 ? e : t, G = N === !0 ? 1 : -1;
      for (let oe = 1; oe <= r; oe++)
        _.push(0, w * G, 0), x.push(0, G, 0), M.push(0.5, 0.5), b++;
      const $ = b;
      for (let oe = 0; oe <= r; oe++) {
        const ee = oe / r * h + f, ye = Math.cos(ee), Me = Math.sin(ee);
        W.x = k * Me, W.y = w * G, W.z = k * ye, _.push(W.x, W.y, W.z), x.push(0, G, 0), B.x = ye * 0.5 + 0.5, B.y = Me * 0.5 * G + 0.5, M.push(B.x, B.y), b++;
      }
      for (let oe = 0; oe < r; oe++) {
        const ne = I + oe, ee = $ + oe;
        N === !0 ? g.push(ee, ee + 1, ne) : g.push(ee + 1, ee, ne), z += 3;
      }
      m.addGroup(R, z, N === !0 ? 1 : 2), R += z;
    }
  }
  static fromJSON(e) {
    return new hc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class bp extends hc {
  constructor(e = 1, t = 1, n = 8, r = 1, s = !1, c = 0, f = Math.PI * 2) {
    super(0, e, t, n, r, s, c, f), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: r,
      openEnded: s,
      thetaStart: c,
      thetaLength: f
    };
  }
  static fromJSON(e) {
    return new bp(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Lo extends Kt {
  constructor(e = [], t = [], n = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: r
    };
    const s = [], c = [];
    f(r), m(n), g(), this.setAttribute("position", new Rt(s, 3)), this.setAttribute("normal", new Rt(s.slice(), 3)), this.setAttribute("uv", new Rt(c, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function f(A) {
      const P = new q(), N = new q(), I = new q();
      for (let B = 0; B < t.length; B += 3)
        M(t[B + 0], P), M(t[B + 1], N), M(t[B + 2], I), h(P, N, I, A);
    }
    function h(A, P, N, I) {
      const B = I + 1, W = [];
      for (let z = 0; z <= B; z++) {
        W[z] = [];
        const k = A.clone().lerp(N, z / B), G = P.clone().lerp(N, z / B), $ = B - z;
        for (let oe = 0; oe <= $; oe++)
          oe === 0 && z === B ? W[z][oe] = k : W[z][oe] = k.clone().lerp(G, oe / $);
      }
      for (let z = 0; z < B; z++)
        for (let k = 0; k < 2 * (B - z) - 1; k++) {
          const G = Math.floor(k / 2);
          k % 2 === 0 ? (x(W[z][G + 1]), x(W[z + 1][G]), x(W[z][G])) : (x(W[z][G + 1]), x(W[z + 1][G + 1]), x(W[z + 1][G]));
        }
    }
    function m(A) {
      const P = new q();
      for (let N = 0; N < s.length; N += 3)
        P.x = s[N + 0], P.y = s[N + 1], P.z = s[N + 2], P.normalize().multiplyScalar(A), s[N + 0] = P.x, s[N + 1] = P.y, s[N + 2] = P.z;
    }
    function g() {
      const A = new q();
      for (let P = 0; P < s.length; P += 3) {
        A.x = s[P + 0], A.y = s[P + 1], A.z = s[P + 2];
        const N = w(A) / 2 / Math.PI + 0.5, I = R(A) / Math.PI + 0.5;
        c.push(N, 1 - I);
      }
      b(), _();
    }
    function _() {
      for (let A = 0; A < c.length; A += 6) {
        const P = c[A + 0], N = c[A + 2], I = c[A + 4], B = Math.max(P, N, I), W = Math.min(P, N, I);
        B > 0.9 && W < 0.1 && (P < 0.2 && (c[A + 0] += 1), N < 0.2 && (c[A + 2] += 1), I < 0.2 && (c[A + 4] += 1));
      }
    }
    function x(A) {
      s.push(A.x, A.y, A.z);
    }
    function M(A, P) {
      const N = A * 3;
      P.x = e[N + 0], P.y = e[N + 1], P.z = e[N + 2];
    }
    function b() {
      const A = new q(), P = new q(), N = new q(), I = new q(), B = new Ue(), W = new Ue(), z = new Ue();
      for (let k = 0, G = 0; k < s.length; k += 9, G += 6) {
        A.set(s[k + 0], s[k + 1], s[k + 2]), P.set(s[k + 3], s[k + 4], s[k + 5]), N.set(s[k + 6], s[k + 7], s[k + 8]), B.set(c[G + 0], c[G + 1]), W.set(c[G + 2], c[G + 3]), z.set(c[G + 4], c[G + 5]), I.copy(A).add(P).add(N).divideScalar(3);
        const $ = w(I);
        E(B, G + 0, A, $), E(W, G + 2, P, $), E(z, G + 4, N, $);
      }
    }
    function E(A, P, N, I) {
      I < 0 && A.x === 1 && (c[P] = A.x - 1), N.x === 0 && N.z === 0 && (c[P] = I / 2 / Math.PI + 0.5);
    }
    function w(A) {
      return Math.atan2(A.z, -A.x);
    }
    function R(A) {
      return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z));
    }
  }
  static fromJSON(e) {
    return new Lo(e.vertices, e.indices, e.radius, e.details);
  }
}
class wp extends Lo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = 1 / n, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      // (1/, , 0)
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -r,
      n,
      0,
      -r,
      -n,
      0,
      r,
      n,
      0,
      r
    ], c = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, c, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new wp(e.radius, e.detail);
  }
}
const Jv = /* @__PURE__ */ new q(), Qv = /* @__PURE__ */ new q(), O_ = /* @__PURE__ */ new q(), Kv = /* @__PURE__ */ new Ga();
class GT extends Kt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(nc * t), c = e.getIndex(), f = e.getAttribute("position"), h = c ? c.count : f.count, m = [0, 0, 0], g = ["a", "b", "c"], _ = new Array(3), x = {}, M = [];
      for (let b = 0; b < h; b += 3) {
        c ? (m[0] = c.getX(b), m[1] = c.getX(b + 1), m[2] = c.getX(b + 2)) : (m[0] = b, m[1] = b + 1, m[2] = b + 2);
        const { a: E, b: w, c: R } = Kv;
        if (E.fromBufferAttribute(f, m[0]), w.fromBufferAttribute(f, m[1]), R.fromBufferAttribute(f, m[2]), Kv.getNormal(O_), _[0] = `${Math.round(E.x * r)},${Math.round(E.y * r)},${Math.round(E.z * r)}`, _[1] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`, _[2] = `${Math.round(R.x * r)},${Math.round(R.y * r)},${Math.round(R.z * r)}`, !(_[0] === _[1] || _[1] === _[2] || _[2] === _[0]))
          for (let A = 0; A < 3; A++) {
            const P = (A + 1) % 3, N = _[A], I = _[P], B = Kv[g[A]], W = Kv[g[P]], z = `${N}_${I}`, k = `${I}_${N}`;
            k in x && x[k] ? (O_.dot(x[k].normal) <= s && (M.push(B.x, B.y, B.z), M.push(W.x, W.y, W.z)), x[k] = null) : z in x || (x[z] = {
              index0: m[A],
              index1: m[P],
              normal: O_.clone()
            });
          }
      }
      for (const b in x)
        if (x[b]) {
          const { index0: E, index1: w } = x[b];
          Jv.fromBufferAttribute(f, E), Qv.fromBufferAttribute(f, w), M.push(Jv.x, Jv.y, Jv.z), M.push(Qv.x, Qv.y, Qv.z);
        }
      this.setAttribute("position", new Rt(M, 3));
    }
  }
}
class ac extends op {
  constructor(e) {
    super(e), this.uuid = va(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(new op().fromJSON(r));
    }
    return this;
  }
}
const RO = {
  triangulate: function(u, e, t = 2) {
    const n = e && e.length, r = n ? e[0] * t : u.length;
    let s = WT(u, 0, r, t, !0);
    const c = [];
    if (!s || s.next === s.prev)
      return c;
    let f, h, m, g, _, x, M;
    if (n && (s = NO(u, e, s, t)), u.length > 80 * t) {
      f = m = u[0], h = g = u[1];
      for (let b = t; b < r; b += t)
        _ = u[b], x = u[b + 1], _ < f && (f = _), x < h && (h = x), _ > m && (m = _), x > g && (g = x);
      M = Math.max(m - f, g - h), M = M !== 0 ? 1 / M : 0;
    }
    return lp(s, c, t, f, h, M), c;
  }
};
function WT(u, e, t, n, r) {
  let s, c;
  if (r === WO(u, e, t, n) > 0)
    for (s = e; s < t; s += n)
      c = Sw(s, u[s], u[s + 1], c);
  else
    for (s = t - n; s >= e; s -= n)
      c = Sw(s, u[s], u[s + 1], c);
  return c && kg(c, c.next) && (cp(c), c = c.next), c;
}
function Vl(u, e) {
  if (!u)
    return u;
  e || (e = u);
  let t = u, n;
  do
    if (n = !1, !t.steiner && (kg(t, t.next) || ni(t.prev, t, t.next) === 0)) {
      if (cp(t), t = e = t.prev, t === t.next)
        break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function lp(u, e, t, n, r, s, c) {
  if (!u)
    return;
  !c && s && FO(u, n, r, s);
  let f = u, h, m;
  for (; u.prev !== u.next; ) {
    if (h = u.prev, m = u.next, s ? LO(u, n, r, s) : AO(u)) {
      e.push(h.i / t), e.push(u.i / t), e.push(m.i / t), cp(u), u = m.next, f = m.next;
      continue;
    }
    if (u = m, u === f) {
      c ? c === 1 ? (u = DO(Vl(u), e, t), lp(u, e, t, n, r, s, 2)) : c === 2 && PO(u, e, t, n, r, s) : lp(Vl(u), e, t, n, r, s, 1);
      break;
    }
  }
}
function AO(u) {
  const e = u.prev, t = u, n = u.next;
  if (ni(e, t, n) >= 0)
    return !1;
  let r = u.next.next;
  for (; r !== u.prev; ) {
    if (Kf(e.x, e.y, t.x, t.y, n.x, n.y, r.x, r.y) && ni(r.prev, r, r.next) >= 0)
      return !1;
    r = r.next;
  }
  return !0;
}
function LO(u, e, t, n) {
  const r = u.prev, s = u, c = u.next;
  if (ni(r, s, c) >= 0)
    return !1;
  const f = r.x < s.x ? r.x < c.x ? r.x : c.x : s.x < c.x ? s.x : c.x, h = r.y < s.y ? r.y < c.y ? r.y : c.y : s.y < c.y ? s.y : c.y, m = r.x > s.x ? r.x > c.x ? r.x : c.x : s.x > c.x ? s.x : c.x, g = r.y > s.y ? r.y > c.y ? r.y : c.y : s.y > c.y ? s.y : c.y, _ = zx(f, h, e, t, n), x = zx(m, g, e, t, n);
  let M = u.prevZ, b = u.nextZ;
  for (; M && M.z >= _ && b && b.z <= x; ) {
    if (M !== u.prev && M !== u.next && Kf(r.x, r.y, s.x, s.y, c.x, c.y, M.x, M.y) && ni(M.prev, M, M.next) >= 0 || (M = M.prevZ, b !== u.prev && b !== u.next && Kf(r.x, r.y, s.x, s.y, c.x, c.y, b.x, b.y) && ni(b.prev, b, b.next) >= 0))
      return !1;
    b = b.nextZ;
  }
  for (; M && M.z >= _; ) {
    if (M !== u.prev && M !== u.next && Kf(r.x, r.y, s.x, s.y, c.x, c.y, M.x, M.y) && ni(M.prev, M, M.next) >= 0)
      return !1;
    M = M.prevZ;
  }
  for (; b && b.z <= x; ) {
    if (b !== u.prev && b !== u.next && Kf(r.x, r.y, s.x, s.y, c.x, c.y, b.x, b.y) && ni(b.prev, b, b.next) >= 0)
      return !1;
    b = b.nextZ;
  }
  return !0;
}
function DO(u, e, t) {
  let n = u;
  do {
    const r = n.prev, s = n.next.next;
    !kg(r, s) && qT(r, n, n.next, s) && up(r, s) && up(s, r) && (e.push(r.i / t), e.push(n.i / t), e.push(s.i / t), cp(n), cp(n.next), n = u = s), n = n.next;
  } while (n !== u);
  return Vl(n);
}
function PO(u, e, t, n, r, s) {
  let c = u;
  do {
    let f = c.next.next;
    for (; f !== c.prev; ) {
      if (c.i !== f.i && kO(c, f)) {
        let h = jT(c, f);
        c = Vl(c, c.next), h = Vl(h, h.next), lp(c, e, t, n, r, s), lp(h, e, t, n, r, s);
        return;
      }
      f = f.next;
    }
    c = c.next;
  } while (c !== u);
}
function NO(u, e, t, n) {
  const r = [];
  let s, c, f, h, m;
  for (s = 0, c = e.length; s < c; s++)
    f = e[s] * n, h = s < c - 1 ? e[s + 1] * n : u.length, m = WT(u, f, h, n, !1), m === m.next && (m.steiner = !0), r.push(HO(m));
  for (r.sort(zO), s = 0; s < r.length; s++)
    OO(r[s], t), t = Vl(t, t.next);
  return t;
}
function zO(u, e) {
  return u.x - e.x;
}
function OO(u, e) {
  if (e = IO(u, e), e) {
    const t = jT(e, u);
    Vl(e, e.next), Vl(t, t.next);
  }
}
function IO(u, e) {
  let t = e;
  const n = u.x, r = u.y;
  let s = -1 / 0, c;
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const x = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (x <= n && x > s) {
        if (s = x, x === n) {
          if (r === t.y)
            return t;
          if (r === t.next.y)
            return t.next;
        }
        c = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!c)
    return null;
  if (n === s)
    return c;
  const f = c, h = c.x, m = c.y;
  let g = 1 / 0, _;
  t = c;
  do
    n >= t.x && t.x >= h && n !== t.x && Kf(r < m ? n : s, r, h, m, r < m ? s : n, r, t.x, t.y) && (_ = Math.abs(r - t.y) / (n - t.x), up(t, u) && (_ < g || _ === g && (t.x > c.x || t.x === c.x && UO(c, t))) && (c = t, g = _)), t = t.next;
  while (t !== f);
  return c;
}
function UO(u, e) {
  return ni(u.prev, u, e.prev) < 0 && ni(e.next, u, u.next) < 0;
}
function FO(u, e, t, n) {
  let r = u;
  do
    r.z === null && (r.z = zx(r.x, r.y, e, t, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== u);
  r.prevZ.nextZ = null, r.prevZ = null, BO(r);
}
function BO(u) {
  let e, t, n, r, s, c, f, h, m = 1;
  do {
    for (t = u, u = null, s = null, c = 0; t; ) {
      for (c++, n = t, f = 0, e = 0; e < m && (f++, n = n.nextZ, !!n); e++)
        ;
      for (h = m; f > 0 || h > 0 && n; )
        f !== 0 && (h === 0 || !n || t.z <= n.z) ? (r = t, t = t.nextZ, f--) : (r = n, n = n.nextZ, h--), s ? s.nextZ = r : u = r, r.prevZ = s, s = r;
      t = n;
    }
    s.nextZ = null, m *= 2;
  } while (c > 1);
  return u;
}
function zx(u, e, t, n, r) {
  return u = 32767 * (u - t) * r, e = 32767 * (e - n) * r, u = (u | u << 8) & 16711935, u = (u | u << 4) & 252645135, u = (u | u << 2) & 858993459, u = (u | u << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, u | e << 1;
}
function HO(u) {
  let e = u, t = u;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== u);
  return t;
}
function Kf(u, e, t, n, r, s, c, f) {
  return (r - c) * (e - f) - (u - c) * (s - f) >= 0 && (u - c) * (n - f) - (t - c) * (e - f) >= 0 && (t - c) * (s - f) - (r - c) * (n - f) >= 0;
}
function kO(u, e) {
  return u.next.i !== e.i && u.prev.i !== e.i && !VO(u, e) && // doesn't intersect other edges
  (up(u, e) && up(e, u) && GO(u, e) && // locally visible
  (ni(u.prev, u, e.prev) || ni(u, e.prev, e)) || // does not create opposite-facing sectors
  kg(u, e) && ni(u.prev, u, u.next) > 0 && ni(e.prev, e, e.next) > 0);
}
function ni(u, e, t) {
  return (e.y - u.y) * (t.x - e.x) - (e.x - u.x) * (t.y - e.y);
}
function kg(u, e) {
  return u.x === e.x && u.y === e.y;
}
function qT(u, e, t, n) {
  const r = eg(ni(u, e, t)), s = eg(ni(u, e, n)), c = eg(ni(t, n, u)), f = eg(ni(t, n, e));
  return !!(r !== s && c !== f || r === 0 && $v(u, t, e) || s === 0 && $v(u, n, e) || c === 0 && $v(t, u, n) || f === 0 && $v(t, e, n));
}
function $v(u, e, t) {
  return e.x <= Math.max(u.x, t.x) && e.x >= Math.min(u.x, t.x) && e.y <= Math.max(u.y, t.y) && e.y >= Math.min(u.y, t.y);
}
function eg(u) {
  return u > 0 ? 1 : u < 0 ? -1 : 0;
}
function VO(u, e) {
  let t = u;
  do {
    if (t.i !== u.i && t.next.i !== u.i && t.i !== e.i && t.next.i !== e.i && qT(t, t.next, u, e))
      return !0;
    t = t.next;
  } while (t !== u);
  return !1;
}
function up(u, e) {
  return ni(u.prev, u, u.next) < 0 ? ni(u, e, u.next) >= 0 && ni(u, u.prev, e) >= 0 : ni(u, e, u.prev) < 0 || ni(u, u.next, e) < 0;
}
function GO(u, e) {
  let t = u, n = !1;
  const r = (u.x + e.x) / 2, s = (u.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== u);
  return n;
}
function jT(u, e) {
  const t = new Ox(u.i, u.x, u.y), n = new Ox(e.i, e.x, e.y), r = u.next, s = e.prev;
  return u.next = e, e.prev = u, t.next = r, r.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
}
function Sw(u, e, t, n) {
  const r = new Ox(u, e, t);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function cp(u) {
  u.next.prev = u.prev, u.prev.next = u.next, u.prevZ && (u.prevZ.nextZ = u.nextZ), u.nextZ && (u.nextZ.prevZ = u.prevZ);
}
function Ox(u, e, t) {
  this.i = u, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function WO(u, e, t, n) {
  let r = 0;
  for (let s = e, c = t - n; s < t; s += n)
    r += (u[c] - u[s]) * (u[s + 1] + u[c + 1]), c = s;
  return r;
}
class Bs {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      n += e[r].x * e[s].y - e[s].x * e[r].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return Bs.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], r = [], s = [];
    Mw(e), bw(n, e);
    let c = e.length;
    t.forEach(Mw);
    for (let h = 0; h < t.length; h++)
      r.push(c), c += t[h].length, bw(n, t[h]);
    const f = RO.triangulate(n, r);
    for (let h = 0; h < f.length; h += 3)
      s.push(f.slice(h, h + 3));
    return s;
  }
}
function Mw(u) {
  const e = u.length;
  e > 2 && u[e - 1].equals(u[0]) && u.pop();
}
function bw(u, e) {
  for (let t = 0; t < e.length; t++)
    u.push(e[t].x), u.push(e[t].y);
}
class Ep extends Kt {
  constructor(e = new ac([new Ue(0.5, 0.5), new Ue(-0.5, 0.5), new Ue(-0.5, -0.5), new Ue(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, r = [], s = [];
    for (let f = 0, h = e.length; f < h; f++) {
      const m = e[f];
      c(m);
    }
    this.setAttribute("position", new Rt(r, 3)), this.setAttribute("uv", new Rt(s, 2)), this.computeVertexNormals();
    function c(f) {
      const h = [], m = t.curveSegments !== void 0 ? t.curveSegments : 12, g = t.steps !== void 0 ? t.steps : 1, _ = t.depth !== void 0 ? t.depth : 1;
      let x = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, M = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, b = t.bevelSize !== void 0 ? t.bevelSize : M - 0.1, E = t.bevelOffset !== void 0 ? t.bevelOffset : 0, w = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const R = t.extrudePath, A = t.UVGenerator !== void 0 ? t.UVGenerator : qO;
      let P, N = !1, I, B, W, z;
      R && (P = R.getSpacedPoints(g), N = !0, x = !1, I = R.computeFrenetFrames(g, !1), B = new q(), W = new q(), z = new q()), x || (w = 0, M = 0, b = 0, E = 0);
      const k = f.extractPoints(m);
      let G = k.shape;
      const $ = k.holes;
      if (!Bs.isClockWise(G)) {
        G = G.reverse();
        for (let Ne = 0, we = $.length; Ne < we; Ne++) {
          const ke = $[Ne];
          Bs.isClockWise(ke) && ($[Ne] = ke.reverse());
        }
      }
      const ne = Bs.triangulateShape(G, $), ee = G;
      for (let Ne = 0, we = $.length; Ne < we; Ne++) {
        const ke = $[Ne];
        G = G.concat(ke);
      }
      function ye(Ne, we, ke) {
        return we || console.error("THREE.ExtrudeGeometry: vec does not exist"), we.clone().multiplyScalar(ke).add(Ne);
      }
      const Me = G.length, De = ne.length;
      function V(Ne, we, ke) {
        let rt, Xe, wt;
        const St = Ne.x - we.x, pt = Ne.y - we.y, kt = ke.x - Ne.x, Gt = ke.y - Ne.y, X = St * St + pt * pt, H = St * Gt - pt * kt;
        if (Math.abs(H) > Number.EPSILON) {
          const be = Math.sqrt(X), qe = Math.sqrt(kt * kt + Gt * Gt), Ye = we.x - pt / be, Ke = we.y + St / be, Et = ke.x - Gt / qe, te = ke.y + kt / qe, he = ((Et - Ye) * Gt - (te - Ke) * kt) / (St * Gt - pt * kt);
          rt = Ye + St * he - Ne.x, Xe = Ke + pt * he - Ne.y;
          const ae = rt * rt + Xe * Xe;
          if (ae <= 2)
            return new Ue(rt, Xe);
          wt = Math.sqrt(ae / 2);
        } else {
          let be = !1;
          St > Number.EPSILON ? kt > Number.EPSILON && (be = !0) : St < -Number.EPSILON ? kt < -Number.EPSILON && (be = !0) : Math.sign(pt) === Math.sign(Gt) && (be = !0), be ? (rt = -pt, Xe = St, wt = Math.sqrt(X)) : (rt = St, Xe = pt, wt = Math.sqrt(X / 2));
        }
        return new Ue(rt / wt, Xe / wt);
      }
      const J = [];
      for (let Ne = 0, we = ee.length, ke = we - 1, rt = Ne + 1; Ne < we; Ne++, ke++, rt++)
        ke === we && (ke = 0), rt === we && (rt = 0), J[Ne] = V(ee[Ne], ee[ke], ee[rt]);
      const Y = [];
      let de, le = J.concat();
      for (let Ne = 0, we = $.length; Ne < we; Ne++) {
        const ke = $[Ne];
        de = [];
        for (let rt = 0, Xe = ke.length, wt = Xe - 1, St = rt + 1; rt < Xe; rt++, wt++, St++)
          wt === Xe && (wt = 0), St === Xe && (St = 0), de[rt] = V(ke[rt], ke[wt], ke[St]);
        Y.push(de), le = le.concat(de);
      }
      for (let Ne = 0; Ne < w; Ne++) {
        const we = Ne / w, ke = M * Math.cos(we * Math.PI / 2), rt = b * Math.sin(we * Math.PI / 2) + E;
        for (let Xe = 0, wt = ee.length; Xe < wt; Xe++) {
          const St = ye(ee[Xe], J[Xe], rt);
          gt(St.x, St.y, -ke);
        }
        for (let Xe = 0, wt = $.length; Xe < wt; Xe++) {
          const St = $[Xe];
          de = Y[Xe];
          for (let pt = 0, kt = St.length; pt < kt; pt++) {
            const Gt = ye(St[pt], de[pt], rt);
            gt(Gt.x, Gt.y, -ke);
          }
        }
      }
      const Pe = b + E;
      for (let Ne = 0; Ne < Me; Ne++) {
        const we = x ? ye(G[Ne], le[Ne], Pe) : G[Ne];
        N ? (W.copy(I.normals[0]).multiplyScalar(we.x), B.copy(I.binormals[0]).multiplyScalar(we.y), z.copy(P[0]).add(W).add(B), gt(z.x, z.y, z.z)) : gt(we.x, we.y, 0);
      }
      for (let Ne = 1; Ne <= g; Ne++)
        for (let we = 0; we < Me; we++) {
          const ke = x ? ye(G[we], le[we], Pe) : G[we];
          N ? (W.copy(I.normals[Ne]).multiplyScalar(ke.x), B.copy(I.binormals[Ne]).multiplyScalar(ke.y), z.copy(P[Ne]).add(W).add(B), gt(z.x, z.y, z.z)) : gt(ke.x, ke.y, _ / g * Ne);
        }
      for (let Ne = w - 1; Ne >= 0; Ne--) {
        const we = Ne / w, ke = M * Math.cos(we * Math.PI / 2), rt = b * Math.sin(we * Math.PI / 2) + E;
        for (let Xe = 0, wt = ee.length; Xe < wt; Xe++) {
          const St = ye(ee[Xe], J[Xe], rt);
          gt(St.x, St.y, _ + ke);
        }
        for (let Xe = 0, wt = $.length; Xe < wt; Xe++) {
          const St = $[Xe];
          de = Y[Xe];
          for (let pt = 0, kt = St.length; pt < kt; pt++) {
            const Gt = ye(St[pt], de[pt], rt);
            N ? gt(Gt.x, Gt.y + P[g - 1].y, P[g - 1].x + ke) : gt(Gt.x, Gt.y, _ + ke);
          }
        }
      }
      We(), $e();
      function We() {
        const Ne = r.length / 3;
        if (x) {
          let we = 0, ke = Me * we;
          for (let rt = 0; rt < De; rt++) {
            const Xe = ne[rt];
            ot(Xe[2] + ke, Xe[1] + ke, Xe[0] + ke);
          }
          we = g + w * 2, ke = Me * we;
          for (let rt = 0; rt < De; rt++) {
            const Xe = ne[rt];
            ot(Xe[0] + ke, Xe[1] + ke, Xe[2] + ke);
          }
        } else {
          for (let we = 0; we < De; we++) {
            const ke = ne[we];
            ot(ke[2], ke[1], ke[0]);
          }
          for (let we = 0; we < De; we++) {
            const ke = ne[we];
            ot(ke[0] + Me * g, ke[1] + Me * g, ke[2] + Me * g);
          }
        }
        n.addGroup(Ne, r.length / 3 - Ne, 0);
      }
      function $e() {
        const Ne = r.length / 3;
        let we = 0;
        ve(ee, we), we += ee.length;
        for (let ke = 0, rt = $.length; ke < rt; ke++) {
          const Xe = $[ke];
          ve(Xe, we), we += Xe.length;
        }
        n.addGroup(Ne, r.length / 3 - Ne, 1);
      }
      function ve(Ne, we) {
        let ke = Ne.length;
        for (; --ke >= 0; ) {
          const rt = ke;
          let Xe = ke - 1;
          Xe < 0 && (Xe = Ne.length - 1);
          for (let wt = 0, St = g + w * 2; wt < St; wt++) {
            const pt = Me * wt, kt = Me * (wt + 1), Gt = we + rt + pt, X = we + Xe + pt, H = we + Xe + kt, be = we + rt + kt;
            _t(Gt, X, H, be);
          }
        }
      }
      function gt(Ne, we, ke) {
        h.push(Ne), h.push(we), h.push(ke);
      }
      function ot(Ne, we, ke) {
        Qe(Ne), Qe(we), Qe(ke);
        const rt = r.length / 3, Xe = A.generateTopUV(n, r, rt - 3, rt - 2, rt - 1);
        At(Xe[0]), At(Xe[1]), At(Xe[2]);
      }
      function _t(Ne, we, ke, rt) {
        Qe(Ne), Qe(we), Qe(rt), Qe(we), Qe(ke), Qe(rt);
        const Xe = r.length / 3, wt = A.generateSideWallUV(n, r, Xe - 6, Xe - 3, Xe - 2, Xe - 1);
        At(wt[0]), At(wt[1]), At(wt[3]), At(wt[1]), At(wt[2]), At(wt[3]);
      }
      function Qe(Ne) {
        r.push(h[Ne * 3 + 0]), r.push(h[Ne * 3 + 1]), r.push(h[Ne * 3 + 2]);
      }
      function At(Ne) {
        s.push(Ne.x), s.push(Ne.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return jO(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, c = e.shapes.length; s < c; s++) {
      const f = t[e.shapes[s]];
      n.push(f);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new pS[r.type]().fromJSON(r)), new Ep(n, e.options);
  }
}
const qO = {
  generateTopUV: function(u, e, t, n, r) {
    const s = e[t * 3], c = e[t * 3 + 1], f = e[n * 3], h = e[n * 3 + 1], m = e[r * 3], g = e[r * 3 + 1];
    return [
      new Ue(s, c),
      new Ue(f, h),
      new Ue(m, g)
    ];
  },
  generateSideWallUV: function(u, e, t, n, r, s) {
    const c = e[t * 3], f = e[t * 3 + 1], h = e[t * 3 + 2], m = e[n * 3], g = e[n * 3 + 1], _ = e[n * 3 + 2], x = e[r * 3], M = e[r * 3 + 1], b = e[r * 3 + 2], E = e[s * 3], w = e[s * 3 + 1], R = e[s * 3 + 2];
    return Math.abs(f - g) < Math.abs(c - m) ? [
      new Ue(c, 1 - h),
      new Ue(m, 1 - _),
      new Ue(x, 1 - b),
      new Ue(E, 1 - R)
    ] : [
      new Ue(f, 1 - h),
      new Ue(g, 1 - _),
      new Ue(M, 1 - b),
      new Ue(w, 1 - R)
    ];
  }
};
function jO(u, e, t) {
  if (t.shapes = [], Array.isArray(u))
    for (let n = 0, r = u.length; n < r; n++) {
      const s = u[n];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(u.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Tp extends Lo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Tp(e.radius, e.detail);
  }
}
class cd extends Lo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new cd(e.radius, e.detail);
  }
}
class Cp extends Kt {
  constructor(e = 0.5, t = 1, n = 8, r = 1, s = 0, c = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: r,
      thetaStart: s,
      thetaLength: c
    }, n = Math.max(3, n), r = Math.max(1, r);
    const f = [], h = [], m = [], g = [];
    let _ = e;
    const x = (t - e) / r, M = new q(), b = new Ue();
    for (let E = 0; E <= r; E++) {
      for (let w = 0; w <= n; w++) {
        const R = s + w / n * c;
        M.x = _ * Math.cos(R), M.y = _ * Math.sin(R), h.push(M.x, M.y, M.z), m.push(0, 0, 1), b.x = (M.x / t + 1) / 2, b.y = (M.y / t + 1) / 2, g.push(b.x, b.y);
      }
      _ += x;
    }
    for (let E = 0; E < r; E++) {
      const w = E * (n + 1);
      for (let R = 0; R < n; R++) {
        const A = R + w, P = A, N = A + n + 1, I = A + n + 2, B = A + 1;
        f.push(P, N, B), f.push(N, I, B);
      }
    }
    this.setIndex(f), this.setAttribute("position", new Rt(h, 3)), this.setAttribute("normal", new Rt(m, 3)), this.setAttribute("uv", new Rt(g, 2));
  }
  static fromJSON(e) {
    return new Cp(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Rp extends Kt {
  constructor(e = new ac([new Ue(0, 0.5), new Ue(-0.5, -0.5), new Ue(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], r = [], s = [], c = [];
    let f = 0, h = 0;
    if (Array.isArray(e) === !1)
      m(e);
    else
      for (let g = 0; g < e.length; g++)
        m(e[g]), this.addGroup(f, h, g), f += h, h = 0;
    this.setIndex(n), this.setAttribute("position", new Rt(r, 3)), this.setAttribute("normal", new Rt(s, 3)), this.setAttribute("uv", new Rt(c, 2));
    function m(g) {
      const _ = r.length / 3, x = g.extractPoints(t);
      let M = x.shape;
      const b = x.holes;
      Bs.isClockWise(M) === !1 && (M = M.reverse());
      for (let w = 0, R = b.length; w < R; w++) {
        const A = b[w];
        Bs.isClockWise(A) === !0 && (b[w] = A.reverse());
      }
      const E = Bs.triangulateShape(M, b);
      for (let w = 0, R = b.length; w < R; w++) {
        const A = b[w];
        M = M.concat(A);
      }
      for (let w = 0, R = M.length; w < R; w++) {
        const A = M[w];
        r.push(A.x, A.y, 0), s.push(0, 0, 1), c.push(A.x, A.y);
      }
      for (let w = 0, R = E.length; w < R; w++) {
        const A = E[w], P = A[0] + _, N = A[1] + _, I = A[2] + _;
        n.push(P, N, I), h += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return YO(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const c = t[e.shapes[r]];
      n.push(c);
    }
    return new Rp(n, e.curveSegments);
  }
}
function YO(u, e) {
  if (e.shapes = [], Array.isArray(u))
    for (let t = 0, n = u.length; t < n; t++) {
      const r = u[t];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(u.uuid);
  return e;
}
class fd extends Kt {
  constructor(e = 1, t = 32, n = 16, r = 0, s = Math.PI * 2, c = 0, f = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: r,
      phiLength: s,
      thetaStart: c,
      thetaLength: f
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const h = Math.min(c + f, Math.PI);
    let m = 0;
    const g = [], _ = new q(), x = new q(), M = [], b = [], E = [], w = [];
    for (let R = 0; R <= n; R++) {
      const A = [], P = R / n;
      let N = 0;
      R == 0 && c == 0 ? N = 0.5 / t : R == n && h == Math.PI && (N = -0.5 / t);
      for (let I = 0; I <= t; I++) {
        const B = I / t;
        _.x = -e * Math.cos(r + B * s) * Math.sin(c + P * f), _.y = e * Math.cos(c + P * f), _.z = e * Math.sin(r + B * s) * Math.sin(c + P * f), b.push(_.x, _.y, _.z), x.copy(_).normalize(), E.push(x.x, x.y, x.z), w.push(B + N, 1 - P), A.push(m++);
      }
      g.push(A);
    }
    for (let R = 0; R < n; R++)
      for (let A = 0; A < t; A++) {
        const P = g[R][A + 1], N = g[R][A], I = g[R + 1][A], B = g[R + 1][A + 1];
        (R !== 0 || c > 0) && M.push(P, N, B), (R !== n - 1 || h < Math.PI) && M.push(N, I, B);
      }
    this.setIndex(M), this.setAttribute("position", new Rt(b, 3)), this.setAttribute("normal", new Rt(E, 3)), this.setAttribute("uv", new Rt(w, 2));
  }
  static fromJSON(e) {
    return new fd(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Ap extends Lo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Ap(e.radius, e.detail);
  }
}
class Lp extends Kt {
  constructor(e = 1, t = 0.4, n = 8, r = 6, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: r,
      arc: s
    }, n = Math.floor(n), r = Math.floor(r);
    const c = [], f = [], h = [], m = [], g = new q(), _ = new q(), x = new q();
    for (let M = 0; M <= n; M++)
      for (let b = 0; b <= r; b++) {
        const E = b / r * s, w = M / n * Math.PI * 2;
        _.x = (e + t * Math.cos(w)) * Math.cos(E), _.y = (e + t * Math.cos(w)) * Math.sin(E), _.z = t * Math.sin(w), f.push(_.x, _.y, _.z), g.x = e * Math.cos(E), g.y = e * Math.sin(E), x.subVectors(_, g).normalize(), h.push(x.x, x.y, x.z), m.push(b / r), m.push(M / n);
      }
    for (let M = 1; M <= n; M++)
      for (let b = 1; b <= r; b++) {
        const E = (r + 1) * M + b - 1, w = (r + 1) * (M - 1) + b - 1, R = (r + 1) * (M - 1) + b, A = (r + 1) * M + b;
        c.push(E, w, A), c.push(w, R, A);
      }
    this.setIndex(c), this.setAttribute("position", new Rt(f, 3)), this.setAttribute("normal", new Rt(h, 3)), this.setAttribute("uv", new Rt(m, 2));
  }
  static fromJSON(e) {
    return new Lp(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Dp extends Kt {
  constructor(e = 1, t = 0.4, n = 64, r = 8, s = 2, c = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: r,
      p: s,
      q: c
    }, n = Math.floor(n), r = Math.floor(r);
    const f = [], h = [], m = [], g = [], _ = new q(), x = new q(), M = new q(), b = new q(), E = new q(), w = new q(), R = new q();
    for (let P = 0; P <= n; ++P) {
      const N = P / n * s * Math.PI * 2;
      A(N, s, c, e, M), A(N + 0.01, s, c, e, b), w.subVectors(b, M), R.addVectors(b, M), E.crossVectors(w, R), R.crossVectors(E, w), E.normalize(), R.normalize();
      for (let I = 0; I <= r; ++I) {
        const B = I / r * Math.PI * 2, W = -t * Math.cos(B), z = t * Math.sin(B);
        _.x = M.x + (W * R.x + z * E.x), _.y = M.y + (W * R.y + z * E.y), _.z = M.z + (W * R.z + z * E.z), h.push(_.x, _.y, _.z), x.subVectors(_, M).normalize(), m.push(x.x, x.y, x.z), g.push(P / n), g.push(I / r);
      }
    }
    for (let P = 1; P <= n; P++)
      for (let N = 1; N <= r; N++) {
        const I = (r + 1) * (P - 1) + (N - 1), B = (r + 1) * P + (N - 1), W = (r + 1) * P + N, z = (r + 1) * (P - 1) + N;
        f.push(I, B, z), f.push(B, W, z);
      }
    this.setIndex(f), this.setAttribute("position", new Rt(h, 3)), this.setAttribute("normal", new Rt(m, 3)), this.setAttribute("uv", new Rt(g, 2));
    function A(P, N, I, B, W) {
      const z = Math.cos(P), k = Math.sin(P), G = I / N * P, $ = Math.cos(G);
      W.x = B * (2 + $) * 0.5 * z, W.y = B * (2 + $) * k * 0.5, W.z = B * Math.sin(G) * 0.5;
    }
  }
  static fromJSON(e) {
    return new Dp(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Pp extends Kt {
  constructor(e = new dS(new q(-1, -1, 0), new q(-1, 1, 0), new q(1, 1, 0)), t = 64, n = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: r,
      closed: s
    };
    const c = e.computeFrenetFrames(t, s);
    this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
    const f = new q(), h = new q(), m = new Ue();
    let g = new q();
    const _ = [], x = [], M = [], b = [];
    E(), this.setIndex(b), this.setAttribute("position", new Rt(_, 3)), this.setAttribute("normal", new Rt(x, 3)), this.setAttribute("uv", new Rt(M, 2));
    function E() {
      for (let P = 0; P < t; P++)
        w(P);
      w(s === !1 ? t : 0), A(), R();
    }
    function w(P) {
      g = e.getPointAt(P / t, g);
      const N = c.normals[P], I = c.binormals[P];
      for (let B = 0; B <= r; B++) {
        const W = B / r * Math.PI * 2, z = Math.sin(W), k = -Math.cos(W);
        h.x = k * N.x + z * I.x, h.y = k * N.y + z * I.y, h.z = k * N.z + z * I.z, h.normalize(), x.push(h.x, h.y, h.z), f.x = g.x + n * h.x, f.y = g.y + n * h.y, f.z = g.z + n * h.z, _.push(f.x, f.y, f.z);
      }
    }
    function R() {
      for (let P = 1; P <= t; P++)
        for (let N = 1; N <= r; N++) {
          const I = (r + 1) * (P - 1) + (N - 1), B = (r + 1) * P + (N - 1), W = (r + 1) * P + N, z = (r + 1) * (P - 1) + N;
          b.push(I, B, z), b.push(B, W, z);
        }
    }
    function A() {
      for (let P = 0; P <= t; P++)
        for (let N = 0; N <= r; N++)
          m.x = P / t, m.y = N / r, M.push(m.x, m.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Pp(
      new pS[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class YT extends Kt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), r = new q(), s = new q();
      if (e.index !== null) {
        const c = e.attributes.position, f = e.index;
        let h = e.groups;
        h.length === 0 && (h = [{ start: 0, count: f.count, materialIndex: 0 }]);
        for (let m = 0, g = h.length; m < g; ++m) {
          const _ = h[m], x = _.start, M = _.count;
          for (let b = x, E = x + M; b < E; b += 3)
            for (let w = 0; w < 3; w++) {
              const R = f.getX(b + w), A = f.getX(b + (w + 1) % 3);
              r.fromBufferAttribute(c, R), s.fromBufferAttribute(c, A), ww(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const c = e.attributes.position;
        for (let f = 0, h = c.count / 3; f < h; f++)
          for (let m = 0; m < 3; m++) {
            const g = 3 * f + m, _ = 3 * f + (m + 1) % 3;
            r.fromBufferAttribute(c, g), s.fromBufferAttribute(c, _), ww(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Rt(t, 3));
    }
  }
}
function ww(u, e, t) {
  const n = `${u.x},${u.y},${u.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${u.x},${u.y},${u.z}`;
  return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0);
}
var Ew = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: ql,
  CapsuleGeometry: Sp,
  CircleGeometry: Mp,
  ConeGeometry: bp,
  CylinderGeometry: hc,
  DodecahedronGeometry: wp,
  EdgesGeometry: GT,
  ExtrudeGeometry: Ep,
  IcosahedronGeometry: Tp,
  LatheGeometry: ud,
  OctahedronGeometry: cd,
  PlaneGeometry: od,
  PolyhedronGeometry: Lo,
  RingGeometry: Cp,
  ShapeGeometry: Rp,
  SphereGeometry: fd,
  TetrahedronGeometry: Ap,
  TorusGeometry: Lp,
  TorusKnotGeometry: Dp,
  TubeGeometry: Pp,
  WireframeGeometry: YT
});
class XT extends Ki {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new xt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class ZT extends Hs {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class mS extends Ki {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new xt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class JT extends mS {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ue(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return gi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new xt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new xt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new xt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class QT extends Ki {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new xt(16777215), this.specular = new xt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mp, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class KT extends Ki {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new xt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class $T extends Ki {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class eC extends Ki {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new xt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new xt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mp, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class tC extends Ki {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new xt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Gl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class nC extends Dr {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Va(u, e, t) {
  return vS(u) ? new u.constructor(u.subarray(e, t !== void 0 ? t : u.length)) : u.slice(e, t);
}
function Ku(u, e, t) {
  return !u || // let 'undefined' and 'null' pass
  !t && u.constructor === e ? u : typeof e.BYTES_PER_ELEMENT == "number" ? new e(u) : Array.prototype.slice.call(u);
}
function vS(u) {
  return ArrayBuffer.isView(u) && !(u instanceof DataView);
}
function iC(u) {
  function e(r, s) {
    return u[r] - u[s];
  }
  const t = u.length, n = new Array(t);
  for (let r = 0; r !== t; ++r)
    n[r] = r;
  return n.sort(e), n;
}
function Ix(u, e, t) {
  const n = u.length, r = new u.constructor(n);
  for (let s = 0, c = 0; c !== n; ++s) {
    const f = t[s] * e;
    for (let h = 0; h !== e; ++h)
      r[c++] = u[f + h];
  }
  return r;
}
function gS(u, e, t, n) {
  let r = 1, s = u[0];
  for (; s !== void 0 && s[n] === void 0; )
    s = u[r++];
  if (s === void 0)
    return;
  let c = s[n];
  if (c !== void 0)
    if (Array.isArray(c))
      do
        c = s[n], c !== void 0 && (e.push(s.time), t.push.apply(t, c)), s = u[r++];
      while (s !== void 0);
    else if (c.toArray !== void 0)
      do
        c = s[n], c !== void 0 && (e.push(s.time), c.toArray(t, t.length)), s = u[r++];
      while (s !== void 0);
    else
      do
        c = s[n], c !== void 0 && (e.push(s.time), t.push(c)), s = u[r++];
      while (s !== void 0);
}
function XO(u, e, t, n, r = 30) {
  const s = u.clone();
  s.name = e;
  const c = [];
  for (let h = 0; h < s.tracks.length; ++h) {
    const m = s.tracks[h], g = m.getValueSize(), _ = [], x = [];
    for (let M = 0; M < m.times.length; ++M) {
      const b = m.times[M] * r;
      if (!(b < t || b >= n)) {
        _.push(m.times[M]);
        for (let E = 0; E < g; ++E)
          x.push(m.values[M * g + E]);
      }
    }
    _.length !== 0 && (m.times = Ku(_, m.times.constructor), m.values = Ku(x, m.values.constructor), c.push(m));
  }
  s.tracks = c;
  let f = 1 / 0;
  for (let h = 0; h < s.tracks.length; ++h)
    f > s.tracks[h].times[0] && (f = s.tracks[h].times[0]);
  for (let h = 0; h < s.tracks.length; ++h)
    s.tracks[h].shift(-1 * f);
  return s.resetDuration(), s;
}
function ZO(u, e = 0, t = u, n = 30) {
  n <= 0 && (n = 30);
  const r = t.tracks.length, s = e / n;
  for (let c = 0; c < r; ++c) {
    const f = t.tracks[c], h = f.ValueTypeName;
    if (h === "bool" || h === "string")
      continue;
    const m = u.tracks.find(function(R) {
      return R.name === f.name && R.ValueTypeName === h;
    });
    if (m === void 0)
      continue;
    let g = 0;
    const _ = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (g = _ / 3);
    let x = 0;
    const M = m.getValueSize();
    m.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (x = M / 3);
    const b = f.times.length - 1;
    let E;
    if (s <= f.times[0]) {
      const R = g, A = _ - g;
      E = Va(f.values, R, A);
    } else if (s >= f.times[b]) {
      const R = b * _ + g, A = R + _ - g;
      E = Va(f.values, R, A);
    } else {
      const R = f.createInterpolant(), A = g, P = _ - g;
      R.evaluate(s), E = Va(R.resultBuffer, A, P);
    }
    h === "quaternion" && new mr().fromArray(E).normalize().conjugate().toArray(E);
    const w = m.times.length;
    for (let R = 0; R < w; ++R) {
      const A = R * M + x;
      if (h === "quaternion")
        mr.multiplyQuaternionsFlat(
          m.values,
          A,
          E,
          0,
          m.values,
          A
        );
      else {
        const P = M - x * 2;
        for (let N = 0; N < P; ++N)
          m.values[A + N] -= E[N];
      }
    }
  }
  return u.blendMode = Qx, u;
}
var JO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arraySlice: Va,
  convertArray: Ku,
  isTypedArray: vS,
  getKeyframeOrder: iC,
  sortedArray: Ix,
  flattenJSON: gS,
  subclip: XO,
  makeClipAdditive: ZO
});
class Np {
  constructor(e, t, n, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, r = t[n], s = t[n - 1];
    e: {
      t: {
        let c;
        n: {
          i:
            if (!(e < r)) {
              for (let f = n + 2; ; ) {
                if (r === void 0) {
                  if (e < s)
                    break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === f)
                  break;
                if (s = r, r = t[++n], e < r)
                  break t;
              }
              c = t.length;
              break n;
            }
          if (!(e >= s)) {
            const f = t[1];
            e < f && (n = 2, s = f);
            for (let h = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === h)
                break;
              if (r = s, s = t[--n - 1], e >= s)
                break t;
            }
            c = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < c; ) {
          const f = n + c >>> 1;
          e < t[f] ? c = f : n = f + 1;
        }
        if (r = t[n], s = t[n - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r;
    for (let c = 0; c !== r; ++c)
      t[c] = n[s + c];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class rC extends Np {
  constructor(e, t, n, r) {
    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Zu,
      endingEnd: Zu
    };
  }
  intervalChanged_(e, t, n) {
    const r = this.parameterPositions;
    let s = e - 2, c = e + 1, f = r[s], h = r[c];
    if (f === void 0)
      switch (this.getSettings_().endingStart) {
        case Ju:
          s = e, f = 2 * t - n;
          break;
        case ip:
          s = r.length - 2, f = t + r[s] - r[s + 1];
          break;
        default:
          s = e, f = n;
      }
    if (h === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ju:
          c = e, h = 2 * n - t;
          break;
        case ip:
          c = 1, h = n + r[1] - r[0];
          break;
        default:
          c = e - 1, h = t;
      }
    const m = (n - t) * 0.5, g = this.valueSize;
    this._weightPrev = m / (t - f), this._weightNext = m / (h - n), this._offsetPrev = s * g, this._offsetNext = c * g;
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, c = this.sampleValues, f = this.valueSize, h = e * f, m = h - f, g = this._offsetPrev, _ = this._offsetNext, x = this._weightPrev, M = this._weightNext, b = (n - t) / (r - t), E = b * b, w = E * b, R = -x * w + 2 * x * E - x * b, A = (1 + x) * w + (-1.5 - 2 * x) * E + (-0.5 + x) * b + 1, P = (-1 - M) * w + (1.5 + M) * E + 0.5 * b, N = M * w - M * E;
    for (let I = 0; I !== f; ++I)
      s[I] = R * c[g + I] + A * c[m + I] + P * c[h + I] + N * c[_ + I];
    return s;
  }
}
class yS extends Np {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, c = this.sampleValues, f = this.valueSize, h = e * f, m = h - f, g = (n - t) / (r - t), _ = 1 - g;
    for (let x = 0; x !== f; ++x)
      s[x] = c[m + x] * _ + c[h + x] * g;
    return s;
  }
}
class aC extends Np {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ps {
  constructor(e, t, n, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Ku(t, this.TimeBufferType), this.values = Ku(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Ku(e.times, Array),
        values: Ku(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new aC(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new yS(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new rC(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case tp:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case np:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case mg:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return tp;
      case this.InterpolantFactoryMethodLinear:
        return np;
      case this.InterpolantFactoryMethodSmooth:
        return mg;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, r = n.length;
    let s = 0, c = r - 1;
    for (; s !== r && n[s] < e; )
      ++s;
    for (; c !== -1 && n[c] > t; )
      --c;
    if (++c, s !== 0 || c !== r) {
      s >= c && (c = Math.max(c, 1), s = c - 1);
      const f = this.getValueSize();
      this.times = Va(n, s, c), this.values = Va(this.values, s * f, c * f);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let c = null;
    for (let f = 0; f !== s; f++) {
      const h = n[f];
      if (typeof h == "number" && isNaN(h)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, h), e = !1;
        break;
      }
      if (c !== null && c > h) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, f, h, c), e = !1;
        break;
      }
      c = h;
    }
    if (r !== void 0 && vS(r))
      for (let f = 0, h = r.length; f !== h; ++f) {
        const m = r[f];
        if (isNaN(m)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, m), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = Va(this.times), t = Va(this.values), n = this.getValueSize(), r = this.getInterpolation() === mg, s = e.length - 1;
    let c = 1;
    for (let f = 1; f < s; ++f) {
      let h = !1;
      const m = e[f], g = e[f + 1];
      if (m !== g && (f !== 1 || m !== e[0]))
        if (r)
          h = !0;
        else {
          const _ = f * n, x = _ - n, M = _ + n;
          for (let b = 0; b !== n; ++b) {
            const E = t[_ + b];
            if (E !== t[x + b] || E !== t[M + b]) {
              h = !0;
              break;
            }
          }
        }
      if (h) {
        if (f !== c) {
          e[c] = e[f];
          const _ = f * n, x = c * n;
          for (let M = 0; M !== n; ++M)
            t[x + M] = t[_ + M];
        }
        ++c;
      }
    }
    if (s > 0) {
      e[c] = e[s];
      for (let f = s * n, h = c * n, m = 0; m !== n; ++m)
        t[h + m] = t[f + m];
      ++c;
    }
    return c !== e.length ? (this.times = Va(e, 0, c), this.values = Va(t, 0, c * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = Va(this.times, 0), t = Va(this.values, 0), n = this.constructor, r = new n(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
ps.prototype.TimeBufferType = Float32Array;
ps.prototype.ValueBufferType = Float32Array;
ps.prototype.DefaultInterpolation = np;
class pc extends ps {
}
pc.prototype.ValueTypeName = "bool";
pc.prototype.ValueBufferType = Array;
pc.prototype.DefaultInterpolation = tp;
pc.prototype.InterpolantFactoryMethodLinear = void 0;
pc.prototype.InterpolantFactoryMethodSmooth = void 0;
class _S extends ps {
}
_S.prototype.ValueTypeName = "color";
class fp extends ps {
}
fp.prototype.ValueTypeName = "number";
class sC extends Np {
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, c = this.sampleValues, f = this.valueSize, h = (n - t) / (r - t);
    let m = e * f;
    for (let g = m + f; m !== g; m += 4)
      mr.slerpFlat(s, 0, c, m - f, c, m, h);
    return s;
  }
}
class dd extends ps {
  InterpolantFactoryMethodLinear(e) {
    return new sC(this.times, this.values, this.getValueSize(), e);
  }
}
dd.prototype.ValueTypeName = "quaternion";
dd.prototype.DefaultInterpolation = np;
dd.prototype.InterpolantFactoryMethodSmooth = void 0;
class mc extends ps {
}
mc.prototype.ValueTypeName = "string";
mc.prototype.ValueBufferType = Array;
mc.prototype.DefaultInterpolation = tp;
mc.prototype.InterpolantFactoryMethodLinear = void 0;
mc.prototype.InterpolantFactoryMethodSmooth = void 0;
class dp extends ps {
}
dp.prototype.ValueTypeName = "vector";
class hp {
  constructor(e, t = -1, n, r = Dg) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = va(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, r = 1 / (e.fps || 1);
    for (let c = 0, f = n.length; c !== f; ++c)
      t.push(KO(n[c]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, c = n.length; s !== c; ++s)
      t.push(ps.toJSON(n[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, n, r) {
    const s = t.length, c = [];
    for (let f = 0; f < s; f++) {
      let h = [], m = [];
      h.push(
        (f + s - 1) % s,
        f,
        (f + 1) % s
      ), m.push(0, 1, 0);
      const g = iC(h);
      h = Ix(h, 1, g), m = Ix(m, 1, g), !r && h[0] === 0 && (h.push(s), m.push(m[0])), c.push(
        new fp(
          ".morphTargetInfluences[" + t[f].name + "]",
          h,
          m
        ).scale(1 / n)
      );
    }
    return new this(e, -1, c);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const r = e;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === t)
        return n[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let f = 0, h = e.length; f < h; f++) {
      const m = e[f], g = m.name.match(s);
      if (g && g.length > 1) {
        const _ = g[1];
        let x = r[_];
        x || (r[_] = x = []), x.push(m);
      }
    }
    const c = [];
    for (const f in r)
      c.push(this.CreateFromMorphTargetSequence(f, r[f], t, n));
    return c;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(_, x, M, b, E) {
      if (M.length !== 0) {
        const w = [], R = [];
        gS(M, w, R, b), w.length !== 0 && E.push(new _(x, w, R));
      }
    }, r = [], s = e.name || "default", c = e.fps || 30, f = e.blendMode;
    let h = e.length || -1;
    const m = e.hierarchy || [];
    for (let _ = 0; _ < m.length; _++) {
      const x = m[_].keys;
      if (!(!x || x.length === 0))
        if (x[0].morphTargets) {
          const M = {};
          let b;
          for (b = 0; b < x.length; b++)
            if (x[b].morphTargets)
              for (let E = 0; E < x[b].morphTargets.length; E++)
                M[x[b].morphTargets[E]] = -1;
          for (const E in M) {
            const w = [], R = [];
            for (let A = 0; A !== x[b].morphTargets.length; ++A) {
              const P = x[b];
              w.push(P.time), R.push(P.morphTarget === E ? 1 : 0);
            }
            r.push(new fp(".morphTargetInfluence[" + E + "]", w, R));
          }
          h = M.length * c;
        } else {
          const M = ".bones[" + t[_].name + "]";
          n(
            dp,
            M + ".position",
            x,
            "pos",
            r
          ), n(
            dd,
            M + ".quaternion",
            x,
            "rot",
            r
          ), n(
            dp,
            M + ".scale",
            x,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(s, h, r, f);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function QO(u) {
  switch (u.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return fp;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return dp;
    case "color":
      return _S;
    case "quaternion":
      return dd;
    case "bool":
    case "boolean":
      return pc;
    case "string":
      return mc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + u);
}
function KO(u) {
  if (u.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = QO(u.type);
  if (u.times === void 0) {
    const t = [], n = [];
    gS(u.keys, t, n, "value"), u.times = t, u.values = n;
  }
  return e.parse !== void 0 ? e.parse(u) : new e(u.name, u.times, u.values, u.interpolation);
}
const uc = {
  enabled: !1,
  files: {},
  add: function(u, e) {
    this.enabled !== !1 && (this.files[u] = e);
  },
  get: function(u) {
    if (this.enabled !== !1)
      return this.files[u];
  },
  remove: function(u) {
    delete this.files[u];
  },
  clear: function() {
    this.files = {};
  }
};
class xS {
  constructor(e, t, n) {
    const r = this;
    let s = !1, c = 0, f = 0, h;
    const m = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(g) {
      f++, s === !1 && r.onStart !== void 0 && r.onStart(g, c, f), s = !0;
    }, this.itemEnd = function(g) {
      c++, r.onProgress !== void 0 && r.onProgress(g, c, f), c === f && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(g) {
      r.onError !== void 0 && r.onError(g);
    }, this.resolveURL = function(g) {
      return h ? h(g) : g;
    }, this.setURLModifier = function(g) {
      return h = g, this;
    }, this.addHandler = function(g, _) {
      return m.push(g, _), this;
    }, this.removeHandler = function(g) {
      const _ = m.indexOf(g);
      return _ !== -1 && m.splice(_, 2), this;
    }, this.getHandler = function(g) {
      for (let _ = 0, x = m.length; _ < x; _ += 2) {
        const M = m[_], b = m[_ + 1];
        if (M.global && (M.lastIndex = 0), M.test(g))
          return b;
      }
      return null;
    };
  }
}
const oC = /* @__PURE__ */ new xS();
class ga {
  constructor(e) {
    this.manager = e !== void 0 ? e : oC, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const bo = {};
class $O extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Ao extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = uc.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (bo[e] !== void 0) {
      bo[e].push({
        onLoad: t,
        onProgress: n,
        onError: r
      });
      return;
    }
    bo[e] = [], bo[e].push({
      onLoad: t,
      onProgress: n,
      onError: r
    });
    const c = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), f = this.mimeType, h = this.responseType;
    fetch(c).then((m) => {
      if (m.status === 200 || m.status === 0) {
        if (m.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || m.body === void 0 || m.body.getReader === void 0)
          return m;
        const g = bo[e], _ = m.body.getReader(), x = m.headers.get("Content-Length"), M = x ? parseInt(x) : 0, b = M !== 0;
        let E = 0;
        const w = new ReadableStream({
          start(R) {
            A();
            function A() {
              _.read().then(({ done: P, value: N }) => {
                if (P)
                  R.close();
                else {
                  E += N.byteLength;
                  const I = new ProgressEvent("progress", { lengthComputable: b, loaded: E, total: M });
                  for (let B = 0, W = g.length; B < W; B++) {
                    const z = g[B];
                    z.onProgress && z.onProgress(I);
                  }
                  R.enqueue(N), A();
                }
              });
            }
          }
        });
        return new Response(w);
      } else
        throw new $O(`fetch for "${m.url}" responded with ${m.status}: ${m.statusText}`, m);
    }).then((m) => {
      switch (h) {
        case "arraybuffer":
          return m.arrayBuffer();
        case "blob":
          return m.blob();
        case "document":
          return m.text().then((g) => new DOMParser().parseFromString(g, f));
        case "json":
          return m.json();
        default:
          if (f === void 0)
            return m.text();
          {
            const _ = /charset="?([^;"\s]*)"?/i.exec(f), x = _ && _[1] ? _[1].toLowerCase() : void 0, M = new TextDecoder(x);
            return m.arrayBuffer().then((b) => M.decode(b));
          }
      }
    }).then((m) => {
      uc.add(e, m);
      const g = bo[e];
      delete bo[e];
      for (let _ = 0, x = g.length; _ < x; _++) {
        const M = g[_];
        M.onLoad && M.onLoad(m);
      }
    }).catch((m) => {
      const g = bo[e];
      if (g === void 0)
        throw this.manager.itemError(e), m;
      delete bo[e];
      for (let _ = 0, x = g.length; _ < x; _++) {
        const M = g[_];
        M.onError && M.onError(m);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class eI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = new Ao(this.manager);
    c.setPath(this.path), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(f) {
      try {
        t(s.parse(JSON.parse(f)));
      } catch (h) {
        r ? r(h) : console.error(h), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const r = hp.parse(e[n]);
      t.push(r);
    }
    return t;
  }
}
class tI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = [], f = new UT(), h = new Ao(this.manager);
    h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(s.withCredentials);
    let m = 0;
    function g(_) {
      h.load(e[_], function(x) {
        const M = s.parse(x, !0);
        c[_] = {
          width: M.width,
          height: M.height,
          format: M.format,
          mipmaps: M.mipmaps
        }, m += 1, m === 6 && (M.mipmapCount === 1 && (f.minFilter = vi), f.image = c, f.format = M.format, f.needsUpdate = !0, t && t(f));
      }, n, r);
    }
    if (Array.isArray(e))
      for (let _ = 0, x = e.length; _ < x; ++_)
        g(_);
    else
      h.load(e, function(_) {
        const x = s.parse(_, !0);
        if (x.isCubemap) {
          const M = x.mipmaps.length / x.mipmapCount;
          for (let b = 0; b < M; b++) {
            c[b] = { mipmaps: [] };
            for (let E = 0; E < x.mipmapCount; E++)
              c[b].mipmaps.push(x.mipmaps[b * x.mipmapCount + E]), c[b].format = x.format, c[b].width = x.width, c[b].height = x.height;
          }
          f.image = c;
        } else
          f.image.width = x.width, f.image.height = x.height, f.mipmaps = x.mipmaps;
        x.mipmapCount === 1 && (f.minFilter = vi), f.format = x.format, f.needsUpdate = !0, t && t(f);
      }, n, r);
    return f;
  }
}
class pp extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, c = uc.get(e);
    if (c !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(c), s.manager.itemEnd(e);
      }, 0), c;
    const f = sp("img");
    function h() {
      g(), uc.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function m(_) {
      g(), r && r(_), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function g() {
      f.removeEventListener("load", h, !1), f.removeEventListener("error", m, !1);
    }
    return f.addEventListener("load", h, !1), f.addEventListener("error", m, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (f.crossOrigin = this.crossOrigin), s.manager.itemStart(e), f.src = e, f;
  }
}
class nI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new _p(), c = new pp(this.manager);
    c.setCrossOrigin(this.crossOrigin), c.setPath(this.path);
    let f = 0;
    function h(m) {
      c.load(e[m], function(g) {
        s.images[m] = g, f++, f === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, r);
    }
    for (let m = 0; m < e.length; ++m)
      h(m);
    return s;
  }
}
class iI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = new ed(), f = new Ao(this.manager);
    return f.setResponseType("arraybuffer"), f.setRequestHeader(this.requestHeader), f.setPath(this.path), f.setWithCredentials(s.withCredentials), f.load(e, function(h) {
      const m = s.parse(h);
      m && (m.image !== void 0 ? c.image = m.image : m.data !== void 0 && (c.image.width = m.width, c.image.height = m.height, c.image.data = m.data), c.wrapS = m.wrapS !== void 0 ? m.wrapS : Lr, c.wrapT = m.wrapT !== void 0 ? m.wrapT : Lr, c.magFilter = m.magFilter !== void 0 ? m.magFilter : vi, c.minFilter = m.minFilter !== void 0 ? m.minFilter : vi, c.anisotropy = m.anisotropy !== void 0 ? m.anisotropy : 1, m.encoding !== void 0 && (c.encoding = m.encoding), m.flipY !== void 0 && (c.flipY = m.flipY), m.format !== void 0 && (c.format = m.format), m.type !== void 0 && (c.type = m.type), m.mipmaps !== void 0 && (c.mipmaps = m.mipmaps, c.minFilter = cc), m.mipmapCount === 1 && (c.minFilter = vi), m.generateMipmaps !== void 0 && (c.generateMipmaps = m.generateMipmaps), c.needsUpdate = !0, t && t(c, m));
    }, n, r), c;
  }
}
class rI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = new Mi(), c = new pp(this.manager);
    return c.setCrossOrigin(this.crossOrigin), c.setPath(this.path), c.load(e, function(f) {
      s.image = f, s.needsUpdate = !0, t !== void 0 && t(s);
    }, n, r), s;
  }
}
class jl extends xn {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new xt(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class lC extends jl {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(xn.DefaultUp), this.updateMatrix(), this.groundColor = new xt(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const I_ = /* @__PURE__ */ new Qt(), Tw = /* @__PURE__ */ new q(), Cw = /* @__PURE__ */ new q();
class SS {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ue(512, 512), this.map = null, this.mapPass = null, this.matrix = new Qt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Ng(), this._frameExtents = new Ue(1, 1), this._viewportCount = 1, this._viewports = [
      new An(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    Tw.setFromMatrixPosition(e.matrixWorld), t.position.copy(Tw), Cw.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Cw), t.updateMatrixWorld(), I_.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(I_), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(I_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class aI extends SS {
  constructor() {
    super(new Vi(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = ap * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (n !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class uC extends jl {
  constructor(e, t, n = 0, r = Math.PI / 3, s = 0, c = 1) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(xn.DefaultUp), this.updateMatrix(), this.target = new xn(), this.distance = n, this.angle = r, this.penumbra = s, this.decay = c, this.map = null, this.shadow = new aI();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const Rw = /* @__PURE__ */ new Qt(), Gh = /* @__PURE__ */ new q(), U_ = /* @__PURE__ */ new q();
class sI extends SS {
  constructor() {
    super(new Vi(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ue(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new An(2, 1, 1, 1),
      // negative X
      new An(0, 1, 1, 1),
      // positive Z
      new An(3, 1, 1, 1),
      // negative Z
      new An(1, 1, 1, 1),
      // positive Y
      new An(3, 0, 1, 1),
      // negative Y
      new An(1, 0, 1, 1)
    ], this._cubeDirections = [
      new q(1, 0, 0),
      new q(-1, 0, 0),
      new q(0, 0, 1),
      new q(0, 0, -1),
      new q(0, 1, 0),
      new q(0, -1, 0)
    ], this._cubeUps = [
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 0, 1),
      new q(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, r = this.matrix, s = e.distance || n.far;
    s !== n.far && (n.far = s, n.updateProjectionMatrix()), Gh.setFromMatrixPosition(e.matrixWorld), n.position.copy(Gh), U_.copy(n.position), U_.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(U_), n.updateMatrixWorld(), r.makeTranslation(-Gh.x, -Gh.y, -Gh.z), Rw.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Rw);
  }
}
class cC extends jl {
  constructor(e, t, n = 0, r = 1) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new sI();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class oI extends SS {
  constructor() {
    super(new xp(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class fC extends jl {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(xn.DefaultUp), this.updateMatrix(), this.target = new xn(), this.shadow = new oI();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class dC extends jl {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class hC extends jl {
  constructor(e, t, n = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class pC {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new q());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, r = e.y, s = e.z, c = this.coefficients;
    return t.copy(c[0]).multiplyScalar(0.282095), t.addScaledVector(c[1], 0.488603 * r), t.addScaledVector(c[2], 0.488603 * s), t.addScaledVector(c[3], 0.488603 * n), t.addScaledVector(c[4], 1.092548 * (n * r)), t.addScaledVector(c[5], 1.092548 * (r * s)), t.addScaledVector(c[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(c[7], 1.092548 * (n * s)), t.addScaledVector(c[8], 0.546274 * (n * n - r * r)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, r = e.y, s = e.z, c = this.coefficients;
    return t.copy(c[0]).multiplyScalar(0.886227), t.addScaledVector(c[1], 2 * 0.511664 * r), t.addScaledVector(c[2], 2 * 0.511664 * s), t.addScaledVector(c[3], 2 * 0.511664 * n), t.addScaledVector(c[4], 2 * 0.429043 * n * r), t.addScaledVector(c[5], 2 * 0.429043 * r * s), t.addScaledVector(c[6], 0.743125 * s * s - 0.247708), t.addScaledVector(c[7], 2 * 0.429043 * n * s), t.addScaledVector(c[8], 0.429043 * (n * n - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].toArray(e, t + r * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = 0.546274 * (n * n - r * r);
  }
}
class Vg extends jl {
  constructor(e = new pC(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Gg extends ga {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, r) {
    const s = this, c = new Ao(s.manager);
    c.setPath(s.path), c.setRequestHeader(s.requestHeader), c.setWithCredentials(s.withCredentials), c.load(e, function(f) {
      try {
        t(s.parse(JSON.parse(f)));
      } catch (h) {
        r ? r(h) : console.error(h), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = this.textures;
    function n(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const r = Gg.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new xt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const c = e.uniforms[s];
        switch (r.uniforms[s] = {}, c.type) {
          case "t":
            r.uniforms[s].value = n(c.value);
            break;
          case "c":
            r.uniforms[s].value = new xt().setHex(c.value);
            break;
          case "v2":
            r.uniforms[s].value = new Ue().fromArray(c.value);
            break;
          case "v3":
            r.uniforms[s].value = new q().fromArray(c.value);
            break;
          case "v4":
            r.uniforms[s].value = new An().fromArray(c.value);
            break;
          case "m3":
            r.uniforms[s].value = new Zr().fromArray(c.value);
            break;
          case "m4":
            r.uniforms[s].value = new Qt().fromArray(c.value);
            break;
          default:
            r.uniforms[s].value = c.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        r.extensions[s] = e.extensions[s];
    if (e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = n(e.map)), e.matcap !== void 0 && (r.matcap = n(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new Ue().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Ue().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: XT,
      SpriteMaterial: sS,
      RawShaderMaterial: ZT,
      ShaderMaterial: Hs,
      PointsMaterial: lS,
      MeshPhysicalMaterial: JT,
      MeshStandardMaterial: mS,
      MeshPhongMaterial: QT,
      MeshToonMaterial: KT,
      MeshNormalMaterial: $T,
      MeshLambertMaterial: eC,
      MeshDepthMaterial: iS,
      MeshDistanceMaterial: rS,
      MeshBasicMaterial: Wl,
      MeshMatcapMaterial: tC,
      LineDashedMaterial: nC,
      LineBasicMaterial: Dr,
      Material: Ki
    };
    return new t[e]();
  }
}
class Ux {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, r = e.length; n < r; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class mC extends Kt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class vC extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = new Ao(s.manager);
    c.setPath(s.path), c.setRequestHeader(s.requestHeader), c.setWithCredentials(s.withCredentials), c.load(e, function(f) {
      try {
        t(s.parse(JSON.parse(f)));
      } catch (h) {
        r ? r(h) : console.error(h), s.manager.itemError(e);
      }
    }, n, r);
  }
  parse(e) {
    const t = {}, n = {};
    function r(M, b) {
      if (t[b] !== void 0)
        return t[b];
      const w = M.interleavedBuffers[b], R = s(M, w.buffer), A = Zf(w.type, R), P = new Ug(A, w.stride);
      return P.uuid = w.uuid, t[b] = P, P;
    }
    function s(M, b) {
      if (n[b] !== void 0)
        return n[b];
      const w = M.arrayBuffers[b], R = new Uint32Array(w).buffer;
      return n[b] = R, R;
    }
    const c = e.isInstancedBufferGeometry ? new mC() : new Kt(), f = e.data.index;
    if (f !== void 0) {
      const M = Zf(f.type, f.array);
      c.setIndex(new Fn(M, 1));
    }
    const h = e.data.attributes;
    for (const M in h) {
      const b = h[M];
      let E;
      if (b.isInterleavedBufferAttribute) {
        const w = r(e.data, b.data);
        E = new lc(w, b.itemSize, b.offset, b.normalized);
      } else {
        const w = Zf(b.type, b.array), R = b.isInstancedBufferAttribute ? id : Fn;
        E = new R(w, b.itemSize, b.normalized);
      }
      b.name !== void 0 && (E.name = b.name), b.usage !== void 0 && E.setUsage(b.usage), b.updateRange !== void 0 && (E.updateRange.offset = b.updateRange.offset, E.updateRange.count = b.updateRange.count), c.setAttribute(M, E);
    }
    const m = e.data.morphAttributes;
    if (m)
      for (const M in m) {
        const b = m[M], E = [];
        for (let w = 0, R = b.length; w < R; w++) {
          const A = b[w];
          let P;
          if (A.isInterleavedBufferAttribute) {
            const N = r(e.data, A.data);
            P = new lc(N, A.itemSize, A.offset, A.normalized);
          } else {
            const N = Zf(A.type, A.array);
            P = new Fn(N, A.itemSize, A.normalized);
          }
          A.name !== void 0 && (P.name = A.name), E.push(P);
        }
        c.morphAttributes[M] = E;
      }
    e.data.morphTargetsRelative && (c.morphTargetsRelative = !0);
    const _ = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (_ !== void 0)
      for (let M = 0, b = _.length; M !== b; ++M) {
        const E = _[M];
        c.addGroup(E.start, E.count, E.materialIndex);
      }
    const x = e.data.boundingSphere;
    if (x !== void 0) {
      const M = new q();
      x.center !== void 0 && M.fromArray(x.center), c.boundingSphere = new dc(M, x.radius);
    }
    return e.name && (c.name = e.name), e.userData && (c.userData = e.userData), c;
  }
}
class lI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = this.path === "" ? Ux.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || c;
    const f = new Ao(this.manager);
    f.setPath(this.path), f.setRequestHeader(this.requestHeader), f.setWithCredentials(this.withCredentials), f.load(e, function(h) {
      let m = null;
      try {
        m = JSON.parse(h);
      } catch (_) {
        r !== void 0 && r(_), console.error("THREE:ObjectLoader: Can't parse " + e + ".", _.message);
        return;
      }
      const g = m.metadata;
      if (g === void 0 || g.type === void 0 || g.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(m, t);
    }, n, r);
  }
  async loadAsync(e, t) {
    const n = this, r = this.path === "" ? Ux.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Ao(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const c = await s.loadAsync(e, t), f = JSON.parse(c), h = f.metadata;
    if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(f);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), c = this.parseImages(e.images, function() {
      t !== void 0 && t(m);
    }), f = this.parseTextures(e.textures, c), h = this.parseMaterials(e.materials, f), m = this.parseObject(e.object, s, h, f, n), g = this.parseSkeletons(e.skeletons, m);
    if (this.bindSkeletons(m, g), t !== void 0) {
      let _ = !1;
      for (const x in c)
        if (c[x].data instanceof HTMLImageElement) {
          _ = !0;
          break;
        }
      _ === !1 && t(m);
    }
    return m;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), s = await this.parseImagesAsync(e.images), c = this.parseTextures(e.textures, s), f = this.parseMaterials(e.materials, c), h = this.parseObject(e.object, r, f, c, t), m = this.parseSkeletons(e.skeletons, h);
    return this.bindSkeletons(h, m), h;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, r = e.length; n < r; n++) {
        const s = new ac().fromJSON(e[n]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, r = {};
    if (t.traverse(function(s) {
      s.isBone && (r[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, c = e.length; s < c; s++) {
        const f = new Fg().fromJSON(e[s], r);
        n[f.uuid] = f;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const r = new vC();
      for (let s = 0, c = e.length; s < c; s++) {
        let f;
        const h = e[s];
        switch (h.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            f = r.parse(h);
            break;
          default:
            h.type in Ew ? f = Ew[h.type].fromJSON(h, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${h.type}"`);
        }
        f.uuid = h.uuid, h.name !== void 0 && (f.name = h.name), f.isBufferGeometry === !0 && h.userData !== void 0 && (f.userData = h.userData), n[h.uuid] = f;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, r = {};
    if (e !== void 0) {
      const s = new Gg();
      s.setTextures(t);
      for (let c = 0, f = e.length; c < f; c++) {
        const h = e[c];
        n[h.uuid] === void 0 && (n[h.uuid] = s.parse(h)), r[h.uuid] = n[h.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const r = e[n], s = hp.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, r = {};
    let s;
    function c(h) {
      return n.manager.itemStart(h), s.load(h, function() {
        n.manager.itemEnd(h);
      }, void 0, function() {
        n.manager.itemError(h), n.manager.itemEnd(h);
      });
    }
    function f(h) {
      if (typeof h == "string") {
        const m = h, g = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : n.resourcePath + m;
        return c(g);
      } else
        return h.data ? {
          data: Zf(h.type, h.data),
          width: h.width,
          height: h.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const h = new xS(t);
      s = new pp(h), s.setCrossOrigin(this.crossOrigin);
      for (let m = 0, g = e.length; m < g; m++) {
        const _ = e[m], x = _.url;
        if (Array.isArray(x)) {
          const M = [];
          for (let b = 0, E = x.length; b < E; b++) {
            const w = x[b], R = f(w);
            R !== null && (R instanceof HTMLImageElement ? M.push(R) : M.push(new ed(R.data, R.width, R.height)));
          }
          r[_.uuid] = new Qu(M);
        } else {
          const M = f(_.url);
          r[_.uuid] = new Qu(M);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let r;
    async function s(c) {
      if (typeof c == "string") {
        const f = c, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : t.resourcePath + f;
        return await r.loadAsync(h);
      } else
        return c.data ? {
          data: Zf(c.type, c.data),
          width: c.width,
          height: c.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new pp(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let c = 0, f = e.length; c < f; c++) {
        const h = e[c], m = h.url;
        if (Array.isArray(m)) {
          const g = [];
          for (let _ = 0, x = m.length; _ < x; _++) {
            const M = m[_], b = await s(M);
            b !== null && (b instanceof HTMLImageElement ? g.push(b) : g.push(new ed(b.data, b.width, b.height)));
          }
          n[h.uuid] = new Qu(g);
        } else {
          const g = await s(h.url);
          n[h.uuid] = new Qu(g);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(s, c) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), c[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, c = e.length; s < c; s++) {
        const f = e[s];
        f.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', f.uuid), t[f.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", f.image);
        const h = t[f.image], m = h.data;
        let g;
        Array.isArray(m) ? (g = new _p(), m.length === 6 && (g.needsUpdate = !0)) : (m && m.data ? g = new ed() : g = new Mi(), m && (g.needsUpdate = !0)), g.source = h, g.uuid = f.uuid, f.name !== void 0 && (g.name = f.name), f.mapping !== void 0 && (g.mapping = n(f.mapping, uI)), f.offset !== void 0 && g.offset.fromArray(f.offset), f.repeat !== void 0 && g.repeat.fromArray(f.repeat), f.center !== void 0 && g.center.fromArray(f.center), f.rotation !== void 0 && (g.rotation = f.rotation), f.wrap !== void 0 && (g.wrapS = n(f.wrap[0], Aw), g.wrapT = n(f.wrap[1], Aw)), f.format !== void 0 && (g.format = f.format), f.type !== void 0 && (g.type = f.type), f.encoding !== void 0 && (g.encoding = f.encoding), f.minFilter !== void 0 && (g.minFilter = n(f.minFilter, Lw)), f.magFilter !== void 0 && (g.magFilter = n(f.magFilter, Lw)), f.anisotropy !== void 0 && (g.anisotropy = f.anisotropy), f.flipY !== void 0 && (g.flipY = f.flipY), f.premultiplyAlpha !== void 0 && (g.premultiplyAlpha = f.premultiplyAlpha), f.unpackAlignment !== void 0 && (g.unpackAlignment = f.unpackAlignment), f.userData !== void 0 && (g.userData = f.userData), r[f.uuid] = g;
      }
    return r;
  }
  parseObject(e, t, n, r, s) {
    let c;
    function f(x) {
      return t[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", x), t[x];
    }
    function h(x) {
      if (x !== void 0) {
        if (Array.isArray(x)) {
          const M = [];
          for (let b = 0, E = x.length; b < E; b++) {
            const w = x[b];
            n[w] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", w), M.push(n[w]);
          }
          return M;
        }
        return n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), n[x];
      }
    }
    function m(x) {
      return r[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", x), r[x];
    }
    let g, _;
    switch (e.type) {
      case "Scene":
        c = new wg(), e.background !== void 0 && (Number.isInteger(e.background) ? c.background = new xt(e.background) : c.background = m(e.background)), e.environment !== void 0 && (c.environment = m(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? c.fog = new Ig(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (c.fog = new Og(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        c = new Vi(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (c.focus = e.focus), e.zoom !== void 0 && (c.zoom = e.zoom), e.filmGauge !== void 0 && (c.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (c.filmOffset = e.filmOffset), e.view !== void 0 && (c.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        c = new xp(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (c.zoom = e.zoom), e.view !== void 0 && (c.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        c = new dC(e.color, e.intensity);
        break;
      case "DirectionalLight":
        c = new fC(e.color, e.intensity);
        break;
      case "PointLight":
        c = new cC(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        c = new hC(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        c = new uC(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        c = new lC(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        c = new Vg().fromJSON(e);
        break;
      case "SkinnedMesh":
        g = f(e.geometry), _ = h(e.material), c = new NT(g, _), e.bindMode !== void 0 && (c.bindMode = e.bindMode), e.bindMatrix !== void 0 && c.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (c.skeleton = e.skeleton);
        break;
      case "Mesh":
        g = f(e.geometry), _ = h(e.material), c = new Qi(g, _);
        break;
      case "InstancedMesh":
        g = f(e.geometry), _ = h(e.material);
        const x = e.count, M = e.instanceMatrix, b = e.instanceColor;
        c = new zT(g, _, x), c.instanceMatrix = new id(new Float32Array(M.array), 16), b !== void 0 && (c.instanceColor = new id(new Float32Array(b.array), b.itemSize));
        break;
      case "LOD":
        c = new PT();
        break;
      case "Line":
        c = new kl(f(e.geometry), h(e.material));
        break;
      case "LineLoop":
        c = new OT(f(e.geometry), h(e.material));
        break;
      case "LineSegments":
        c = new Vs(f(e.geometry), h(e.material));
        break;
      case "PointCloud":
      case "Points":
        c = new IT(f(e.geometry), h(e.material));
        break;
      case "Sprite":
        c = new DT(h(e.material));
        break;
      case "Group":
        c = new Qf();
        break;
      case "Bone":
        c = new oS();
        break;
      default:
        c = new xn();
    }
    if (c.uuid = e.uuid, e.name !== void 0 && (c.name = e.name), e.matrix !== void 0 ? (c.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (c.matrixAutoUpdate = e.matrixAutoUpdate), c.matrixAutoUpdate && c.matrix.decompose(c.position, c.quaternion, c.scale)) : (e.position !== void 0 && c.position.fromArray(e.position), e.rotation !== void 0 && c.rotation.fromArray(e.rotation), e.quaternion !== void 0 && c.quaternion.fromArray(e.quaternion), e.scale !== void 0 && c.scale.fromArray(e.scale)), e.castShadow !== void 0 && (c.castShadow = e.castShadow), e.receiveShadow !== void 0 && (c.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (c.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (c.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (c.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && c.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (c.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (c.visible = e.visible), e.frustumCulled !== void 0 && (c.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (c.renderOrder = e.renderOrder), e.userData !== void 0 && (c.userData = e.userData), e.layers !== void 0 && (c.layers.mask = e.layers), e.children !== void 0) {
      const x = e.children;
      for (let M = 0; M < x.length; M++)
        c.add(this.parseObject(x[M], t, n, r, s));
    }
    if (e.animations !== void 0) {
      const x = e.animations;
      for (let M = 0; M < x.length; M++) {
        const b = x[M];
        c.animations.push(s[b]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (c.autoUpdate = e.autoUpdate);
      const x = e.levels;
      for (let M = 0; M < x.length; M++) {
        const b = x[M], E = c.getObjectByProperty("uuid", b.object);
        E !== void 0 && c.addLevel(E, b.distance);
      }
    }
    return c;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const r = t[n.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(r, n.bindMatrix);
      }
    });
  }
}
const uI = {
  UVMapping: Lg,
  CubeReflectionMapping: Fl,
  CubeRefractionMapping: Bl,
  EquirectangularReflectionMapping: Qh,
  EquirectangularRefractionMapping: Kh,
  CubeUVReflectionMapping: ad
}, Aw = {
  RepeatWrapping: $h,
  ClampToEdgeWrapping: Lr,
  MirroredRepeatWrapping: ep
}, Lw = {
  NearestFilter: Si,
  NearestMipmapNearestFilter: xg,
  NearestMipmapLinearFilter: Sg,
  LinearFilter: vi,
  LinearMipmapNearestFilter: Zx,
  LinearMipmapLinearFilter: cc
};
class cI extends ga {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, c = uc.get(e);
    if (c !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(c), s.manager.itemEnd(e);
      }, 0), c;
    const f = {};
    f.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", f.headers = this.requestHeader, fetch(e, f).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      uc.add(e, h), t && t(h), s.manager.itemEnd(e);
    }).catch(function(h) {
      r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
let tg;
const MS = {
  getContext: function() {
    return tg === void 0 && (tg = new (window.AudioContext || window.webkitAudioContext)()), tg;
  },
  setContext: function(u) {
    tg = u;
  }
};
class fI extends ga {
  constructor(e) {
    super(e);
  }
  load(e, t, n, r) {
    const s = this, c = new Ao(this.manager);
    c.setResponseType("arraybuffer"), c.setPath(this.path), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(f) {
      try {
        const h = f.slice(0);
        MS.getContext().decodeAudioData(h, function(g) {
          t(g);
        });
      } catch (h) {
        r ? r(h) : console.error(h), s.manager.itemError(e);
      }
    }, n, r);
  }
}
class dI extends Vg {
  constructor(e, t, n = 1) {
    super(void 0, n), this.isHemisphereLightProbe = !0;
    const r = new xt().set(e), s = new xt().set(t), c = new q(r.r, r.g, r.b), f = new q(s.r, s.g, s.b), h = Math.sqrt(Math.PI), m = h * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(c).add(f).multiplyScalar(h), this.sh.coefficients[1].copy(c).sub(f).multiplyScalar(m);
  }
}
class hI extends Vg {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const n = new xt().set(e);
    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const Dw = /* @__PURE__ */ new Qt(), Pw = /* @__PURE__ */ new Qt(), Fu = /* @__PURE__ */ new Qt();
class pI {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Vi(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Vi(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Fu.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, s = r * t.near / t.focus, c = t.near * Math.tan(nc * t.fov * 0.5) / t.zoom;
      let f, h;
      Pw.elements[12] = -r, Dw.elements[12] = r, f = -c * t.aspect + s, h = c * t.aspect + s, Fu.elements[0] = 2 * t.near / (h - f), Fu.elements[8] = (h + f) / (h - f), this.cameraL.projectionMatrix.copy(Fu), f = -c * t.aspect - s, h = c * t.aspect - s, Fu.elements[0] = 2 * t.near / (h - f), Fu.elements[8] = (h + f) / (h - f), this.cameraR.projectionMatrix.copy(Fu);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Pw), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Dw);
  }
}
class bS {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Nw(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = Nw();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function Nw() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Bu = /* @__PURE__ */ new q(), zw = /* @__PURE__ */ new mr(), mI = /* @__PURE__ */ new q(), Hu = /* @__PURE__ */ new q();
class vI extends xn {
  constructor() {
    super(), this.type = "AudioListener", this.context = MS.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new bS();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Bu, zw, mI), Hu.set(0, 0, -1).applyQuaternion(zw), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Bu.x, r), t.positionY.linearRampToValueAtTime(Bu.y, r), t.positionZ.linearRampToValueAtTime(Bu.z, r), t.forwardX.linearRampToValueAtTime(Hu.x, r), t.forwardY.linearRampToValueAtTime(Hu.y, r), t.forwardZ.linearRampToValueAtTime(Hu.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r);
    } else
      t.setPosition(Bu.x, Bu.y, Bu.z), t.setOrientation(Hu.x, Hu.y, Hu.z, n.x, n.y, n.z);
  }
}
class gC extends xn {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const ku = /* @__PURE__ */ new q(), Ow = /* @__PURE__ */ new mr(), gI = /* @__PURE__ */ new q(), Vu = /* @__PURE__ */ new q();
class yI extends gC {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(ku, Ow, gI), Vu.set(0, 0, 1).applyQuaternion(Ow);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(ku.x, n), t.positionY.linearRampToValueAtTime(ku.y, n), t.positionZ.linearRampToValueAtTime(ku.z, n), t.orientationX.linearRampToValueAtTime(Vu.x, n), t.orientationY.linearRampToValueAtTime(Vu.y, n), t.orientationZ.linearRampToValueAtTime(Vu.z, n);
    } else
      t.setPosition(ku.x, ku.y, ku.z), t.setOrientation(Vu.x, Vu.y, Vu.z);
  }
}
class _I {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class yC {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let r, s, c;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, c = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, c = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, c = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = c, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, r = this.valueSize, s = e * r + r;
    let c = this.cumulativeWeight;
    if (c === 0) {
      for (let f = 0; f !== r; ++f)
        n[s + f] = n[f];
      c = t;
    } else {
      c += t;
      const f = t / c;
      this._mixBufferRegion(n, s, 0, f, r);
    }
    this.cumulativeWeight = c;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, r = e * t + t, s = this.cumulativeWeight, c = this.cumulativeWeightAdditive, f = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const h = t * this._origIndex;
      this._mixBufferRegion(
        n,
        r,
        h,
        1 - s,
        t
      );
    }
    c > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
    for (let h = t, m = t + t; h !== m; ++h)
      if (n[h] !== n[h + t]) {
        f.setValue(n, r);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex;
    e.getValue(t, r);
    for (let s = n, c = r; s !== c; ++s)
      t[s] = t[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, r, s) {
    if (r >= 0.5)
      for (let c = 0; c !== s; ++c)
        e[t + c] = e[n + c];
  }
  _slerp(e, t, n, r) {
    mr.slerpFlat(e, t, e, t, e, n, r);
  }
  _slerpAdditive(e, t, n, r, s) {
    const c = this._workIndex * s;
    mr.multiplyQuaternionsFlat(e, c, e, t, e, n), mr.slerpFlat(e, t, e, t, e, c, r);
  }
  _lerp(e, t, n, r, s) {
    const c = 1 - r;
    for (let f = 0; f !== s; ++f) {
      const h = t + f;
      e[h] = e[h] * c + e[n + f] * r;
    }
  }
  _lerpAdditive(e, t, n, r, s) {
    for (let c = 0; c !== s; ++c) {
      const f = t + c;
      e[f] = e[f] + e[n + c] * r;
    }
  }
}
const wS = "\\[\\]\\.:\\/", xI = new RegExp("[" + wS + "]", "g"), ES = "[^" + wS + "]", SI = "[^" + wS.replace("\\.", "") + "]", MI = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", ES), bI = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", SI), wI = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ES), EI = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ES), TI = new RegExp(
  "^" + MI + bI + wI + EI + "$"
), CI = ["material", "materials", "bones", "map"];
class RI {
  constructor(e, t, n) {
    const r = n || vn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)
      n[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class vn {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || vn.parseTrackName(t), this.node = vn.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new vn.Composite(e, t, n) : new vn(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(xI, "");
  }
  static parseTrackName(e) {
    const t = TI.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      CI.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(s) {
        for (let c = 0; c < s.length; c++) {
          const f = s[c];
          if (f.name === t || f.uuid === t)
            return f;
          const h = n(f.children);
          if (h)
            return h;
        }
        return null;
      }, r = n(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      e[t++] = n[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = vn.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (n) {
      let m = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let g = 0; g < e.length; g++)
            if (e[g].name === m) {
              m = g;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (m !== void 0) {
        if (e[m] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[m];
      }
    }
    const c = e[r];
    if (c === void 0) {
      const m = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + m + "." + r + " but it wasn't found.", e);
      return;
    }
    let f = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? f = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (f = this.Versioning.MatrixWorldNeedsUpdate);
    let h = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      h = this.BindingType.ArrayElement, this.resolvedProperty = c, this.propertyIndex = s;
    } else
      c.fromArray !== void 0 && c.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = c) : Array.isArray(c) ? (h = this.BindingType.EntireArray, this.resolvedProperty = c) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][f];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
vn.Composite = RI;
vn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
vn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
vn.prototype.GetterByBindingType = [
  vn.prototype._getValue_direct,
  vn.prototype._getValue_array,
  vn.prototype._getValue_arrayElement,
  vn.prototype._getValue_toArray
];
vn.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    vn.prototype._setValue_direct,
    vn.prototype._setValue_direct_setNeedsUpdate,
    vn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    vn.prototype._setValue_array,
    vn.prototype._setValue_array_setNeedsUpdate,
    vn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    vn.prototype._setValue_arrayElement,
    vn.prototype._setValue_arrayElement_setNeedsUpdate,
    vn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    vn.prototype._setValue_fromArray,
    vn.prototype._setValue_fromArray_setNeedsUpdate,
    vn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AI {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = va(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, r = arguments.length; n !== r; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, s = this._bindings, c = s.length;
    let f, h = e.length, m = this.nCachedObjects_;
    for (let g = 0, _ = arguments.length; g !== _; ++g) {
      const x = arguments[g], M = x.uuid;
      let b = t[M];
      if (b === void 0) {
        b = h++, t[M] = b, e.push(x);
        for (let E = 0, w = c; E !== w; ++E)
          s[E].push(new vn(x, n[E], r[E]));
      } else if (b < m) {
        f = e[b];
        const E = --m, w = e[E];
        t[w.uuid] = b, e[b] = w, t[M] = E, e[E] = x;
        for (let R = 0, A = c; R !== A; ++R) {
          const P = s[R], N = P[E];
          let I = P[b];
          P[b] = N, I === void 0 && (I = new vn(x, n[R], r[R])), P[E] = I;
        }
      } else
        e[b] !== f && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = m;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_;
    for (let c = 0, f = arguments.length; c !== f; ++c) {
      const h = arguments[c], m = h.uuid, g = t[m];
      if (g !== void 0 && g >= s) {
        const _ = s++, x = e[_];
        t[x.uuid] = g, e[g] = x, t[m] = _, e[_] = h;
        for (let M = 0, b = r; M !== b; ++M) {
          const E = n[M], w = E[_], R = E[g];
          E[g] = w, E[_] = R;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_, c = e.length;
    for (let f = 0, h = arguments.length; f !== h; ++f) {
      const m = arguments[f], g = m.uuid, _ = t[g];
      if (_ !== void 0)
        if (delete t[g], _ < s) {
          const x = --s, M = e[x], b = --c, E = e[b];
          t[M.uuid] = _, e[_] = M, t[E.uuid] = x, e[x] = E, e.pop();
          for (let w = 0, R = r; w !== R; ++w) {
            const A = n[w], P = A[x], N = A[b];
            A[_] = P, A[x] = N, A.pop();
          }
        } else {
          const x = --c, M = e[x];
          x > 0 && (t[M.uuid] = _), e[_] = M, e.pop();
          for (let b = 0, E = r; b !== E; ++b) {
            const w = n[b];
            w[_] = w[x], w.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let r = n[e];
    const s = this._bindings;
    if (r !== void 0)
      return s[r];
    const c = this._paths, f = this._parsedPaths, h = this._objects, m = h.length, g = this.nCachedObjects_, _ = new Array(m);
    r = s.length, n[e] = r, c.push(e), f.push(t), s.push(_);
    for (let x = g, M = h.length; x !== M; ++x) {
      const b = h[x];
      _[x] = new vn(b, e, t);
    }
    return _;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const r = this._paths, s = this._parsedPaths, c = this._bindings, f = c.length - 1, h = c[f], m = e[f];
      t[m] = n, c[n] = h, c.pop(), s[n] = s[f], s.pop(), r[n] = r[f], r.pop();
    }
  }
}
class LI {
  constructor(e, t, n = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
    const s = t.tracks, c = s.length, f = new Array(c), h = {
      endingStart: Zu,
      endingEnd: Zu
    };
    for (let m = 0; m !== c; ++m) {
      const g = s[m].createInterpolant(null);
      f[m] = g, g.settings = h;
    }
    this._interpolantSettings = h, this._interpolants = f, this._propertyBindings = new Array(c), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = uT, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const r = this._clip.duration, s = e._clip.duration, c = s / r, f = r / s;
      e.warp(1, c, t), this.warp(f, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const r = this._mixer, s = r.time, c = this.timeScale;
    let f = this._timeScaleInterpolant;
    f === null && (f = r._lendControlInterpolant(), this._timeScaleInterpolant = f);
    const h = f.parameterPositions, m = f.sampleValues;
    return h[0] = s, h[1] = s + n, m[0] = e / c, m[1] = t / c, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const h = (e - s) * n;
      h < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * h);
    }
    t *= this._updateTimeScale(e);
    const c = this._updateTime(t), f = this._updateWeight(e);
    if (f > 0) {
      const h = this._interpolants, m = this._propertyBindings;
      switch (this.blendMode) {
        case Qx:
          for (let g = 0, _ = h.length; g !== _; ++g)
            h[g].evaluate(c), m[g].accumulateAdditive(f);
          break;
        case Dg:
        default:
          for (let g = 0, _ = h.length; g !== _; ++g)
            h[g].evaluate(c), m[g].accumulate(r, f);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let r = this.time + e, s = this._loopCount;
    const c = n === cT;
    if (e === 0)
      return s === -1 ? r : c && (s & 1) === 1 ? t - r : r;
    if (n === lT) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, c)) : this._setEndings(this.repetitions === 0, !0, c)), r >= t || r < 0) {
        const f = Math.floor(r / t);
        r -= t * f, s += Math.abs(f);
        const h = this.repetitions - s;
        if (h <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (h === 1) {
            const m = e < 0;
            this._setEndings(m, !m, c);
          } else
            this._setEndings(!1, !1, c);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: f
          });
        }
      } else
        this.time = r;
      if (c && (s & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, n) {
    const r = this._interpolantSettings;
    n ? (r.endingStart = Ju, r.endingEnd = Ju) : (e ? r.endingStart = this.zeroSlopeAtStart ? Ju : Zu : r.endingStart = ip, t ? r.endingEnd = this.zeroSlopeAtEnd ? Ju : Zu : r.endingEnd = ip);
  }
  _scheduleFading(e, t, n) {
    const r = this._mixer, s = r.time;
    let c = this._weightInterpolant;
    c === null && (c = r._lendControlInterpolant(), this._weightInterpolant = c);
    const f = c.parameterPositions, h = c.sampleValues;
    return f[0] = s, h[0] = t, f[1] = s + e, h[1] = n, this;
  }
}
const DI = new Float32Array(1);
class PI extends ks {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, r = e._clip.tracks, s = r.length, c = e._propertyBindings, f = e._interpolants, h = n.uuid, m = this._bindingsByRootAndName;
    let g = m[h];
    g === void 0 && (g = {}, m[h] = g);
    for (let _ = 0; _ !== s; ++_) {
      const x = r[_], M = x.name;
      let b = g[M];
      if (b !== void 0)
        ++b.referenceCount, c[_] = b;
      else {
        if (b = c[_], b !== void 0) {
          b._cacheIndex === null && (++b.referenceCount, this._addInactiveBinding(b, h, M));
          continue;
        }
        const E = t && t._propertyBindings[_].binding.parsedPath;
        b = new yC(
          vn.create(n, M, E),
          x.ValueTypeName,
          x.getValueSize()
        ), ++b.referenceCount, this._addInactiveBinding(b, h, M), c[_] = b;
      }
      f[_].resultBuffer = b.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, r, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const r = this._actions, s = this._actionsByClip;
    let c = s[t];
    if (c === void 0)
      c = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = c;
    else {
      const f = c.knownActions;
      e._byClipCacheIndex = f.length, f.push(e);
    }
    e._cacheIndex = r.length, r.push(e), c.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], r = e._cacheIndex;
    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, c = this._actionsByClip, f = c[s], h = f.knownActions, m = h[h.length - 1], g = e._byClipCacheIndex;
    m._byClipCacheIndex = g, h[g] = m, h.pop(), e._byClipCacheIndex = null;
    const _ = f.actionByRoot, x = (e._localRoot || this._root).uuid;
    delete _[x], h.length === 0 && delete c[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const s = t[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let c = r[t];
    c === void 0 && (c = {}, r[t] = c), c[n] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, r = n.rootNode.uuid, s = n.path, c = this._bindingsByRootAndName, f = c[r], h = t[t.length - 1], m = e._cacheIndex;
    h._cacheIndex = m, t[m] = h, t.pop(), delete f[s], Object.keys(f).length === 0 && delete c[r];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new yS(
      new Float32Array(2),
      new Float32Array(2),
      1,
      DI
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = n, t[n] = s;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const r = t || this._root, s = r.uuid;
    let c = typeof e == "string" ? hp.findByName(r, e) : e;
    const f = c !== null ? c.uuid : e, h = this._actionsByClip[f];
    let m = null;
    if (n === void 0 && (c !== null ? n = c.blendMode : n = Dg), h !== void 0) {
      const _ = h.actionByRoot[s];
      if (_ !== void 0 && _.blendMode === n)
        return _;
      m = h.knownActions[0], c === null && (c = m._clip);
    }
    if (c === null)
      return null;
    const g = new LI(this, c, t, n);
    return this._bindAction(g, m), this._addInactiveAction(g, f, s), g;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, r = n.uuid, s = typeof e == "string" ? hp.findByName(n, e) : e, c = s ? s.uuid : e, f = this._actionsByClip[c];
    return f !== void 0 && f.actionByRoot[r] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, r = this.time += e, s = Math.sign(e), c = this._accuIndex ^= 1;
    for (let m = 0; m !== n; ++m)
      t[m]._update(r, e, s, c);
    const f = this._bindings, h = this._nActiveBindings;
    for (let m = 0; m !== h; ++m)
      f[m].apply(c);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, r = this._actionsByClip, s = r[n];
    if (s !== void 0) {
      const c = s.knownActions;
      for (let f = 0, h = c.length; f !== h; ++f) {
        const m = c[f];
        this._deactivateAction(m);
        const g = m._cacheIndex, _ = t[t.length - 1];
        m._cacheIndex = null, m._byClipCacheIndex = null, _._cacheIndex = g, t[g] = _, t.pop(), this._removeInactiveBindingsForAction(m);
      }
      delete r[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const c in n) {
      const f = n[c].actionByRoot, h = f[t];
      h !== void 0 && (this._deactivateAction(h), this._removeInactiveAction(h));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0)
      for (const c in s) {
        const f = s[c];
        f.restoreOriginalState(), this._removeInactiveBinding(f);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class TS {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new TS(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let NI = 0;
class zI extends ks {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: NI++ }), this.name = "", this.usage = rp, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, r = t.length; n < r; n++)
      this.uniforms.push(t[n].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class OI extends Ug {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class II {
  constructor(e, t, n, r, s) {
    this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class _C {
  constructor(e, t, n = 0, r = 1 / 0) {
    this.ray = new gp(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new rc(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return Fx(e, this, n, t), n.sort(Iw), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let r = 0, s = e.length; r < s; r++)
      Fx(e[r], this, n, t);
    return n.sort(Iw), n;
  }
}
function Iw(u, e) {
  return u.distance - e.distance;
}
function Fx(u, e, t, n) {
  if (u.layers.test(e.layers) && u.raycast(e, t), n === !0) {
    const r = u.children;
    for (let s = 0, c = r.length; s < c; s++)
      Fx(r[s], e, t, !0);
  }
}
class Bx {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(gi(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class UI {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Uw = /* @__PURE__ */ new Ue();
class FI {
  constructor(e = new Ue(1 / 0, 1 / 0), t = new Ue(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Uw.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Uw.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Fw = /* @__PURE__ */ new q(), ng = /* @__PURE__ */ new q();
class BI {
  constructor(e = new q(), t = new q()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Fw.subVectors(e, this.start), ng.subVectors(this.end, this.start);
    const n = ng.dot(ng);
    let s = ng.dot(Fw) / n;
    return t && (s = gi(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, n) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Bw = /* @__PURE__ */ new q();
class HI extends xn {
  constructor(e, t) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
    const n = new Kt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let c = 0, f = 1, h = 32; c < h; c++, f++) {
      const m = c / h * Math.PI * 2, g = f / h * Math.PI * 2;
      r.push(
        Math.cos(m),
        Math.sin(m),
        1,
        Math.cos(g),
        Math.sin(g),
        1
      );
    }
    n.setAttribute("position", new Rt(r, 3));
    const s = new Dr({ fog: !1, toneMapped: !1 });
    this.cone = new Vs(n, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), Bw.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Bw), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Dl = /* @__PURE__ */ new q(), ig = /* @__PURE__ */ new Qt(), F_ = /* @__PURE__ */ new Qt();
class kI extends Vs {
  constructor(e) {
    const t = xC(e), n = new Kt(), r = [], s = [], c = new xt(0, 0, 1), f = new xt(0, 1, 0);
    for (let m = 0; m < t.length; m++) {
      const g = t[m];
      g.parent && g.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(c.r, c.g, c.b), s.push(f.r, f.g, f.b));
    }
    n.setAttribute("position", new Rt(r, 3)), n.setAttribute("color", new Rt(s, 3));
    const h = new Dr({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, h), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, r = n.getAttribute("position");
    F_.copy(this.root.matrixWorld).invert();
    for (let s = 0, c = 0; s < t.length; s++) {
      const f = t[s];
      f.parent && f.parent.isBone && (ig.multiplyMatrices(F_, f.matrixWorld), Dl.setFromMatrixPosition(ig), r.setXYZ(c, Dl.x, Dl.y, Dl.z), ig.multiplyMatrices(F_, f.parent.matrixWorld), Dl.setFromMatrixPosition(ig), r.setXYZ(c + 1, Dl.x, Dl.y, Dl.z), c += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function xC(u) {
  const e = [];
  u.isBone === !0 && e.push(u);
  for (let t = 0; t < u.children.length; t++)
    e.push.apply(e, xC(u.children[t]));
  return e;
}
class VI extends Qi {
  constructor(e, t, n) {
    const r = new fd(t, 4, 2), s = new Wl({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const GI = /* @__PURE__ */ new q(), Hw = /* @__PURE__ */ new xt(), kw = /* @__PURE__ */ new xt();
class WI extends xn {
  constructor(e, t, n) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
    const r = new cd(t);
    r.rotateY(Math.PI * 0.5), this.material = new Wl({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"), c = new Float32Array(s.count * 3);
    r.setAttribute("color", new Fn(c, 3)), this.add(new Qi(r, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      Hw.copy(this.light.color), kw.copy(this.light.groundColor);
      for (let n = 0, r = t.count; n < r; n++) {
        const s = n < r / 2 ? Hw : kw;
        t.setXYZ(n, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    e.lookAt(GI.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class qI extends Vs {
  constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
    n = new xt(n), r = new xt(r);
    const s = t / 2, c = e / t, f = e / 2, h = [], m = [];
    for (let x = 0, M = 0, b = -f; x <= t; x++, b += c) {
      h.push(-f, 0, b, f, 0, b), h.push(b, 0, -f, b, 0, f);
      const E = x === s ? n : r;
      E.toArray(m, M), M += 3, E.toArray(m, M), M += 3, E.toArray(m, M), M += 3, E.toArray(m, M), M += 3;
    }
    const g = new Kt();
    g.setAttribute("position", new Rt(h, 3)), g.setAttribute("color", new Rt(m, 3));
    const _ = new Dr({ vertexColors: !0, toneMapped: !1 });
    super(g, _), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class jI extends Vs {
  constructor(e = 10, t = 16, n = 8, r = 64, s = 4473924, c = 8947848) {
    s = new xt(s), c = new xt(c);
    const f = [], h = [];
    if (t > 1)
      for (let _ = 0; _ < t; _++) {
        const x = _ / t * (Math.PI * 2), M = Math.sin(x) * e, b = Math.cos(x) * e;
        f.push(0, 0, 0), f.push(M, 0, b);
        const E = _ & 1 ? s : c;
        h.push(E.r, E.g, E.b), h.push(E.r, E.g, E.b);
      }
    for (let _ = 0; _ < n; _++) {
      const x = _ & 1 ? s : c, M = e - e / n * _;
      for (let b = 0; b < r; b++) {
        let E = b / r * (Math.PI * 2), w = Math.sin(E) * M, R = Math.cos(E) * M;
        f.push(w, 0, R), h.push(x.r, x.g, x.b), E = (b + 1) / r * (Math.PI * 2), w = Math.sin(E) * M, R = Math.cos(E) * M, f.push(w, 0, R), h.push(x.r, x.g, x.b);
      }
    }
    const m = new Kt();
    m.setAttribute("position", new Rt(f, 3)), m.setAttribute("color", new Rt(h, 3));
    const g = new Dr({ vertexColors: !0, toneMapped: !1 });
    super(m, g), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Vw = /* @__PURE__ */ new q(), rg = /* @__PURE__ */ new q(), Gw = /* @__PURE__ */ new q();
class YI extends xn {
  constructor(e, t, n) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, t === void 0 && (t = 1);
    let r = new Kt();
    r.setAttribute("position", new Rt([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const s = new Dr({ fog: !1, toneMapped: !1 });
    this.lightPlane = new kl(r, s), this.add(this.lightPlane), r = new Kt(), r.setAttribute("position", new Rt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new kl(r, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    Vw.setFromMatrixPosition(this.light.matrixWorld), rg.setFromMatrixPosition(this.light.target.matrixWorld), Gw.subVectors(rg, Vw), this.lightPlane.lookAt(rg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(rg), this.targetLine.scale.z = Gw.length();
  }
}
const ag = /* @__PURE__ */ new q(), ai = /* @__PURE__ */ new yp();
class XI extends Vs {
  constructor(e) {
    const t = new Kt(), n = new Dr({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], c = {};
    f("n1", "n2"), f("n2", "n4"), f("n4", "n3"), f("n3", "n1"), f("f1", "f2"), f("f2", "f4"), f("f4", "f3"), f("f3", "f1"), f("n1", "f1"), f("n2", "f2"), f("n3", "f3"), f("n4", "f4"), f("p", "n1"), f("p", "n2"), f("p", "n3"), f("p", "n4"), f("u1", "u2"), f("u2", "u3"), f("u3", "u1"), f("c", "t"), f("p", "c"), f("cn1", "cn2"), f("cn3", "cn4"), f("cf1", "cf2"), f("cf3", "cf4");
    function f(b, E) {
      h(b), h(E);
    }
    function h(b) {
      r.push(0, 0, 0), s.push(0, 0, 0), c[b] === void 0 && (c[b] = []), c[b].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Rt(r, 3)), t.setAttribute("color", new Rt(s, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = c, this.update();
    const m = new xt(16755200), g = new xt(16711680), _ = new xt(43775), x = new xt(16777215), M = new xt(3355443);
    this.setColors(m, g, _, x, M);
  }
  setColors(e, t, n, r, s) {
    const f = this.geometry.getAttribute("color");
    f.setXYZ(0, e.r, e.g, e.b), f.setXYZ(1, e.r, e.g, e.b), f.setXYZ(2, e.r, e.g, e.b), f.setXYZ(3, e.r, e.g, e.b), f.setXYZ(4, e.r, e.g, e.b), f.setXYZ(5, e.r, e.g, e.b), f.setXYZ(6, e.r, e.g, e.b), f.setXYZ(7, e.r, e.g, e.b), f.setXYZ(8, e.r, e.g, e.b), f.setXYZ(9, e.r, e.g, e.b), f.setXYZ(10, e.r, e.g, e.b), f.setXYZ(11, e.r, e.g, e.b), f.setXYZ(12, e.r, e.g, e.b), f.setXYZ(13, e.r, e.g, e.b), f.setXYZ(14, e.r, e.g, e.b), f.setXYZ(15, e.r, e.g, e.b), f.setXYZ(16, e.r, e.g, e.b), f.setXYZ(17, e.r, e.g, e.b), f.setXYZ(18, e.r, e.g, e.b), f.setXYZ(19, e.r, e.g, e.b), f.setXYZ(20, e.r, e.g, e.b), f.setXYZ(21, e.r, e.g, e.b), f.setXYZ(22, e.r, e.g, e.b), f.setXYZ(23, e.r, e.g, e.b), f.setXYZ(24, t.r, t.g, t.b), f.setXYZ(25, t.r, t.g, t.b), f.setXYZ(26, t.r, t.g, t.b), f.setXYZ(27, t.r, t.g, t.b), f.setXYZ(28, t.r, t.g, t.b), f.setXYZ(29, t.r, t.g, t.b), f.setXYZ(30, t.r, t.g, t.b), f.setXYZ(31, t.r, t.g, t.b), f.setXYZ(32, n.r, n.g, n.b), f.setXYZ(33, n.r, n.g, n.b), f.setXYZ(34, n.r, n.g, n.b), f.setXYZ(35, n.r, n.g, n.b), f.setXYZ(36, n.r, n.g, n.b), f.setXYZ(37, n.r, n.g, n.b), f.setXYZ(38, r.r, r.g, r.b), f.setXYZ(39, r.r, r.g, r.b), f.setXYZ(40, s.r, s.g, s.b), f.setXYZ(41, s.r, s.g, s.b), f.setXYZ(42, s.r, s.g, s.b), f.setXYZ(43, s.r, s.g, s.b), f.setXYZ(44, s.r, s.g, s.b), f.setXYZ(45, s.r, s.g, s.b), f.setXYZ(46, s.r, s.g, s.b), f.setXYZ(47, s.r, s.g, s.b), f.setXYZ(48, s.r, s.g, s.b), f.setXYZ(49, s.r, s.g, s.b), f.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, r = 1;
    ai.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), mi("c", t, e, ai, 0, 0, -1), mi("t", t, e, ai, 0, 0, 1), mi("n1", t, e, ai, -n, -r, -1), mi("n2", t, e, ai, n, -r, -1), mi("n3", t, e, ai, -n, r, -1), mi("n4", t, e, ai, n, r, -1), mi("f1", t, e, ai, -n, -r, 1), mi("f2", t, e, ai, n, -r, 1), mi("f3", t, e, ai, -n, r, 1), mi("f4", t, e, ai, n, r, 1), mi("u1", t, e, ai, n * 0.7, r * 1.1, -1), mi("u2", t, e, ai, -n * 0.7, r * 1.1, -1), mi("u3", t, e, ai, 0, r * 2, -1), mi("cf1", t, e, ai, -n, 0, 1), mi("cf2", t, e, ai, n, 0, 1), mi("cf3", t, e, ai, 0, -r, 1), mi("cf4", t, e, ai, 0, r, 1), mi("cn1", t, e, ai, -n, 0, -1), mi("cn2", t, e, ai, n, 0, -1), mi("cn3", t, e, ai, 0, -r, -1), mi("cn4", t, e, ai, 0, r, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function mi(u, e, t, n, r, s, c) {
  ag.set(r, s, c).unproject(n);
  const f = e[u];
  if (f !== void 0) {
    const h = t.getAttribute("position");
    for (let m = 0, g = f.length; m < g; m++)
      h.setXYZ(f[m], ag.x, ag.y, ag.z);
  }
}
const sg = /* @__PURE__ */ new fc();
class ZI extends Vs {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new Kt();
    s.setIndex(new Fn(n, 1)), s.setAttribute("position", new Fn(r, 3)), super(s, new Dr({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && sg.setFromObject(this.object), sg.isEmpty())
      return;
    const t = sg.min, n = sg.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = t.x, s[4] = n.y, s[5] = n.z, s[6] = t.x, s[7] = t.y, s[8] = n.z, s[9] = n.x, s[10] = t.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = t.z, s[15] = t.x, s[16] = n.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = n.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class JI extends Vs {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new Kt();
    s.setIndex(new Fn(n, 1)), s.setAttribute("position", new Rt(r, 3)), super(s, new Dr({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class QI extends kl {
  constructor(e, t = 1, n = 16776960) {
    const r = n, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], c = new Kt();
    c.setAttribute("position", new Rt(s, 3)), c.computeBoundingSphere(), super(c, new Dr({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const f = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], h = new Kt();
    h.setAttribute("position", new Rt(f, 3)), h.computeBoundingSphere(), this.add(new Qi(h, new Wl({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Ww = /* @__PURE__ */ new q();
let og, B_;
class KI extends xn {
  // dir is assumed to be normalized
  constructor(e = new q(0, 0, 1), t = new q(0, 0, 0), n = 1, r = 16776960, s = n * 0.2, c = s * 0.2) {
    super(), this.type = "ArrowHelper", og === void 0 && (og = new Kt(), og.setAttribute("position", new Rt([0, 0, 0, 0, 1, 0], 3)), B_ = new hc(0, 0.5, 1, 5, 1), B_.translate(0, -0.5, 0)), this.position.copy(t), this.line = new kl(og, new Dr({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Qi(B_, new Wl({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, s, c);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      Ww.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Ww, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class $I extends Vs {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Kt();
    r.setAttribute("position", new Rt(t, 3)), r.setAttribute("color", new Rt(n, 3));
    const s = new Dr({ vertexColors: !0, toneMapped: !1 });
    super(r, s), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const r = new xt(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(n), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class eU {
  constructor() {
    this.type = "ShapePath", this.color = new xt(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new op(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, r) {
    return this.currentPath.quadraticCurveTo(e, t, n, r), this;
  }
  bezierCurveTo(e, t, n, r, s, c) {
    return this.currentPath.bezierCurveTo(e, t, n, r, s, c), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(R) {
      const A = [];
      for (let P = 0, N = R.length; P < N; P++) {
        const I = R[P], B = new ac();
        B.curves = I.curves, A.push(B);
      }
      return A;
    }
    function n(R, A) {
      const P = A.length;
      let N = !1;
      for (let I = P - 1, B = 0; B < P; I = B++) {
        let W = A[I], z = A[B], k = z.x - W.x, G = z.y - W.y;
        if (Math.abs(G) > Number.EPSILON) {
          if (G < 0 && (W = A[B], k = -k, z = A[I], G = -G), R.y < W.y || R.y > z.y)
            continue;
          if (R.y === W.y) {
            if (R.x === W.x)
              return !0;
          } else {
            const $ = G * (R.x - W.x) - k * (R.y - W.y);
            if ($ === 0)
              return !0;
            if ($ < 0)
              continue;
            N = !N;
          }
        } else {
          if (R.y !== W.y)
            continue;
          if (z.x <= R.x && R.x <= W.x || W.x <= R.x && R.x <= z.x)
            return !0;
        }
      }
      return N;
    }
    const r = Bs.isClockWise, s = this.subPaths;
    if (s.length === 0)
      return [];
    let c, f, h;
    const m = [];
    if (s.length === 1)
      return f = s[0], h = new ac(), h.curves = f.curves, m.push(h), m;
    let g = !r(s[0].getPoints());
    g = e ? !g : g;
    const _ = [], x = [];
    let M = [], b = 0, E;
    x[b] = void 0, M[b] = [];
    for (let R = 0, A = s.length; R < A; R++)
      f = s[R], E = f.getPoints(), c = r(E), c = e ? !c : c, c ? (!g && x[b] && b++, x[b] = { s: new ac(), p: E }, x[b].s.curves = f.curves, g && b++, M[b] = []) : M[b].push({ h: f, p: E[0] });
    if (!x[0])
      return t(s);
    if (x.length > 1) {
      let R = !1, A = 0;
      for (let P = 0, N = x.length; P < N; P++)
        _[P] = [];
      for (let P = 0, N = x.length; P < N; P++) {
        const I = M[P];
        for (let B = 0; B < I.length; B++) {
          const W = I[B];
          let z = !0;
          for (let k = 0; k < x.length; k++)
            n(W.p, x[k].p) && (P !== k && A++, z ? (z = !1, _[k].push(W)) : R = !0);
          z && _[P].push(W);
        }
      }
      A > 0 && R === !1 && (M = _);
    }
    let w;
    for (let R = 0, A = x.length; R < A; R++) {
      h = x[R].s, m.push(h), w = M[R];
      for (let P = 0, N = w.length; P < N; P++)
        h.holes.push(w[P].h);
    }
    return m;
  }
}
const wo = /* @__PURE__ */ tU();
function tU() {
  const u = new ArrayBuffer(4), e = new Float32Array(u), t = new Uint32Array(u), n = new Uint32Array(512), r = new Uint32Array(512);
  for (let h = 0; h < 256; ++h) {
    const m = h - 127;
    m < -27 ? (n[h] = 0, n[h | 256] = 32768, r[h] = 24, r[h | 256] = 24) : m < -14 ? (n[h] = 1024 >> -m - 14, n[h | 256] = 1024 >> -m - 14 | 32768, r[h] = -m - 1, r[h | 256] = -m - 1) : m <= 15 ? (n[h] = m + 15 << 10, n[h | 256] = m + 15 << 10 | 32768, r[h] = 13, r[h | 256] = 13) : m < 128 ? (n[h] = 31744, n[h | 256] = 64512, r[h] = 24, r[h | 256] = 24) : (n[h] = 31744, n[h | 256] = 64512, r[h] = 13, r[h | 256] = 13);
  }
  const s = new Uint32Array(2048), c = new Uint32Array(64), f = new Uint32Array(64);
  for (let h = 1; h < 1024; ++h) {
    let m = h << 13, g = 0;
    for (; !(m & 8388608); )
      m <<= 1, g -= 8388608;
    m &= -8388609, g += 947912704, s[h] = m | g;
  }
  for (let h = 1024; h < 2048; ++h)
    s[h] = 939524096 + (h - 1024 << 13);
  for (let h = 1; h < 31; ++h)
    c[h] = h << 23;
  c[31] = 1199570944, c[32] = 2147483648;
  for (let h = 33; h < 63; ++h)
    c[h] = 2147483648 + (h - 32 << 23);
  c[63] = 3347054592;
  for (let h = 1; h < 64; ++h)
    h !== 32 && (f[h] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: c,
    offsetTable: f
  };
}
function nU(u) {
  Math.abs(u) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), u = gi(u, -65504, 65504), wo.floatView[0] = u;
  const e = wo.uint32View[0], t = e >> 23 & 511;
  return wo.baseTable[t] + ((e & 8388607) >> wo.shiftTable[t]);
}
function iU(u) {
  const e = u >> 10;
  return wo.uint32View[0] = wo.mantissaTable[wo.offsetTable[e] + (u & 1023)] + wo.exponentTable[e], wo.floatView[0];
}
var rU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toHalfFloat: nU,
  fromHalfFloat: iU
});
function aU() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
class sU extends Wa {
  constructor(e, t, n) {
    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, n), this.samples = 4;
  }
}
class oU extends vp {
  constructor(e, t, n, r) {
    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, n, r);
  }
}
class lU extends Pg {
  constructor(e, t, n, r) {
    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, n, r);
  }
}
class uU extends ql {
  constructor(e, t, n, r, s, c) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, n, r, s, c);
  }
}
class cU extends Sp {
  constructor(e, t, n, r) {
    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, n, r);
  }
}
class fU extends Mp {
  constructor(e, t, n, r) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, n, r);
  }
}
class dU extends bp {
  constructor(e, t, n, r, s, c, f) {
    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, n, r, s, c, f);
  }
}
class hU extends hc {
  constructor(e, t, n, r, s, c, f, h) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, n, r, s, c, f, h);
  }
}
class pU extends wp {
  constructor(e, t) {
    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t);
  }
}
class mU extends Ep {
  constructor(e, t) {
    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t);
  }
}
class vU extends Tp {
  constructor(e, t) {
    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t);
  }
}
class gU extends ud {
  constructor(e, t, n, r) {
    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, n, r);
  }
}
class yU extends cd {
  constructor(e, t) {
    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t);
  }
}
class _U extends od {
  constructor(e, t, n, r) {
    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, n, r);
  }
}
class xU extends Lo {
  constructor(e, t, n, r) {
    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, n, r);
  }
}
class SU extends Cp {
  constructor(e, t, n, r, s, c) {
    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, n, r, s, c);
  }
}
class MU extends Rp {
  constructor(e, t) {
    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t);
  }
}
class bU extends fd {
  constructor(e, t, n, r, s, c, f) {
    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, n, r, s, c, f);
  }
}
class wU extends Ap {
  constructor(e, t) {
    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t);
  }
}
class EU extends Lp {
  constructor(e, t, n, r, s) {
    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, n, r, s);
  }
}
class TU extends Dp {
  constructor(e, t, n, r, s, c) {
    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, n, r, s, c);
  }
}
class CU extends Pp {
  constructor(e, t, n, r, s) {
    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, n, r, s);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Rg
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Rg);
const RU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: Xx,
  AddEquation: ju,
  AddOperation: VE,
  AdditiveAnimationBlendMode: Qx,
  AdditiveBlending: ix,
  AlphaFormat: KE,
  AlwaysDepth: OE,
  AlwaysStencilFunc: pT,
  AmbientLight: dC,
  AmbientLightProbe: hI,
  AnimationClip: hp,
  AnimationLoader: eI,
  AnimationMixer: PI,
  AnimationObjectGroup: AI,
  AnimationUtils: JO,
  ArcCurve: FT,
  ArrayCamera: CT,
  ArrowHelper: KI,
  Audio: gC,
  AudioAnalyser: _I,
  AudioContext: MS,
  AudioListener: vI,
  AudioLoader: fI,
  AxesHelper: $I,
  BackSide: ma,
  BasicDepthPacking: fT,
  BasicShadowMap: SE,
  Bone: oS,
  BooleanKeyframeTrack: pc,
  Box2: FI,
  Box3: fc,
  Box3Helper: JI,
  BoxBufferGeometry: uU,
  BoxGeometry: ql,
  BoxHelper: ZI,
  BufferAttribute: Fn,
  BufferGeometry: Kt,
  BufferGeometryLoader: vC,
  ByteType: YE,
  Cache: uc,
  Camera: yp,
  CameraHelper: XI,
  CanvasTexture: xO,
  CapsuleBufferGeometry: cU,
  CapsuleGeometry: Sp,
  CatmullRomCurve3: BT,
  CineonToneMapping: qE,
  CircleBufferGeometry: fU,
  CircleGeometry: Mp,
  ClampToEdgeWrapping: Lr,
  Clock: bS,
  Color: xt,
  ColorKeyframeTrack: _S,
  ColorManagement: ka,
  CompressedTexture: UT,
  CompressedTextureLoader: tI,
  ConeBufferGeometry: dU,
  ConeGeometry: bp,
  CubeCamera: _T,
  CubeReflectionMapping: Fl,
  CubeRefractionMapping: Bl,
  CubeTexture: _p,
  CubeTextureLoader: nI,
  CubeUVReflectionMapping: ad,
  CubicBezierCurve: cS,
  CubicBezierCurve3: HT,
  CubicInterpolant: rC,
  CullFaceBack: nx,
  CullFaceFront: xE,
  CullFaceFrontBack: T2,
  CullFaceNone: _E,
  Curve: hs,
  CurvePath: VT,
  CustomBlending: ME,
  CustomToneMapping: jE,
  CylinderBufferGeometry: hU,
  CylinderGeometry: hc,
  Cylindrical: UI,
  Data3DTexture: Pg,
  DataArrayTexture: vp,
  DataTexture: ed,
  DataTexture2DArray: oU,
  DataTexture3D: lU,
  DataTextureLoader: iI,
  DataUtils: rU,
  DecrementStencilOp: F2,
  DecrementWrapStencilOp: H2,
  DefaultLoadingManager: oC,
  DepthFormat: Ul,
  DepthStencilFormat: oc,
  DepthTexture: RT,
  DirectionalLight: fC,
  DirectionalLightHelper: YI,
  DiscreteInterpolant: aC,
  DodecahedronBufferGeometry: pU,
  DodecahedronGeometry: wp,
  DoubleSide: Fs,
  DstAlphaFactor: AE,
  DstColorFactor: DE,
  DynamicCopyUsage: tL,
  DynamicDrawUsage: Z2,
  DynamicReadUsage: K2,
  EdgesGeometry: GT,
  EllipseCurve: Bg,
  EqualDepth: UE,
  EqualStencilFunc: W2,
  EquirectangularReflectionMapping: Qh,
  EquirectangularRefractionMapping: Kh,
  Euler: sd,
  EventDispatcher: ks,
  ExtrudeBufferGeometry: mU,
  ExtrudeGeometry: Ep,
  FileLoader: Ao,
  Float16BufferAttribute: IL,
  Float32BufferAttribute: Rt,
  Float64BufferAttribute: UL,
  FloatType: Eo,
  Fog: Ig,
  FogExp2: Og,
  FramebufferTexture: _O,
  FrontSide: sc,
  Frustum: Ng,
  GLBufferAttribute: II,
  GLSL1: iL,
  GLSL3: Ax,
  GreaterDepth: BE,
  GreaterEqualDepth: FE,
  GreaterEqualStencilFunc: X2,
  GreaterStencilFunc: j2,
  GridHelper: qI,
  Group: Qf,
  HalfFloatType: td,
  HemisphereLight: lC,
  HemisphereLightHelper: WI,
  HemisphereLightProbe: dI,
  IcosahedronBufferGeometry: vU,
  IcosahedronGeometry: Tp,
  ImageBitmapLoader: cI,
  ImageLoader: pp,
  ImageUtils: $x,
  ImmediateRenderObject: aU,
  IncrementStencilOp: U2,
  IncrementWrapStencilOp: B2,
  InstancedBufferAttribute: id,
  InstancedBufferGeometry: mC,
  InstancedInterleavedBuffer: OI,
  InstancedMesh: zT,
  Int16BufferAttribute: zL,
  Int32BufferAttribute: OL,
  Int8BufferAttribute: DL,
  IntType: ZE,
  InterleavedBuffer: Ug,
  InterleavedBufferAttribute: lc,
  Interpolant: Np,
  InterpolateDiscrete: tp,
  InterpolateLinear: np,
  InterpolateSmooth: mg,
  InvertStencilOp: k2,
  KeepStencilOp: vg,
  KeyframeTrack: ps,
  LOD: PT,
  LatheBufferGeometry: gU,
  LatheGeometry: ud,
  Layers: rc,
  LessDepth: IE,
  LessEqualDepth: _g,
  LessEqualStencilFunc: q2,
  LessStencilFunc: G2,
  Light: jl,
  LightProbe: Vg,
  Line: kl,
  Line3: BI,
  LineBasicMaterial: Dr,
  LineCurve: Hg,
  LineCurve3: kT,
  LineDashedMaterial: nC,
  LineLoop: OT,
  LineSegments: Vs,
  LinearEncoding: Hl,
  LinearFilter: vi,
  LinearInterpolant: yS,
  LinearMipMapLinearFilter: L2,
  LinearMipMapNearestFilter: A2,
  LinearMipmapLinearFilter: cc,
  LinearMipmapNearestFilter: Zx,
  LinearSRGBColorSpace: Il,
  LinearToneMapping: GE,
  Loader: ga,
  LoaderUtils: Ux,
  LoadingManager: xS,
  LoopOnce: lT,
  LoopPingPong: cT,
  LoopRepeat: uT,
  LuminanceAlphaFormat: tT,
  LuminanceFormat: eT,
  MOUSE: Gu,
  Material: Ki,
  MaterialLoader: Gg,
  MathUtils: gL,
  Matrix3: Zr,
  Matrix4: Qt,
  MaxEquation: ox,
  Mesh: Qi,
  MeshBasicMaterial: Wl,
  MeshDepthMaterial: iS,
  MeshDistanceMaterial: rS,
  MeshLambertMaterial: eC,
  MeshMatcapMaterial: tC,
  MeshNormalMaterial: $T,
  MeshPhongMaterial: QT,
  MeshPhysicalMaterial: JT,
  MeshStandardMaterial: mS,
  MeshToonMaterial: KT,
  MinEquation: sx,
  MirroredRepeatWrapping: ep,
  MixOperation: kE,
  MultiplyBlending: ax,
  MultiplyOperation: mp,
  NearestFilter: Si,
  NearestMipMapLinearFilter: R2,
  NearestMipMapNearestFilter: C2,
  NearestMipmapLinearFilter: Sg,
  NearestMipmapNearestFilter: xg,
  NeverDepth: zE,
  NeverStencilFunc: V2,
  NoBlending: Co,
  NoColorSpace: z2,
  NoToneMapping: ds,
  NormalAnimationBlendMode: Dg,
  NormalBlending: ec,
  NotEqualDepth: HE,
  NotEqualStencilFunc: Y2,
  NumberKeyframeTrack: fp,
  Object3D: xn,
  ObjectLoader: lI,
  ObjectSpaceNormalMap: hT,
  OctahedronBufferGeometry: yU,
  OctahedronGeometry: cd,
  OneFactor: TE,
  OneMinusDstAlphaFactor: LE,
  OneMinusDstColorFactor: PE,
  OneMinusSrcAlphaFactor: Yx,
  OneMinusSrcColorFactor: RE,
  OrthographicCamera: xp,
  PCFShadowMap: Ag,
  PCFSoftShadowMap: Yh,
  PMREMGenerator: Dx,
  Path: op,
  PerspectiveCamera: Vi,
  Plane: zl,
  PlaneBufferGeometry: _U,
  PlaneGeometry: od,
  PlaneHelper: QI,
  PointLight: cC,
  PointLightHelper: VI,
  Points: IT,
  PointsMaterial: lS,
  PolarGridHelper: jI,
  PolyhedronBufferGeometry: xU,
  PolyhedronGeometry: Lo,
  PositionalAudio: yI,
  PropertyBinding: vn,
  PropertyMixer: yC,
  QuadraticBezierCurve: fS,
  QuadraticBezierCurve3: dS,
  Quaternion: mr,
  QuaternionKeyframeTrack: dd,
  QuaternionLinearInterpolant: sC,
  REVISION: Rg,
  RGBADepthPacking: dT,
  RGBAFormat: pa,
  RGBAIntegerFormat: sT,
  RGBA_ASTC_10x10_Format: Ex,
  RGBA_ASTC_10x5_Format: Mx,
  RGBA_ASTC_10x6_Format: bx,
  RGBA_ASTC_10x8_Format: wx,
  RGBA_ASTC_12x10_Format: Tx,
  RGBA_ASTC_12x12_Format: Cx,
  RGBA_ASTC_4x4_Format: px,
  RGBA_ASTC_5x4_Format: mx,
  RGBA_ASTC_5x5_Format: vx,
  RGBA_ASTC_6x5_Format: gx,
  RGBA_ASTC_6x6_Format: yx,
  RGBA_ASTC_8x5_Format: _x,
  RGBA_ASTC_8x6_Format: xx,
  RGBA_ASTC_8x8_Format: Sx,
  RGBA_BPTC_Format: Rx,
  RGBA_ETC2_EAC_Format: hx,
  RGBA_PVRTC_2BPPV1_Format: fx,
  RGBA_PVRTC_4BPPV1_Format: cx,
  RGBA_S3TC_DXT1_Format: dg,
  RGBA_S3TC_DXT3_Format: hg,
  RGBA_S3TC_DXT5_Format: pg,
  RGBFormat: $E,
  RGB_ETC1_Format: oT,
  RGB_ETC2_Format: dx,
  RGB_PVRTC_2BPPV1_Format: ux,
  RGB_PVRTC_4BPPV1_Format: lx,
  RGB_S3TC_DXT1_Format: fg,
  RGFormat: rT,
  RGIntegerFormat: aT,
  RawShaderMaterial: ZT,
  Ray: gp,
  Raycaster: _C,
  RectAreaLight: hC,
  RedFormat: nT,
  RedIntegerFormat: iT,
  ReinhardToneMapping: WE,
  RepeatWrapping: $h,
  ReplaceStencilOp: I2,
  ReverseSubtractEquation: wE,
  RingBufferGeometry: SU,
  RingGeometry: Cp,
  SRGBColorSpace: Is,
  Scene: wg,
  ShaderChunk: nn,
  ShaderLib: fs,
  ShaderMaterial: Hs,
  ShadowMaterial: XT,
  Shape: ac,
  ShapeBufferGeometry: MU,
  ShapeGeometry: Rp,
  ShapePath: eU,
  ShapeUtils: Bs,
  ShortType: XE,
  Skeleton: Fg,
  SkeletonHelper: kI,
  SkinnedMesh: NT,
  Source: Qu,
  Sphere: dc,
  SphereBufferGeometry: bU,
  SphereGeometry: fd,
  Spherical: Bx,
  SphericalHarmonics3: pC,
  SplineCurve: hS,
  SpotLight: uC,
  SpotLightHelper: HI,
  Sprite: DT,
  SpriteMaterial: sS,
  SrcAlphaFactor: jx,
  SrcAlphaSaturateFactor: NE,
  SrcColorFactor: CE,
  StaticCopyUsage: eL,
  StaticDrawUsage: rp,
  StaticReadUsage: Q2,
  StereoCamera: pI,
  StreamCopyUsage: nL,
  StreamDrawUsage: J2,
  StreamReadUsage: $2,
  StringKeyframeTrack: mc,
  SubtractEquation: bE,
  SubtractiveBlending: rx,
  TOUCH: Wu,
  TangentSpaceNormalMap: Gl,
  TetrahedronBufferGeometry: wU,
  TetrahedronGeometry: Ap,
  Texture: Mi,
  TextureLoader: rI,
  TorusBufferGeometry: EU,
  TorusGeometry: Lp,
  TorusKnotBufferGeometry: TU,
  TorusKnotGeometry: Dp,
  Triangle: Ga,
  TriangleFanDrawMode: N2,
  TriangleStripDrawMode: P2,
  TrianglesDrawMode: D2,
  TubeBufferGeometry: CU,
  TubeGeometry: Pp,
  UVMapping: Lg,
  Uint16BufferAttribute: eS,
  Uint32BufferAttribute: tS,
  Uint8BufferAttribute: PL,
  Uint8ClampedBufferAttribute: NL,
  Uniform: TS,
  UniformsGroup: zI,
  UniformsLib: lt,
  UniformsUtils: yT,
  UnsignedByteType: Ro,
  UnsignedInt248Type: tc,
  UnsignedIntType: Ol,
  UnsignedShort4444Type: JE,
  UnsignedShort5551Type: QE,
  UnsignedShortType: Jx,
  VSMShadowMap: Xu,
  Vector2: Ue,
  Vector3: q,
  Vector4: An,
  VectorKeyframeTrack: dp,
  VideoTexture: yO,
  WebGL1Renderer: AT,
  WebGL3DRenderTarget: SL,
  WebGLArrayRenderTarget: xL,
  WebGLCubeRenderTarget: xT,
  WebGLMultipleRenderTargets: ML,
  WebGLMultisampleRenderTarget: sU,
  WebGLRenderTarget: Wa,
  WebGLRenderer: aS,
  WebGLUtils: TT,
  WireframeGeometry: YT,
  WrapAroundEnding: ip,
  ZeroCurvatureEnding: Zu,
  ZeroFactor: EE,
  ZeroSlopeEnding: Ju,
  ZeroStencilOp: O2,
  _SRGBAFormat: Mg,
  sRGBEncoding: ti
}, Symbol.toStringTag, { value: "Module" }));
var Hx = { exports: {} }, Pl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qw;
function AU() {
  return qw || (qw = 1, Pl.ConcurrentRoot = 1, Pl.ContinuousEventPriority = 4, Pl.DefaultEventPriority = 16, Pl.DiscreteEventPriority = 1, Pl.IdleEventPriority = 536870912, Pl.LegacyRoot = 0), Pl;
}
var Nl = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jw;
function LU() {
  return jw || (jw = 1, process.env.NODE_ENV !== "production" && function() {
    var u = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), n = (
      /*                       */
      536870912
    ), r = u, s = e, c = t, f = n, h = 0, m = 1;
    Nl.ConcurrentRoot = m, Nl.ContinuousEventPriority = s, Nl.DefaultEventPriority = c, Nl.DiscreteEventPriority = r, Nl.IdleEventPriority = f, Nl.LegacyRoot = h;
  }()), Nl;
}
process.env.NODE_ENV === "production" ? Hx.exports = AU() : Hx.exports = LU();
var $f = Hx.exports;
function DU(u) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (m, g) => {
    const _ = typeof m == "function" ? m(e) : m;
    if (_ !== e) {
      const x = e;
      e = g ? _ : Object.assign({}, e, _), t.forEach((M) => M(e, x));
    }
  }, r = () => e, s = (m, g = r, _ = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let x = g(e);
    function M() {
      const b = g(e);
      if (!_(x, b)) {
        const E = x;
        m(x = b, E);
      }
    }
    return t.add(M), () => t.delete(M);
  }, h = { setState: n, getState: r, subscribe: (m, g, _) => g || _ ? s(m, g, _) : (t.add(m), () => t.delete(m)), destroy: () => t.clear() };
  return e = u(n, r, h), h;
}
const PU = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), Yw = PU ? $u : M2;
function NU(u) {
  const e = typeof u == "function" ? DU(u) : u, t = (n = e.getState, r = Object.is) => {
    const [, s] = x2((w) => w + 1, 0), c = e.getState(), f = Us(c), h = Us(n), m = Us(r), g = Us(!1), _ = Us();
    _.current === void 0 && (_.current = n(c));
    let x, M = !1;
    (f.current !== c || h.current !== n || m.current !== r || g.current) && (x = n(c), M = !r(_.current, x)), Yw(() => {
      M && (_.current = x), f.current = c, h.current = n, m.current = r, g.current = !1;
    });
    const b = Us(c);
    Yw(() => {
      const w = () => {
        try {
          const A = e.getState(), P = h.current(A);
          m.current(_.current, P) || (f.current = A, _.current = P, s());
        } catch {
          g.current = !0, s();
        }
      }, R = e.subscribe(w);
      return e.getState() !== b.current && w(), R;
    }, []);
    const E = M ? x : _.current;
    return S2(E), E;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const r = n.length <= 0;
        return { value: n.shift(), done: r };
      }
    };
  }, t;
}
var kx = { exports: {} }, lg = { exports: {} }, H_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xw;
function zU() {
  return Xw || (Xw = 1, function(u) {
    function e(V, J) {
      var Y = V.length;
      V.push(J);
      e:
        for (; 0 < Y; ) {
          var de = Y - 1 >>> 1, le = V[de];
          if (0 < r(le, J))
            V[de] = J, V[Y] = le, Y = de;
          else
            break e;
        }
    }
    function t(V) {
      return V.length === 0 ? null : V[0];
    }
    function n(V) {
      if (V.length === 0)
        return null;
      var J = V[0], Y = V.pop();
      if (Y !== J) {
        V[0] = Y;
        e:
          for (var de = 0, le = V.length, Pe = le >>> 1; de < Pe; ) {
            var We = 2 * (de + 1) - 1, $e = V[We], ve = We + 1, gt = V[ve];
            if (0 > r($e, Y))
              ve < le && 0 > r(gt, $e) ? (V[de] = gt, V[ve] = Y, de = ve) : (V[de] = $e, V[We] = Y, de = We);
            else if (ve < le && 0 > r(gt, Y))
              V[de] = gt, V[ve] = Y, de = ve;
            else
              break e;
          }
      }
      return J;
    }
    function r(V, J) {
      var Y = V.sortIndex - J.sortIndex;
      return Y !== 0 ? Y : V.id - J.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      u.unstable_now = function() {
        return s.now();
      };
    } else {
      var c = Date, f = c.now();
      u.unstable_now = function() {
        return c.now() - f;
      };
    }
    var h = [], m = [], g = 1, _ = null, x = 3, M = !1, b = !1, E = !1, w = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function P(V) {
      for (var J = t(m); J !== null; ) {
        if (J.callback === null)
          n(m);
        else if (J.startTime <= V)
          n(m), J.sortIndex = J.expirationTime, e(h, J);
        else
          break;
        J = t(m);
      }
    }
    function N(V) {
      if (E = !1, P(V), !b)
        if (t(h) !== null)
          b = !0, Me(I);
        else {
          var J = t(m);
          J !== null && De(N, J.startTime - V);
        }
    }
    function I(V, J) {
      b = !1, E && (E = !1, R(z), z = -1), M = !0;
      var Y = x;
      try {
        for (P(J), _ = t(h); _ !== null && (!(_.expirationTime > J) || V && !$()); ) {
          var de = _.callback;
          if (typeof de == "function") {
            _.callback = null, x = _.priorityLevel;
            var le = de(_.expirationTime <= J);
            J = u.unstable_now(), typeof le == "function" ? _.callback = le : _ === t(h) && n(h), P(J);
          } else
            n(h);
          _ = t(h);
        }
        if (_ !== null)
          var Pe = !0;
        else {
          var We = t(m);
          We !== null && De(N, We.startTime - J), Pe = !1;
        }
        return Pe;
      } finally {
        _ = null, x = Y, M = !1;
      }
    }
    var B = !1, W = null, z = -1, k = 5, G = -1;
    function $() {
      return !(u.unstable_now() - G < k);
    }
    function oe() {
      if (W !== null) {
        var V = u.unstable_now();
        G = V;
        var J = !0;
        try {
          J = W(!0, V);
        } finally {
          J ? ne() : (B = !1, W = null);
        }
      } else
        B = !1;
    }
    var ne;
    if (typeof A == "function")
      ne = function() {
        A(oe);
      };
    else if (typeof MessageChannel < "u") {
      var ee = new MessageChannel(), ye = ee.port2;
      ee.port1.onmessage = oe, ne = function() {
        ye.postMessage(null);
      };
    } else
      ne = function() {
        w(oe, 0);
      };
    function Me(V) {
      W = V, B || (B = !0, ne());
    }
    function De(V, J) {
      z = w(function() {
        V(u.unstable_now());
      }, J);
    }
    u.unstable_IdlePriority = 5, u.unstable_ImmediatePriority = 1, u.unstable_LowPriority = 4, u.unstable_NormalPriority = 3, u.unstable_Profiling = null, u.unstable_UserBlockingPriority = 2, u.unstable_cancelCallback = function(V) {
      V.callback = null;
    }, u.unstable_continueExecution = function() {
      b || M || (b = !0, Me(I));
    }, u.unstable_forceFrameRate = function(V) {
      0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : k = 0 < V ? Math.floor(1e3 / V) : 5;
    }, u.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, u.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, u.unstable_next = function(V) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var J = 3;
          break;
        default:
          J = x;
      }
      var Y = x;
      x = J;
      try {
        return V();
      } finally {
        x = Y;
      }
    }, u.unstable_pauseExecution = function() {
    }, u.unstable_requestPaint = function() {
    }, u.unstable_runWithPriority = function(V, J) {
      switch (V) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          V = 3;
      }
      var Y = x;
      x = V;
      try {
        return J();
      } finally {
        x = Y;
      }
    }, u.unstable_scheduleCallback = function(V, J, Y) {
      var de = u.unstable_now();
      switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? de + Y : de) : Y = de, V) {
        case 1:
          var le = -1;
          break;
        case 2:
          le = 250;
          break;
        case 5:
          le = 1073741823;
          break;
        case 4:
          le = 1e4;
          break;
        default:
          le = 5e3;
      }
      return le = Y + le, V = { id: g++, callback: J, priorityLevel: V, startTime: Y, expirationTime: le, sortIndex: -1 }, Y > de ? (V.sortIndex = Y, e(m, V), t(h) === null && V === t(m) && (E ? (R(z), z = -1) : E = !0, De(N, Y - de))) : (V.sortIndex = le, e(h, V), b || M || (b = !0, Me(I))), V;
    }, u.unstable_shouldYield = $, u.unstable_wrapCallback = function(V) {
      var J = x;
      return function() {
        var Y = x;
        x = J;
        try {
          return V.apply(this, arguments);
        } finally {
          x = Y;
        }
      };
    };
  }(H_)), H_;
}
var k_ = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zw;
function OU() {
  return Zw || (Zw = 1, function(u) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, n = 5;
      function r(ae, pe) {
        var Ee = ae.length;
        ae.push(pe), f(ae, pe, Ee);
      }
      function s(ae) {
        return ae.length === 0 ? null : ae[0];
      }
      function c(ae) {
        if (ae.length === 0)
          return null;
        var pe = ae[0], Ee = ae.pop();
        return Ee !== pe && (ae[0] = Ee, h(ae, Ee, 0)), pe;
      }
      function f(ae, pe, Ee) {
        for (var He = Ee; He > 0; ) {
          var Fe = He - 1 >>> 1, Tt = ae[Fe];
          if (m(Tt, pe) > 0)
            ae[Fe] = pe, ae[He] = Tt, He = Fe;
          else
            return;
        }
      }
      function h(ae, pe, Ee) {
        for (var He = Ee, Fe = ae.length, Tt = Fe >>> 1; He < Tt; ) {
          var ie = (He + 1) * 2 - 1, Re = ae[ie], fe = ie + 1, Ae = ae[fe];
          if (m(Re, pe) < 0)
            fe < Fe && m(Ae, Re) < 0 ? (ae[He] = Ae, ae[fe] = pe, He = fe) : (ae[He] = Re, ae[ie] = pe, He = ie);
          else if (fe < Fe && m(Ae, pe) < 0)
            ae[He] = Ae, ae[fe] = pe, He = fe;
          else
            return;
        }
      }
      function m(ae, pe) {
        var Ee = ae.sortIndex - pe.sortIndex;
        return Ee !== 0 ? Ee : ae.id - pe.id;
      }
      var g = 1, _ = 2, x = 3, M = 4, b = 5;
      function E(ae, pe) {
      }
      var w = typeof performance == "object" && typeof performance.now == "function";
      if (w) {
        var R = performance;
        u.unstable_now = function() {
          return R.now();
        };
      } else {
        var A = Date, P = A.now();
        u.unstable_now = function() {
          return A.now() - P;
        };
      }
      var N = 1073741823, I = -1, B = 250, W = 5e3, z = 1e4, k = N, G = [], $ = [], oe = 1, ne = null, ee = x, ye = !1, Me = !1, De = !1, V = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function de(ae) {
        for (var pe = s($); pe !== null; ) {
          if (pe.callback === null)
            c($);
          else if (pe.startTime <= ae)
            c($), pe.sortIndex = pe.expirationTime, r(G, pe);
          else
            return;
          pe = s($);
        }
      }
      function le(ae) {
        if (De = !1, de(ae), !Me)
          if (s(G) !== null)
            Me = !0, Ye(Pe);
          else {
            var pe = s($);
            pe !== null && Ke(le, pe.startTime - ae);
          }
      }
      function Pe(ae, pe) {
        Me = !1, De && (De = !1, Et()), ye = !0;
        var Ee = ee;
        try {
          var He;
          if (!t)
            return We(ae, pe);
        } finally {
          ne = null, ee = Ee, ye = !1;
        }
      }
      function We(ae, pe) {
        var Ee = pe;
        for (de(Ee), ne = s(G); ne !== null && !e && !(ne.expirationTime > Ee && (!ae || pt())); ) {
          var He = ne.callback;
          if (typeof He == "function") {
            ne.callback = null, ee = ne.priorityLevel;
            var Fe = ne.expirationTime <= Ee, Tt = He(Fe);
            Ee = u.unstable_now(), typeof Tt == "function" ? ne.callback = Tt : ne === s(G) && c(G), de(Ee);
          } else
            c(G);
          ne = s(G);
        }
        if (ne !== null)
          return !0;
        var ie = s($);
        return ie !== null && Ke(le, ie.startTime - Ee), !1;
      }
      function $e(ae, pe) {
        switch (ae) {
          case g:
          case _:
          case x:
          case M:
          case b:
            break;
          default:
            ae = x;
        }
        var Ee = ee;
        ee = ae;
        try {
          return pe();
        } finally {
          ee = Ee;
        }
      }
      function ve(ae) {
        var pe;
        switch (ee) {
          case g:
          case _:
          case x:
            pe = x;
            break;
          default:
            pe = ee;
            break;
        }
        var Ee = ee;
        ee = pe;
        try {
          return ae();
        } finally {
          ee = Ee;
        }
      }
      function gt(ae) {
        var pe = ee;
        return function() {
          var Ee = ee;
          ee = pe;
          try {
            return ae.apply(this, arguments);
          } finally {
            ee = Ee;
          }
        };
      }
      function ot(ae, pe, Ee) {
        var He = u.unstable_now(), Fe;
        if (typeof Ee == "object" && Ee !== null) {
          var Tt = Ee.delay;
          typeof Tt == "number" && Tt > 0 ? Fe = He + Tt : Fe = He;
        } else
          Fe = He;
        var ie;
        switch (ae) {
          case g:
            ie = I;
            break;
          case _:
            ie = B;
            break;
          case b:
            ie = k;
            break;
          case M:
            ie = z;
            break;
          case x:
          default:
            ie = W;
            break;
        }
        var Re = Fe + ie, fe = {
          id: oe++,
          callback: pe,
          priorityLevel: ae,
          startTime: Fe,
          expirationTime: Re,
          sortIndex: -1
        };
        return Fe > He ? (fe.sortIndex = Fe, r($, fe), s(G) === null && fe === s($) && (De ? Et() : De = !0, Ke(le, Fe - He))) : (fe.sortIndex = Re, r(G, fe), !Me && !ye && (Me = !0, Ye(Pe))), fe;
      }
      function _t() {
      }
      function Qe() {
        !Me && !ye && (Me = !0, Ye(Pe));
      }
      function At() {
        return s(G);
      }
      function Ne(ae) {
        ae.callback = null;
      }
      function we() {
        return ee;
      }
      var ke = !1, rt = null, Xe = -1, wt = n, St = -1;
      function pt() {
        var ae = u.unstable_now() - St;
        return !(ae < wt);
      }
      function kt() {
      }
      function Gt(ae) {
        if (ae < 0 || ae > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ae > 0 ? wt = Math.floor(1e3 / ae) : wt = n;
      }
      var X = function() {
        if (rt !== null) {
          var ae = u.unstable_now();
          St = ae;
          var pe = !0, Ee = !0;
          try {
            Ee = rt(pe, ae);
          } finally {
            Ee ? H() : (ke = !1, rt = null);
          }
        } else
          ke = !1;
      }, H;
      if (typeof Y == "function")
        H = function() {
          Y(X);
        };
      else if (typeof MessageChannel < "u") {
        var be = new MessageChannel(), qe = be.port2;
        be.port1.onmessage = X, H = function() {
          qe.postMessage(null);
        };
      } else
        H = function() {
          V(X, 0);
        };
      function Ye(ae) {
        rt = ae, ke || (ke = !0, H());
      }
      function Ke(ae, pe) {
        Xe = V(function() {
          ae(u.unstable_now());
        }, pe);
      }
      function Et() {
        J(Xe), Xe = -1;
      }
      var te = kt, he = null;
      u.unstable_IdlePriority = b, u.unstable_ImmediatePriority = g, u.unstable_LowPriority = M, u.unstable_NormalPriority = x, u.unstable_Profiling = he, u.unstable_UserBlockingPriority = _, u.unstable_cancelCallback = Ne, u.unstable_continueExecution = Qe, u.unstable_forceFrameRate = Gt, u.unstable_getCurrentPriorityLevel = we, u.unstable_getFirstCallbackNode = At, u.unstable_next = ve, u.unstable_pauseExecution = _t, u.unstable_requestPaint = te, u.unstable_runWithPriority = $e, u.unstable_scheduleCallback = ot, u.unstable_shouldYield = pt, u.unstable_wrapCallback = gt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(k_)), k_;
}
var Jw;
function SC() {
  return Jw || (Jw = 1, process.env.NODE_ENV === "production" ? lg.exports = zU() : lg.exports = OU()), lg.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V_, Qw;
function IU() {
  return Qw || (Qw = 1, V_ = function(e) {
    var t = {}, n = Cg, r = SC(), s = Object.assign;
    function c(o) {
      for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, v = 1; v < arguments.length; v++)
        l += "&args[]=" + encodeURIComponent(arguments[v]);
      return "Minified React error #" + o + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var f = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, h = Symbol.for("react.element"), m = Symbol.for("react.portal"), g = Symbol.for("react.fragment"), _ = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), M = Symbol.for("react.provider"), b = Symbol.for("react.context"), E = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), A = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), N = Symbol.for("react.offscreen"), I = Symbol.iterator;
    function B(o) {
      return o === null || typeof o != "object" ? null : (o = I && o[I] || o["@@iterator"], typeof o == "function" ? o : null);
    }
    function W(o) {
      if (o == null)
        return null;
      if (typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case g:
          return "Fragment";
        case m:
          return "Portal";
        case x:
          return "Profiler";
        case _:
          return "StrictMode";
        case w:
          return "Suspense";
        case R:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case b:
            return (o.displayName || "Context") + ".Consumer";
          case M:
            return (o._context.displayName || "Context") + ".Provider";
          case E:
            var l = o.render;
            return o = o.displayName, o || (o = l.displayName || l.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
          case A:
            return l = o.displayName || null, l !== null ? l : W(o.type) || "Memo";
          case P:
            l = o._payload, o = o._init;
            try {
              return W(o(l));
            } catch {
            }
        }
      return null;
    }
    function z(o) {
      var l = o.type;
      switch (o.tag) {
        case 24:
          return "Cache";
        case 9:
          return (l.displayName || "Context") + ".Consumer";
        case 10:
          return (l._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return o = l.render, o = o.displayName || o.name || "", l.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return l;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return W(l);
        case 8:
          return l === _ ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof l == "function")
            return l.displayName || l.name || null;
          if (typeof l == "string")
            return l;
      }
      return null;
    }
    function k(o) {
      var l = o, v = o;
      if (o.alternate)
        for (; l.return; )
          l = l.return;
      else {
        o = l;
        do
          l = o, l.flags & 4098 && (v = l.return), o = l.return;
        while (o);
      }
      return l.tag === 3 ? v : null;
    }
    function G(o) {
      if (k(o) !== o)
        throw Error(c(188));
    }
    function $(o) {
      var l = o.alternate;
      if (!l) {
        if (l = k(o), l === null)
          throw Error(c(188));
        return l !== o ? null : o;
      }
      for (var v = o, S = l; ; ) {
        var C = v.return;
        if (C === null)
          break;
        var D = C.alternate;
        if (D === null) {
          if (S = C.return, S !== null) {
            v = S;
            continue;
          }
          break;
        }
        if (C.child === D.child) {
          for (D = C.child; D; ) {
            if (D === v)
              return G(C), o;
            if (D === S)
              return G(C), l;
            D = D.sibling;
          }
          throw Error(c(188));
        }
        if (v.return !== S.return)
          v = C, S = D;
        else {
          for (var Z = !1, ue = C.child; ue; ) {
            if (ue === v) {
              Z = !0, v = C, S = D;
              break;
            }
            if (ue === S) {
              Z = !0, S = C, v = D;
              break;
            }
            ue = ue.sibling;
          }
          if (!Z) {
            for (ue = D.child; ue; ) {
              if (ue === v) {
                Z = !0, v = D, S = C;
                break;
              }
              if (ue === S) {
                Z = !0, S = D, v = C;
                break;
              }
              ue = ue.sibling;
            }
            if (!Z)
              throw Error(c(189));
          }
        }
        if (v.alternate !== S)
          throw Error(c(190));
      }
      if (v.tag !== 3)
        throw Error(c(188));
      return v.stateNode.current === v ? o : l;
    }
    function oe(o) {
      return o = $(o), o !== null ? ne(o) : null;
    }
    function ne(o) {
      if (o.tag === 5 || o.tag === 6)
        return o;
      for (o = o.child; o !== null; ) {
        var l = ne(o);
        if (l !== null)
          return l;
        o = o.sibling;
      }
      return null;
    }
    function ee(o) {
      if (o.tag === 5 || o.tag === 6)
        return o;
      for (o = o.child; o !== null; ) {
        if (o.tag !== 4) {
          var l = ee(o);
          if (l !== null)
            return l;
        }
        o = o.sibling;
      }
      return null;
    }
    var ye = Array.isArray, Me = e.getPublicInstance, De = e.getRootHostContext, V = e.getChildHostContext, J = e.prepareForCommit, Y = e.resetAfterCommit, de = e.createInstance, le = e.appendInitialChild, Pe = e.finalizeInitialChildren, We = e.prepareUpdate, $e = e.shouldSetTextContent, ve = e.createTextInstance, gt = e.scheduleTimeout, ot = e.cancelTimeout, _t = e.noTimeout, Qe = e.isPrimaryRenderer, At = e.supportsMutation, Ne = e.supportsPersistence, we = e.supportsHydration, ke = e.getInstanceFromNode, rt = e.preparePortalMount, Xe = e.getCurrentEventPriority, wt = e.detachDeletedInstance, St = e.supportsMicrotasks, pt = e.scheduleMicrotask, kt = e.supportsTestSelectors, Gt = e.findFiberRoot, X = e.getBoundingRect, H = e.getTextContent, be = e.isHiddenSubtree, qe = e.matchAccessibilityRole, Ye = e.setFocusIfFocusable, Ke = e.setupIntersectionObserver, Et = e.appendChild, te = e.appendChildToContainer, he = e.commitTextUpdate, ae = e.commitMount, pe = e.commitUpdate, Ee = e.insertBefore, He = e.insertInContainerBefore, Fe = e.removeChild, Tt = e.removeChildFromContainer, ie = e.resetTextContent, Re = e.hideInstance, fe = e.hideTextInstance, Ae = e.unhideInstance, Be = e.unhideTextInstance, tt = e.clearContainer, hn = e.cloneInstance, an = e.createContainerChildSet, bi = e.appendChildToContainerChildSet, Sn = e.finalizeContainerChildren, Bt = e.replaceContainerChildren, Ln = e.cloneHiddenInstance, vr = e.cloneHiddenTextInstance, $i = e.canHydrateInstance, Ii = e.canHydrateTextInstance, wi = e.canHydrateSuspenseInstance, Do = e.isSuspenseInstancePending, Pr = e.isSuspenseInstanceFallback, j = e.registerSuspenseInstanceRetry, ge = e.getNextHydratableSibling, U = e.getFirstHydratableChild, Q = e.getFirstHydratableChildWithinContainer, se = e.getFirstHydratableChildWithinSuspenseInstance, Ve = e.hydrateInstance, at = e.hydrateTextInstance, mt = e.hydrateSuspenseInstance, nt = e.getNextHydratableInstanceAfterSuspenseInstance, ht = e.commitHydratedContainer, Ct = e.commitHydratedSuspenseInstance, Mt = e.clearSuspenseBoundary, Ut = e.clearSuspenseBoundaryFromContainer, Dn = e.shouldDeleteUnhydratedTailInstances, oi = e.didNotMatchHydratedContainerTextInstance, Ui = e.didNotMatchHydratedTextInstance, fn;
    function tn(o) {
      if (fn === void 0)
        try {
          throw Error();
        } catch (v) {
          var l = v.stack.trim().match(/\n( *(at )?)/);
          fn = l && l[1] || "";
        }
      return `
` + fn + o;
    }
    var gr = !1;
    function Bn(o, l) {
      if (!o || gr)
        return "";
      gr = !0;
      var v = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (l)
          if (l = function() {
            throw Error();
          }, Object.defineProperty(l.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(l, []);
            } catch (Ze) {
              var S = Ze;
            }
            Reflect.construct(o, [], l);
          } else {
            try {
              l.call();
            } catch (Ze) {
              S = Ze;
            }
            o.call(l.prototype);
          }
        else {
          try {
            throw Error();
          } catch (Ze) {
            S = Ze;
          }
          o();
        }
      } catch (Ze) {
        if (Ze && S && typeof Ze.stack == "string") {
          for (var C = Ze.stack.split(`
`), D = S.stack.split(`
`), Z = C.length - 1, ue = D.length - 1; 1 <= Z && 0 <= ue && C[Z] !== D[ue]; )
            ue--;
          for (; 1 <= Z && 0 <= ue; Z--, ue--)
            if (C[Z] !== D[ue]) {
              if (Z !== 1 || ue !== 1)
                do
                  if (Z--, ue--, 0 > ue || C[Z] !== D[ue]) {
                    var Le = `
` + C[Z].replace(" at new ", " at ");
                    return o.displayName && Le.includes("<anonymous>") && (Le = Le.replace("<anonymous>", o.displayName)), Le;
                  }
                while (1 <= Z && 0 <= ue);
              break;
            }
        }
      } finally {
        gr = !1, Error.prepareStackTrace = v;
      }
      return (o = o ? o.displayName || o.name : "") ? tn(o) : "";
    }
    var er = Object.prototype.hasOwnProperty, yr = [], _r = -1;
    function tr(o) {
      return { current: o };
    }
    function Vt(o) {
      0 > _r || (o.current = yr[_r], yr[_r] = null, _r--);
    }
    function sn(o, l) {
      _r++, yr[_r] = o.current, o.current = l;
    }
    var xr = {}, gn = tr(xr), yn = tr(!1), Jr = xr;
    function qa(o, l) {
      var v = o.type.contextTypes;
      if (!v)
        return xr;
      var S = o.stateNode;
      if (S && S.__reactInternalMemoizedUnmaskedChildContext === l)
        return S.__reactInternalMemoizedMaskedChildContext;
      var C = {}, D;
      for (D in v)
        C[D] = l[D];
      return S && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = l, o.__reactInternalMemoizedMaskedChildContext = C), C;
    }
    function nr(o) {
      return o = o.childContextTypes, o != null;
    }
    function vc() {
      Vt(yn), Vt(gn);
    }
    function Op(o, l, v) {
      if (gn.current !== xr)
        throw Error(c(168));
      sn(gn, l), sn(yn, v);
    }
    function Ip(o, l, v) {
      var S = o.stateNode;
      if (l = l.childContextTypes, typeof S.getChildContext != "function")
        return v;
      S = S.getChildContext();
      for (var C in S)
        if (!(C in l))
          throw Error(c(108, z(o) || "Unknown", C));
      return s({}, v, S);
    }
    function Po(o) {
      return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || xr, Jr = gn.current, sn(gn, o), sn(yn, yn.current), !0;
    }
    function hd(o, l, v) {
      var S = o.stateNode;
      if (!S)
        throw Error(c(169));
      v ? (o = Ip(o, l, Jr), S.__reactInternalMemoizedMergedChildContext = o, Vt(yn), Vt(gn), sn(gn, o)) : Vt(yn), sn(yn, v);
    }
    var Nr = Math.clz32 ? Math.clz32 : Fp, pd = Math.log, Up = Math.LN2;
    function Fp(o) {
      return o >>>= 0, o === 0 ? 32 : 31 - (pd(o) / Up | 0) | 0;
    }
    var gc = 64, No = 4194304;
    function ms(o) {
      switch (o & -o) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return o & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return o & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return o;
      }
    }
    function yc(o, l) {
      var v = o.pendingLanes;
      if (v === 0)
        return 0;
      var S = 0, C = o.suspendedLanes, D = o.pingedLanes, Z = v & 268435455;
      if (Z !== 0) {
        var ue = Z & ~C;
        ue !== 0 ? S = ms(ue) : (D &= Z, D !== 0 && (S = ms(D)));
      } else
        Z = v & ~C, Z !== 0 ? S = ms(Z) : D !== 0 && (S = ms(D));
      if (S === 0)
        return 0;
      if (l !== 0 && l !== S && !(l & C) && (C = S & -S, D = l & -l, C >= D || C === 16 && (D & 4194240) !== 0))
        return l;
      if (S & 4 && (S |= v & 16), l = o.entangledLanes, l !== 0)
        for (o = o.entanglements, l &= S; 0 < l; )
          v = 31 - Nr(l), C = 1 << v, S |= o[v], l &= ~C;
      return S;
    }
    function Qr(o, l) {
      switch (o) {
        case 1:
        case 2:
        case 4:
          return l + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return l + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Yl(o, l) {
      for (var v = o.suspendedLanes, S = o.pingedLanes, C = o.expirationTimes, D = o.pendingLanes; 0 < D; ) {
        var Z = 31 - Nr(D), ue = 1 << Z, Le = C[Z];
        Le === -1 ? (!(ue & v) || ue & S) && (C[Z] = Qr(ue, l)) : Le <= l && (o.expiredLanes |= ue), D &= ~ue;
      }
    }
    function Gi(o) {
      return o = o.pendingLanes & -1073741825, o !== 0 ? o : o & 1073741824 ? 1073741824 : 0;
    }
    function md(o) {
      for (var l = [], v = 0; 31 > v; v++)
        l.push(o);
      return l;
    }
    function Xl(o, l, v) {
      o.pendingLanes |= l, l !== 536870912 && (o.suspendedLanes = 0, o.pingedLanes = 0), o = o.eventTimes, l = 31 - Nr(l), o[l] = v;
    }
    function Wg(o, l) {
      var v = o.pendingLanes & ~l;
      o.pendingLanes = l, o.suspendedLanes = 0, o.pingedLanes = 0, o.expiredLanes &= l, o.mutableReadLanes &= l, o.entangledLanes &= l, l = o.entanglements;
      var S = o.eventTimes;
      for (o = o.expirationTimes; 0 < v; ) {
        var C = 31 - Nr(v), D = 1 << C;
        l[C] = 0, S[C] = -1, o[C] = -1, v &= ~D;
      }
    }
    function vd(o, l) {
      var v = o.entangledLanes |= l;
      for (o = o.entanglements; v; ) {
        var S = 31 - Nr(v), C = 1 << S;
        C & l | o[S] & l && (o[S] |= l), v &= ~C;
      }
    }
    var dn = 0;
    function Bp(o) {
      return o &= -o, 1 < o ? 4 < o ? o & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var vs = r.unstable_scheduleCallback, Hp = r.unstable_cancelCallback, qg = r.unstable_shouldYield, jg = r.unstable_requestPaint, Gn = r.unstable_now, gd = r.unstable_ImmediatePriority, Yg = r.unstable_UserBlockingPriority, yd = r.unstable_NormalPriority, Xg = r.unstable_IdlePriority, _c = null, ya = null;
    function Zg(o) {
      if (ya && typeof ya.onCommitFiberRoot == "function")
        try {
          ya.onCommitFiberRoot(_c, o, void 0, (o.current.flags & 128) === 128);
        } catch {
        }
    }
    function Jg(o, l) {
      return o === l && (o !== 0 || 1 / o === 1 / l) || o !== o && l !== l;
    }
    var _a = typeof Object.is == "function" ? Object.is : Jg, ja = null, xc = !1, _d = !1;
    function xd(o) {
      ja === null ? ja = [o] : ja.push(o);
    }
    function Qg(o) {
      xc = !0, xd(o);
    }
    function xa() {
      if (!_d && ja !== null) {
        _d = !0;
        var o = 0, l = dn;
        try {
          var v = ja;
          for (dn = 1; o < v.length; o++) {
            var S = v[o];
            do
              S = S(!0);
            while (S !== null);
          }
          ja = null, xc = !1;
        } catch (C) {
          throw ja !== null && (ja = ja.slice(o + 1)), vs(gd, xa), C;
        } finally {
          dn = l, _d = !1;
        }
      }
      return null;
    }
    var Kg = f.ReactCurrentBatchConfig;
    function Sc(o, l) {
      if (_a(o, l))
        return !0;
      if (typeof o != "object" || o === null || typeof l != "object" || l === null)
        return !1;
      var v = Object.keys(o), S = Object.keys(l);
      if (v.length !== S.length)
        return !1;
      for (S = 0; S < v.length; S++) {
        var C = v[S];
        if (!er.call(l, C) || !_a(o[C], l[C]))
          return !1;
      }
      return !0;
    }
    function $g(o) {
      switch (o.tag) {
        case 5:
          return tn(o.type);
        case 16:
          return tn("Lazy");
        case 13:
          return tn("Suspense");
        case 19:
          return tn("SuspenseList");
        case 0:
        case 2:
        case 15:
          return o = Bn(o.type, !1), o;
        case 11:
          return o = Bn(o.type.render, !1), o;
        case 1:
          return o = Bn(o.type, !0), o;
        default:
          return "";
      }
    }
    function Kr(o, l) {
      if (o && o.defaultProps) {
        l = s({}, l), o = o.defaultProps;
        for (var v in o)
          l[v] === void 0 && (l[v] = o[v]);
        return l;
      }
      return l;
    }
    var Zl = tr(null), Jl = null, zo = null, Mc = null;
    function Sd() {
      Mc = zo = Jl = null;
    }
    function Md(o, l, v) {
      Qe ? (sn(Zl, l._currentValue), l._currentValue = v) : (sn(Zl, l._currentValue2), l._currentValue2 = v);
    }
    function bc(o) {
      var l = Zl.current;
      Vt(Zl), Qe ? o._currentValue = l : o._currentValue2 = l;
    }
    function bd(o, l, v) {
      for (; o !== null; ) {
        var S = o.alternate;
        if ((o.childLanes & l) !== l ? (o.childLanes |= l, S !== null && (S.childLanes |= l)) : S !== null && (S.childLanes & l) !== l && (S.childLanes |= l), o === v)
          break;
        o = o.return;
      }
    }
    function Oo(o, l) {
      Jl = o, Mc = zo = null, o = o.dependencies, o !== null && o.firstContext !== null && (o.lanes & l && (Fi = !0), o.firstContext = null);
    }
    function zr(o) {
      var l = Qe ? o._currentValue : o._currentValue2;
      if (Mc !== o)
        if (o = { context: o, memoizedValue: l, next: null }, zo === null) {
          if (Jl === null)
            throw Error(c(308));
          zo = o, Jl.dependencies = { lanes: 0, firstContext: o };
        } else
          zo = zo.next = o;
      return l;
    }
    var $r = null, Sa = !1;
    function wd(o) {
      o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Ql(o, l) {
      o = o.updateQueue, l.updateQueue === o && (l.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, effects: o.effects });
    }
    function Ya(o, l) {
      return { eventTime: o, lane: l, tag: 0, payload: null, callback: null, next: null };
    }
    function gs(o, l) {
      var v = o.updateQueue;
      v !== null && (v = v.shared, ii !== null && o.mode & 1 && !(Xt & 2) ? (o = v.interleaved, o === null ? (l.next = l, $r === null ? $r = [v] : $r.push(v)) : (l.next = o.next, o.next = l), v.interleaved = l) : (o = v.pending, o === null ? l.next = l : (l.next = o.next, o.next = l), v.pending = l));
    }
    function wc(o, l, v) {
      if (l = l.updateQueue, l !== null && (l = l.shared, (v & 4194240) !== 0)) {
        var S = l.lanes;
        S &= o.pendingLanes, v |= S, l.lanes = v, vd(o, v);
      }
    }
    function kp(o, l) {
      var v = o.updateQueue, S = o.alternate;
      if (S !== null && (S = S.updateQueue, v === S)) {
        var C = null, D = null;
        if (v = v.firstBaseUpdate, v !== null) {
          do {
            var Z = { eventTime: v.eventTime, lane: v.lane, tag: v.tag, payload: v.payload, callback: v.callback, next: null };
            D === null ? C = D = Z : D = D.next = Z, v = v.next;
          } while (v !== null);
          D === null ? C = D = l : D = D.next = l;
        } else
          C = D = l;
        v = { baseState: S.baseState, firstBaseUpdate: C, lastBaseUpdate: D, shared: S.shared, effects: S.effects }, o.updateQueue = v;
        return;
      }
      o = v.lastBaseUpdate, o === null ? v.firstBaseUpdate = l : o.next = l, v.lastBaseUpdate = l;
    }
    function Ec(o, l, v, S) {
      var C = o.updateQueue;
      Sa = !1;
      var D = C.firstBaseUpdate, Z = C.lastBaseUpdate, ue = C.shared.pending;
      if (ue !== null) {
        C.shared.pending = null;
        var Le = ue, Ze = Le.next;
        Le.next = null, Z === null ? D = Ze : Z.next = Ze, Z = Le;
        var it = o.alternate;
        it !== null && (it = it.updateQueue, ue = it.lastBaseUpdate, ue !== Z && (ue === null ? it.firstBaseUpdate = Ze : ue.next = Ze, it.lastBaseUpdate = Le));
      }
      if (D !== null) {
        var It = C.baseState;
        Z = 0, it = Ze = Le = null, ue = D;
        do {
          var Nt = ue.lane, Rn = ue.eventTime;
          if ((S & Nt) === Nt) {
            it !== null && (it = it.next = {
              eventTime: Rn,
              lane: 0,
              tag: ue.tag,
              payload: ue.payload,
              callback: ue.callback,
              next: null
            });
            e: {
              var Lt = o, Ri = ue;
              switch (Nt = l, Rn = v, Ri.tag) {
                case 1:
                  if (Lt = Ri.payload, typeof Lt == "function") {
                    It = Lt.call(Rn, It, Nt);
                    break e;
                  }
                  It = Lt;
                  break e;
                case 3:
                  Lt.flags = Lt.flags & -65537 | 128;
                case 0:
                  if (Lt = Ri.payload, Nt = typeof Lt == "function" ? Lt.call(Rn, It, Nt) : Lt, Nt == null)
                    break e;
                  It = s({}, It, Nt);
                  break e;
                case 2:
                  Sa = !0;
              }
            }
            ue.callback !== null && ue.lane !== 0 && (o.flags |= 64, Nt = C.effects, Nt === null ? C.effects = [ue] : Nt.push(ue));
          } else
            Rn = { eventTime: Rn, lane: Nt, tag: ue.tag, payload: ue.payload, callback: ue.callback, next: null }, it === null ? (Ze = it = Rn, Le = It) : it = it.next = Rn, Z |= Nt;
          if (ue = ue.next, ue === null) {
            if (ue = C.shared.pending, ue === null)
              break;
            Nt = ue, ue = Nt.next, Nt.next = null, C.lastBaseUpdate = Nt, C.shared.pending = null;
          }
        } while (1);
        if (it === null && (Le = It), C.baseState = Le, C.firstBaseUpdate = Ze, C.lastBaseUpdate = it, l = C.shared.interleaved, l !== null) {
          C = l;
          do
            Z |= C.lane, C = C.next;
          while (C !== l);
        } else
          D === null && (C.shared.lanes = 0);
        Aa |= Z, o.lanes = Z, o.memoizedState = It;
      }
    }
    function Vp(o, l, v) {
      if (o = l.effects, l.effects = null, o !== null)
        for (l = 0; l < o.length; l++) {
          var S = o[l], C = S.callback;
          if (C !== null) {
            if (S.callback = null, S = v, typeof C != "function")
              throw Error(c(191, C));
            C.call(S);
          }
        }
    }
    var Gp = new n.Component().refs;
    function Tc(o, l, v, S) {
      l = o.memoizedState, v = v(S, l), v = v == null ? l : s({}, l, v), o.memoizedState = v, o.lanes === 0 && (o.updateQueue.baseState = v);
    }
    var Cc = { isMounted: function(o) {
      return (o = o._reactInternals) ? k(o) === o : !1;
    }, enqueueSetState: function(o, l, v) {
      o = o._reactInternals;
      var S = Bi(), C = Es(o), D = Ya(S, C);
      D.payload = l, v != null && (D.callback = v), gs(o, D), l = kr(o, C, S), l !== null && wc(l, o, C);
    }, enqueueReplaceState: function(o, l, v) {
      o = o._reactInternals;
      var S = Bi(), C = Es(o), D = Ya(S, C);
      D.tag = 1, D.payload = l, v != null && (D.callback = v), gs(o, D), l = kr(o, C, S), l !== null && wc(l, o, C);
    }, enqueueForceUpdate: function(o, l) {
      o = o._reactInternals;
      var v = Bi(), S = Es(o), C = Ya(
        v,
        S
      );
      C.tag = 2, l != null && (C.callback = l), gs(o, C), l = kr(o, S, v), l !== null && wc(l, o, S);
    } };
    function Wp(o, l, v, S, C, D, Z) {
      return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(S, D, Z) : l.prototype && l.prototype.isPureReactComponent ? !Sc(v, S) || !Sc(C, D) : !0;
    }
    function qp(o, l, v) {
      var S = !1, C = xr, D = l.contextType;
      return typeof D == "object" && D !== null ? D = zr(D) : (C = nr(l) ? Jr : gn.current, S = l.contextTypes, D = (S = S != null) ? qa(o, C) : xr), l = new l(v, D), o.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = Cc, o.stateNode = l, l._reactInternals = o, S && (o = o.stateNode, o.__reactInternalMemoizedUnmaskedChildContext = C, o.__reactInternalMemoizedMaskedChildContext = D), l;
    }
    function jp(o, l, v, S) {
      o = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(v, S), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(v, S), l.state !== o && Cc.enqueueReplaceState(l, l.state, null);
    }
    function Ed(o, l, v, S) {
      var C = o.stateNode;
      C.props = v, C.state = o.memoizedState, C.refs = Gp, wd(o);
      var D = l.contextType;
      typeof D == "object" && D !== null ? C.context = zr(D) : (D = nr(l) ? Jr : gn.current, C.context = qa(o, D)), C.state = o.memoizedState, D = l.getDerivedStateFromProps, typeof D == "function" && (Tc(o, l, D, v), C.state = o.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (l = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), l !== C.state && Cc.enqueueReplaceState(C, C.state, null), Ec(o, v, C, S), C.state = o.memoizedState), typeof C.componentDidMount == "function" && (o.flags |= 4194308);
    }
    var Io = [], Uo = 0, Rc = null, Ac = 0, Or = [], Ir = 0, Gs = null, Xa = 1, Za = "";
    function Ws(o, l) {
      Io[Uo++] = Ac, Io[Uo++] = Rc, Rc = o, Ac = l;
    }
    function Yp(o, l, v) {
      Or[Ir++] = Xa, Or[Ir++] = Za, Or[Ir++] = Gs, Gs = o;
      var S = Xa;
      o = Za;
      var C = 32 - Nr(S) - 1;
      S &= ~(1 << C), v += 1;
      var D = 32 - Nr(l) + C;
      if (30 < D) {
        var Z = C - C % 5;
        D = (S & (1 << Z) - 1).toString(32), S >>= Z, C -= Z, Xa = 1 << 32 - Nr(l) + C | v << C | S, Za = D + o;
      } else
        Xa = 1 << D | v << C | S, Za = o;
    }
    function Td(o) {
      o.return !== null && (Ws(o, 1), Yp(o, 1, 0));
    }
    function Cd(o) {
      for (; o === Rc; )
        Rc = Io[--Uo], Io[Uo] = null, Ac = Io[--Uo], Io[Uo] = null;
      for (; o === Gs; )
        Gs = Or[--Ir], Or[Ir] = null, Za = Or[--Ir], Or[Ir] = null, Xa = Or[--Ir], Or[Ir] = null;
    }
    var Sr = null, Ei = null, zn = !1, Fo = !1, Ur = null;
    function Rd(o, l) {
      var v = Hi(5, null, null, 0);
      v.elementType = "DELETED", v.stateNode = l, v.return = o, l = o.deletions, l === null ? (o.deletions = [v], o.flags |= 16) : l.push(v);
    }
    function Ad(o, l) {
      switch (o.tag) {
        case 5:
          return l = $i(l, o.type, o.pendingProps), l !== null ? (o.stateNode = l, Sr = o, Ei = U(l), !0) : !1;
        case 6:
          return l = Ii(l, o.pendingProps), l !== null ? (o.stateNode = l, Sr = o, Ei = null, !0) : !1;
        case 13:
          if (l = wi(l), l !== null) {
            var v = Gs !== null ? { id: Xa, overflow: Za } : null;
            return o.memoizedState = { dehydrated: l, treeContext: v, retryLane: 1073741824 }, v = Hi(18, null, null, 0), v.stateNode = l, v.return = o, o.child = v, Sr = o, Ei = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function Lc(o) {
      return (o.mode & 1) !== 0 && (o.flags & 128) === 0;
    }
    function Dc(o) {
      if (zn) {
        var l = Ei;
        if (l) {
          var v = l;
          if (!Ad(o, l)) {
            if (Lc(o))
              throw Error(c(418));
            l = ge(v);
            var S = Sr;
            l && Ad(o, l) ? Rd(S, v) : (o.flags = o.flags & -4097 | 2, zn = !1, Sr = o);
          }
        } else {
          if (Lc(o))
            throw Error(c(418));
          o.flags = o.flags & -4097 | 2, zn = !1, Sr = o;
        }
      }
    }
    function Ld(o) {
      for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; )
        o = o.return;
      Sr = o;
    }
    function Kl(o) {
      if (!we || o !== Sr)
        return !1;
      if (!zn)
        return Ld(o), zn = !0, !1;
      if (o.tag !== 3 && (o.tag !== 5 || Dn(o.type) && !$e(o.type, o.memoizedProps))) {
        var l = Ei;
        if (l) {
          if (Lc(o)) {
            for (o = Ei; o; )
              o = ge(o);
            throw Error(c(418));
          }
          for (; l; )
            Rd(o, l), l = ge(l);
        }
      }
      if (Ld(o), o.tag === 13) {
        if (!we)
          throw Error(c(316));
        if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o)
          throw Error(c(317));
        Ei = nt(o);
      } else
        Ei = Sr ? ge(o.stateNode) : null;
      return !0;
    }
    function Bo() {
      we && (Ei = Sr = null, Fo = zn = !1);
    }
    function $l(o) {
      Ur === null ? Ur = [o] : Ur.push(o);
    }
    function qs(o, l, v) {
      if (o = v.ref, o !== null && typeof o != "function" && typeof o != "object") {
        if (v._owner) {
          if (v = v._owner, v) {
            if (v.tag !== 1)
              throw Error(c(309));
            var S = v.stateNode;
          }
          if (!S)
            throw Error(c(147, o));
          var C = S, D = "" + o;
          return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === D ? l.ref : (l = function(Z) {
            var ue = C.refs;
            ue === Gp && (ue = C.refs = {}), Z === null ? delete ue[D] : ue[D] = Z;
          }, l._stringRef = D, l);
        }
        if (typeof o != "string")
          throw Error(c(284));
        if (!v._owner)
          throw Error(c(290, o));
      }
      return o;
    }
    function ea(o, l) {
      throw o = Object.prototype.toString.call(l), Error(c(31, o === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : o));
    }
    function Pc(o) {
      var l = o._init;
      return l(o._payload);
    }
    function eu(o) {
      function l(xe, ce) {
        if (o) {
          var Te = xe.deletions;
          Te === null ? (xe.deletions = [ce], xe.flags |= 16) : Te.push(ce);
        }
      }
      function v(xe, ce) {
        if (!o)
          return null;
        for (; ce !== null; )
          l(xe, ce), ce = ce.sibling;
        return null;
      }
      function S(xe, ce) {
        for (xe = /* @__PURE__ */ new Map(); ce !== null; )
          ce.key !== null ? xe.set(ce.key, ce) : xe.set(ce.index, ce), ce = ce.sibling;
        return xe;
      }
      function C(xe, ce) {
        return xe = or(xe, ce), xe.index = 0, xe.sibling = null, xe;
      }
      function D(xe, ce, Te) {
        return xe.index = Te, o ? (Te = xe.alternate, Te !== null ? (Te = Te.index, Te < ce ? (xe.flags |= 2, ce) : Te) : (xe.flags |= 2, ce)) : (xe.flags |= 1048576, ce);
      }
      function Z(xe) {
        return o && xe.alternate === null && (xe.flags |= 2), xe;
      }
      function ue(xe, ce, Te, ct) {
        return ce === null || ce.tag !== 6 ? (ce = af(Te, xe.mode, ct), ce.return = xe, ce) : (ce = C(ce, Te), ce.return = xe, ce);
      }
      function Le(xe, ce, Te, ct) {
        var bt = Te.type;
        return bt === g ? it(xe, ce, Te.props.children, ct, Te.key) : ce !== null && (ce.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === P && Pc(bt) === ce.type) ? (ct = C(ce, Te.props), ct.ref = qs(xe, ce, Te), ct.return = xe, ct) : (ct = uo(Te.type, Te.key, Te.props, null, xe.mode, ct), ct.ref = qs(xe, ce, Te), ct.return = xe, ct);
      }
      function Ze(xe, ce, Te, ct) {
        return ce === null || ce.tag !== 4 || ce.stateNode.containerInfo !== Te.containerInfo || ce.stateNode.implementation !== Te.implementation ? (ce = Su(Te, xe.mode, ct), ce.return = xe, ce) : (ce = C(ce, Te.children || []), ce.return = xe, ce);
      }
      function it(xe, ce, Te, ct, bt) {
        return ce === null || ce.tag !== 7 ? (ce = Cs(Te, xe.mode, ct, bt), ce.return = xe, ce) : (ce = C(ce, Te), ce.return = xe, ce);
      }
      function It(xe, ce, Te) {
        if (typeof ce == "string" && ce !== "" || typeof ce == "number")
          return ce = af("" + ce, xe.mode, Te), ce.return = xe, ce;
        if (typeof ce == "object" && ce !== null) {
          switch (ce.$$typeof) {
            case h:
              return Te = uo(ce.type, ce.key, ce.props, null, xe.mode, Te), Te.ref = qs(xe, null, ce), Te.return = xe, Te;
            case m:
              return ce = Su(ce, xe.mode, Te), ce.return = xe, ce;
            case P:
              var ct = ce._init;
              return It(xe, ct(ce._payload), Te);
          }
          if (ye(ce) || B(ce))
            return ce = Cs(ce, xe.mode, Te, null), ce.return = xe, ce;
          ea(xe, ce);
        }
        return null;
      }
      function Nt(xe, ce, Te, ct) {
        var bt = ce !== null ? ce.key : null;
        if (typeof Te == "string" && Te !== "" || typeof Te == "number")
          return bt !== null ? null : ue(xe, ce, "" + Te, ct);
        if (typeof Te == "object" && Te !== null) {
          switch (Te.$$typeof) {
            case h:
              return Te.key === bt ? Le(xe, ce, Te, ct) : null;
            case m:
              return Te.key === bt ? Ze(xe, ce, Te, ct) : null;
            case P:
              return bt = Te._init, Nt(
                xe,
                ce,
                bt(Te._payload),
                ct
              );
          }
          if (ye(Te) || B(Te))
            return bt !== null ? null : it(xe, ce, Te, ct, null);
          ea(xe, Te);
        }
        return null;
      }
      function Rn(xe, ce, Te, ct, bt) {
        if (typeof ct == "string" && ct !== "" || typeof ct == "number")
          return xe = xe.get(Te) || null, ue(ce, xe, "" + ct, bt);
        if (typeof ct == "object" && ct !== null) {
          switch (ct.$$typeof) {
            case h:
              return xe = xe.get(ct.key === null ? Te : ct.key) || null, Le(ce, xe, ct, bt);
            case m:
              return xe = xe.get(ct.key === null ? Te : ct.key) || null, Ze(ce, xe, ct, bt);
            case P:
              var qt = ct._init;
              return Rn(xe, ce, Te, qt(ct._payload), bt);
          }
          if (ye(ct) || B(ct))
            return xe = xe.get(Te) || null, it(ce, xe, ct, bt, null);
          ea(ce, ct);
        }
        return null;
      }
      function Lt(xe, ce, Te, ct) {
        for (var bt = null, qt = null, zt = ce, Zt = ce = 0, Zn = null; zt !== null && Zt < Te.length; Zt++) {
          zt.index > Zt ? (Zn = zt, zt = null) : Zn = zt.sibling;
          var un = Nt(xe, zt, Te[Zt], ct);
          if (un === null) {
            zt === null && (zt = Zn);
            break;
          }
          o && zt && un.alternate === null && l(xe, zt), ce = D(un, ce, Zt), qt === null ? bt = un : qt.sibling = un, qt = un, zt = Zn;
        }
        if (Zt === Te.length)
          return v(xe, zt), zn && Ws(xe, Zt), bt;
        if (zt === null) {
          for (; Zt < Te.length; Zt++)
            zt = It(xe, Te[Zt], ct), zt !== null && (ce = D(zt, ce, Zt), qt === null ? bt = zt : qt.sibling = zt, qt = zt);
          return zn && Ws(xe, Zt), bt;
        }
        for (zt = S(xe, zt); Zt < Te.length; Zt++)
          Zn = Rn(zt, xe, Zt, Te[Zt], ct), Zn !== null && (o && Zn.alternate !== null && zt.delete(Zn.key === null ? Zt : Zn.key), ce = D(Zn, ce, Zt), qt === null ? bt = Zn : qt.sibling = Zn, qt = Zn);
        return o && zt.forEach(function(Rs) {
          return l(xe, Rs);
        }), zn && Ws(xe, Zt), bt;
      }
      function Ri(xe, ce, Te, ct) {
        var bt = B(Te);
        if (typeof bt != "function")
          throw Error(c(150));
        if (Te = bt.call(Te), Te == null)
          throw Error(c(151));
        for (var qt = bt = null, zt = ce, Zt = ce = 0, Zn = null, un = Te.next(); zt !== null && !un.done; Zt++, un = Te.next()) {
          zt.index > Zt ? (Zn = zt, zt = null) : Zn = zt.sibling;
          var Rs = Nt(xe, zt, un.value, ct);
          if (Rs === null) {
            zt === null && (zt = Zn);
            break;
          }
          o && zt && Rs.alternate === null && l(xe, zt), ce = D(Rs, ce, Zt), qt === null ? bt = Rs : qt.sibling = Rs, qt = Rs, zt = Zn;
        }
        if (un.done)
          return v(
            xe,
            zt
          ), zn && Ws(xe, Zt), bt;
        if (zt === null) {
          for (; !un.done; Zt++, un = Te.next())
            un = It(xe, un.value, ct), un !== null && (ce = D(un, ce, Zt), qt === null ? bt = un : qt.sibling = un, qt = un);
          return zn && Ws(xe, Zt), bt;
        }
        for (zt = S(xe, zt); !un.done; Zt++, un = Te.next())
          un = Rn(zt, xe, Zt, un.value, ct), un !== null && (o && un.alternate !== null && zt.delete(un.key === null ? Zt : un.key), ce = D(un, ce, Zt), qt === null ? bt = un : qt.sibling = un, qt = un);
        return o && zt.forEach(function(sf) {
          return l(xe, sf);
        }), zn && Ws(xe, Zt), bt;
      }
      function Wi(xe, ce, Te, ct) {
        if (typeof Te == "object" && Te !== null && Te.type === g && Te.key === null && (Te = Te.props.children), typeof Te == "object" && Te !== null) {
          switch (Te.$$typeof) {
            case h:
              e: {
                for (var bt = Te.key, qt = ce; qt !== null; ) {
                  if (qt.key === bt) {
                    if (bt = Te.type, bt === g) {
                      if (qt.tag === 7) {
                        v(xe, qt.sibling), ce = C(qt, Te.props.children), ce.return = xe, xe = ce;
                        break e;
                      }
                    } else if (qt.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === P && Pc(bt) === qt.type) {
                      v(xe, qt.sibling), ce = C(qt, Te.props), ce.ref = qs(xe, qt, Te), ce.return = xe, xe = ce;
                      break e;
                    }
                    v(xe, qt);
                    break;
                  } else
                    l(xe, qt);
                  qt = qt.sibling;
                }
                Te.type === g ? (ce = Cs(Te.props.children, xe.mode, ct, Te.key), ce.return = xe, xe = ce) : (ct = uo(Te.type, Te.key, Te.props, null, xe.mode, ct), ct.ref = qs(xe, ce, Te), ct.return = xe, xe = ct);
              }
              return Z(xe);
            case m:
              e: {
                for (qt = Te.key; ce !== null; ) {
                  if (ce.key === qt)
                    if (ce.tag === 4 && ce.stateNode.containerInfo === Te.containerInfo && ce.stateNode.implementation === Te.implementation) {
                      v(xe, ce.sibling), ce = C(ce, Te.children || []), ce.return = xe, xe = ce;
                      break e;
                    } else {
                      v(xe, ce);
                      break;
                    }
                  else
                    l(xe, ce);
                  ce = ce.sibling;
                }
                ce = Su(Te, xe.mode, ct), ce.return = xe, xe = ce;
              }
              return Z(xe);
            case P:
              return qt = Te._init, Wi(xe, ce, qt(Te._payload), ct);
          }
          if (ye(Te))
            return Lt(xe, ce, Te, ct);
          if (B(Te))
            return Ri(xe, ce, Te, ct);
          ea(xe, Te);
        }
        return typeof Te == "string" && Te !== "" || typeof Te == "number" ? (Te = "" + Te, ce !== null && ce.tag === 6 ? (v(xe, ce.sibling), ce = C(ce, Te), ce.return = xe, xe = ce) : (v(xe, ce), ce = af(Te, xe.mode, ct), ce.return = xe, xe = ce), Z(xe)) : v(xe, ce);
      }
      return Wi;
    }
    var Ho = eu(!0), Nc = eu(!1), tu = {}, ir = tr(tu), nu = tr(tu), ys = tr(tu);
    function ta(o) {
      if (o === tu)
        throw Error(c(174));
      return o;
    }
    function zc(o, l) {
      sn(ys, l), sn(nu, o), sn(ir, tu), o = De(l), Vt(ir), sn(ir, o);
    }
    function js() {
      Vt(ir), Vt(nu), Vt(ys);
    }
    function iu(o) {
      var l = ta(ys.current), v = ta(ir.current);
      l = V(v, o.type, l), v !== l && (sn(nu, o), sn(ir, l));
    }
    function Mr(o) {
      nu.current === o && (Vt(ir), Vt(nu));
    }
    var On = tr(0);
    function Ys(o) {
      for (var l = o; l !== null; ) {
        if (l.tag === 13) {
          var v = l.memoizedState;
          if (v !== null && (v = v.dehydrated, v === null || Do(v) || Pr(v)))
            return l;
        } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
          if (l.flags & 128)
            return l;
        } else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === o)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === o)
            return null;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return null;
    }
    var na = [];
    function Ma() {
      for (var o = 0; o < na.length; o++) {
        var l = na[o];
        Qe ? l._workInProgressVersionPrimary = null : l._workInProgressVersionSecondary = null;
      }
      na.length = 0;
    }
    var li = f.ReactCurrentDispatcher, En = f.ReactCurrentBatchConfig, _s = 0, on = null, Hn = null, Cn = null, ko = !1, ba = !1, Vo = 0, Go = 0;
    function ui() {
      throw Error(c(321));
    }
    function Fr(o, l) {
      if (l === null)
        return !1;
      for (var v = 0; v < l.length && v < o.length; v++)
        if (!_a(o[v], l[v]))
          return !1;
      return !0;
    }
    function Wo(o, l, v, S, C, D) {
      if (_s = D, on = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, li.current = o === null || o.memoizedState === null ? zd : Od, o = v(S, C), ba) {
        D = 0;
        do {
          if (ba = !1, Vo = 0, 25 <= D)
            throw Error(c(301));
          D += 1, Cn = Hn = null, l.updateQueue = null, li.current = Id, o = v(S, C);
        } while (ba);
      }
      if (li.current = Zo, l = Hn !== null && Hn.next !== null, _s = 0, Cn = Hn = on = null, ko = !1, l)
        throw Error(c(300));
      return o;
    }
    function ru() {
      var o = Vo !== 0;
      return Vo = 0, o;
    }
    function wa() {
      var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Cn === null ? on.memoizedState = Cn = o : Cn = Cn.next = o, Cn;
    }
    function ia() {
      if (Hn === null) {
        var o = on.alternate;
        o = o !== null ? o.memoizedState : null;
      } else
        o = Hn.next;
      var l = Cn === null ? on.memoizedState : Cn.next;
      if (l !== null)
        Cn = l, Hn = o;
      else {
        if (o === null)
          throw Error(c(310));
        Hn = o, o = { memoizedState: Hn.memoizedState, baseState: Hn.baseState, baseQueue: Hn.baseQueue, queue: Hn.queue, next: null }, Cn === null ? on.memoizedState = Cn = o : Cn = Cn.next = o;
      }
      return Cn;
    }
    function Ea(o, l) {
      return typeof l == "function" ? l(o) : l;
    }
    function au(o) {
      var l = ia(), v = l.queue;
      if (v === null)
        throw Error(c(311));
      v.lastRenderedReducer = o;
      var S = Hn, C = S.baseQueue, D = v.pending;
      if (D !== null) {
        if (C !== null) {
          var Z = C.next;
          C.next = D.next, D.next = Z;
        }
        S.baseQueue = C = D, v.pending = null;
      }
      if (C !== null) {
        D = C.next, S = S.baseState;
        var ue = Z = null, Le = null, Ze = D;
        do {
          var it = Ze.lane;
          if ((_s & it) === it)
            Le !== null && (Le = Le.next = { lane: 0, action: Ze.action, hasEagerState: Ze.hasEagerState, eagerState: Ze.eagerState, next: null }), S = Ze.hasEagerState ? Ze.eagerState : o(S, Ze.action);
          else {
            var It = {
              lane: it,
              action: Ze.action,
              hasEagerState: Ze.hasEagerState,
              eagerState: Ze.eagerState,
              next: null
            };
            Le === null ? (ue = Le = It, Z = S) : Le = Le.next = It, on.lanes |= it, Aa |= it;
          }
          Ze = Ze.next;
        } while (Ze !== null && Ze !== D);
        Le === null ? Z = S : Le.next = ue, _a(S, l.memoizedState) || (Fi = !0), l.memoizedState = S, l.baseState = Z, l.baseQueue = Le, v.lastRenderedState = S;
      }
      if (o = v.interleaved, o !== null) {
        C = o;
        do
          D = C.lane, on.lanes |= D, Aa |= D, C = C.next;
        while (C !== o);
      } else
        C === null && (v.lanes = 0);
      return [l.memoizedState, v.dispatch];
    }
    function Oc(o) {
      var l = ia(), v = l.queue;
      if (v === null)
        throw Error(c(311));
      v.lastRenderedReducer = o;
      var S = v.dispatch, C = v.pending, D = l.memoizedState;
      if (C !== null) {
        v.pending = null;
        var Z = C = C.next;
        do
          D = o(D, Z.action), Z = Z.next;
        while (Z !== C);
        _a(D, l.memoizedState) || (Fi = !0), l.memoizedState = D, l.baseQueue === null && (l.baseState = D), v.lastRenderedState = D;
      }
      return [D, S];
    }
    function Xs() {
    }
    function Dd(o, l) {
      var v = on, S = ia(), C = l(), D = !_a(S.memoizedState, C);
      if (D && (S.memoizedState = C, Fi = !0), S = S.queue, Ge(cn.bind(null, v, S, o), [o]), S.getSnapshot !== l || D || Cn !== null && Cn.memoizedState.tag & 1) {
        if (v.flags |= 2048, qo(9, Mn.bind(null, v, S, C, l), void 0, null), ii === null)
          throw Error(c(349));
        _s & 30 || Ft(v, l, C);
      }
      return C;
    }
    function Ft(o, l, v) {
      o.flags |= 16384, o = { getSnapshot: l, value: v }, l = on.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, on.updateQueue = l, l.stores = [o]) : (v = l.stores, v === null ? l.stores = [o] : v.push(o));
    }
    function Mn(o, l, v, S) {
      l.value = v, l.getSnapshot = S, qn(l) && kr(o, 1, -1);
    }
    function cn(o, l, v) {
      return v(function() {
        qn(l) && kr(o, 1, -1);
      });
    }
    function qn(o) {
      var l = o.getSnapshot;
      o = o.value;
      try {
        var v = l();
        return !_a(o, v);
      } catch {
        return !0;
      }
    }
    function Br(o) {
      var l = wa();
      return typeof o == "function" && (o = o()), l.memoizedState = l.baseState = o, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ea, lastRenderedState: o }, l.queue = o, o = o.dispatch = Nd.bind(null, on, o), [l.memoizedState, o];
    }
    function qo(o, l, v, S) {
      return o = { tag: o, create: l, destroy: v, deps: S, next: null }, l = on.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, on.updateQueue = l, l.lastEffect = o.next = o) : (v = l.lastEffect, v === null ? l.lastEffect = o.next = o : (S = v.next, v.next = o, o.next = S, l.lastEffect = o)), o;
    }
    function Xp() {
      return ia().memoizedState;
    }
    function Ic(o, l, v, S) {
      var C = wa();
      on.flags |= o, C.memoizedState = qo(1 | l, v, void 0, S === void 0 ? null : S);
    }
    function Uc(o, l, v, S) {
      var C = ia();
      S = S === void 0 ? null : S;
      var D = void 0;
      if (Hn !== null) {
        var Z = Hn.memoizedState;
        if (D = Z.destroy, S !== null && Fr(S, Z.deps)) {
          C.memoizedState = qo(l, v, D, S);
          return;
        }
      }
      on.flags |= o, C.memoizedState = qo(1 | l, v, D, S);
    }
    function su(o, l) {
      return Ic(8390656, 8, o, l);
    }
    function Ge(o, l) {
      return Uc(2048, 8, o, l);
    }
    function ci(o, l) {
      return Uc(4, 2, o, l);
    }
    function $t(o, l) {
      return Uc(4, 4, o, l);
    }
    function Zs(o, l) {
      if (typeof l == "function")
        return o = o(), l(o), function() {
          l(null);
        };
      if (l != null)
        return o = o(), l.current = o, function() {
          l.current = null;
        };
    }
    function Ja(o, l, v) {
      return v = v != null ? v.concat([o]) : null, Uc(4, 4, Zs.bind(null, l, o), v);
    }
    function Qa() {
    }
    function Ta(o, l) {
      var v = ia();
      l = l === void 0 ? null : l;
      var S = v.memoizedState;
      return S !== null && l !== null && Fr(l, S[1]) ? S[0] : (v.memoizedState = [o, l], o);
    }
    function jo(o, l) {
      var v = ia();
      l = l === void 0 ? null : l;
      var S = v.memoizedState;
      return S !== null && l !== null && Fr(l, S[1]) ? S[0] : (o = o(), v.memoizedState = [o, l], o);
    }
    function Yo(o, l) {
      var v = dn;
      dn = v !== 0 && 4 > v ? v : 4, o(!0);
      var S = En.transition;
      En.transition = {};
      try {
        o(!1), l();
      } finally {
        dn = v, En.transition = S;
      }
    }
    function Xo() {
      return ia().memoizedState;
    }
    function Pd(o, l, v) {
      var S = Es(o);
      v = { lane: S, action: v, hasEagerState: !1, eagerState: null, next: null }, Fc(o) ? Bc(l, v) : (Hc(o, l, v), v = Bi(), o = kr(o, S, v), o !== null && kc(o, l, S));
    }
    function Nd(o, l, v) {
      var S = Es(o), C = { lane: S, action: v, hasEagerState: !1, eagerState: null, next: null };
      if (Fc(o))
        Bc(l, C);
      else {
        Hc(o, l, C);
        var D = o.alternate;
        if (o.lanes === 0 && (D === null || D.lanes === 0) && (D = l.lastRenderedReducer, D !== null))
          try {
            var Z = l.lastRenderedState, ue = D(Z, v);
            if (C.hasEagerState = !0, C.eagerState = ue, _a(ue, Z))
              return;
          } catch {
          } finally {
          }
        v = Bi(), o = kr(o, S, v), o !== null && kc(o, l, S);
      }
    }
    function Fc(o) {
      var l = o.alternate;
      return o === on || l !== null && l === on;
    }
    function Bc(o, l) {
      ba = ko = !0;
      var v = o.pending;
      v === null ? l.next = l : (l.next = v.next, v.next = l), o.pending = l;
    }
    function Hc(o, l, v) {
      ii !== null && o.mode & 1 && !(Xt & 2) ? (o = l.interleaved, o === null ? (v.next = v, $r === null ? $r = [l] : $r.push(l)) : (v.next = o.next, o.next = v), l.interleaved = v) : (o = l.pending, o === null ? v.next = v : (v.next = o.next, o.next = v), l.pending = v);
    }
    function kc(o, l, v) {
      if (v & 4194240) {
        var S = l.lanes;
        S &= o.pendingLanes, v |= S, l.lanes = v, vd(o, v);
      }
    }
    var Zo = { readContext: zr, useCallback: ui, useContext: ui, useEffect: ui, useImperativeHandle: ui, useInsertionEffect: ui, useLayoutEffect: ui, useMemo: ui, useReducer: ui, useRef: ui, useState: ui, useDebugValue: ui, useDeferredValue: ui, useTransition: ui, useMutableSource: ui, useSyncExternalStore: ui, useId: ui, unstable_isNewReconciler: !1 }, zd = { readContext: zr, useCallback: function(o, l) {
      return wa().memoizedState = [o, l === void 0 ? null : l], o;
    }, useContext: zr, useEffect: su, useImperativeHandle: function(o, l, v) {
      return v = v != null ? v.concat([o]) : null, Ic(
        4194308,
        4,
        Zs.bind(null, l, o),
        v
      );
    }, useLayoutEffect: function(o, l) {
      return Ic(4194308, 4, o, l);
    }, useInsertionEffect: function(o, l) {
      return Ic(4, 2, o, l);
    }, useMemo: function(o, l) {
      var v = wa();
      return l = l === void 0 ? null : l, o = o(), v.memoizedState = [o, l], o;
    }, useReducer: function(o, l, v) {
      var S = wa();
      return l = v !== void 0 ? v(l) : l, S.memoizedState = S.baseState = l, o = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: o, lastRenderedState: l }, S.queue = o, o = o.dispatch = Pd.bind(null, on, o), [S.memoizedState, o];
    }, useRef: function(o) {
      var l = wa();
      return o = { current: o }, l.memoizedState = o;
    }, useState: Br, useDebugValue: Qa, useDeferredValue: function(o) {
      var l = Br(o), v = l[0], S = l[1];
      return su(function() {
        var C = En.transition;
        En.transition = {};
        try {
          S(o);
        } finally {
          En.transition = C;
        }
      }, [o]), v;
    }, useTransition: function() {
      var o = Br(!1), l = o[0];
      return o = Yo.bind(null, o[1]), wa().memoizedState = o, [l, o];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(o, l, v) {
      var S = on, C = wa();
      if (zn) {
        if (v === void 0)
          throw Error(c(407));
        v = v();
      } else {
        if (v = l(), ii === null)
          throw Error(c(349));
        _s & 30 || Ft(S, l, v);
      }
      C.memoizedState = v;
      var D = { value: v, getSnapshot: l };
      return C.queue = D, su(cn.bind(null, S, D, o), [o]), S.flags |= 2048, qo(9, Mn.bind(null, S, D, v, l), void 0, null), v;
    }, useId: function() {
      var o = wa(), l = ii.identifierPrefix;
      if (zn) {
        var v = Za, S = Xa;
        v = (S & ~(1 << 32 - Nr(S) - 1)).toString(32) + v, l = ":" + l + "R" + v, v = Vo++, 0 < v && (l += "H" + v.toString(32)), l += ":";
      } else
        v = Go++, l = ":" + l + "r" + v.toString(32) + ":";
      return o.memoizedState = l;
    }, unstable_isNewReconciler: !1 }, Od = {
      readContext: zr,
      useCallback: Ta,
      useContext: zr,
      useEffect: Ge,
      useImperativeHandle: Ja,
      useInsertionEffect: ci,
      useLayoutEffect: $t,
      useMemo: jo,
      useReducer: au,
      useRef: Xp,
      useState: function() {
        return au(Ea);
      },
      useDebugValue: Qa,
      useDeferredValue: function(o) {
        var l = au(Ea), v = l[0], S = l[1];
        return Ge(function() {
          var C = En.transition;
          En.transition = {};
          try {
            S(o);
          } finally {
            En.transition = C;
          }
        }, [o]), v;
      },
      useTransition: function() {
        var o = au(Ea)[0], l = ia().memoizedState;
        return [o, l];
      },
      useMutableSource: Xs,
      useSyncExternalStore: Dd,
      useId: Xo,
      unstable_isNewReconciler: !1
    }, Id = {
      readContext: zr,
      useCallback: Ta,
      useContext: zr,
      useEffect: Ge,
      useImperativeHandle: Ja,
      useInsertionEffect: ci,
      useLayoutEffect: $t,
      useMemo: jo,
      useReducer: Oc,
      useRef: Xp,
      useState: function() {
        return Oc(Ea);
      },
      useDebugValue: Qa,
      useDeferredValue: function(o) {
        var l = Oc(Ea), v = l[0], S = l[1];
        return Ge(function() {
          var C = En.transition;
          En.transition = {};
          try {
            S(o);
          } finally {
            En.transition = C;
          }
        }, [o]), v;
      },
      useTransition: function() {
        var o = Oc(Ea)[0], l = ia().memoizedState;
        return [o, l];
      },
      useMutableSource: Xs,
      useSyncExternalStore: Dd,
      useId: Xo,
      unstable_isNewReconciler: !1
    };
    function ou(o, l) {
      try {
        var v = "", S = l;
        do
          v += $g(S), S = S.return;
        while (S);
        var C = v;
      } catch (D) {
        C = `
Error generating stack: ` + D.message + `
` + D.stack;
      }
      return { value: o, source: l, stack: C };
    }
    function lu(o, l) {
      try {
        console.error(l.value);
      } catch (v) {
        setTimeout(function() {
          throw v;
        });
      }
    }
    var Ud = typeof WeakMap == "function" ? WeakMap : Map;
    function Vc(o, l, v) {
      v = Ya(-1, v), v.tag = 3, v.payload = { element: null };
      var S = l.value;
      return v.callback = function() {
        pu || (pu = !0, ef = S), lu(o, l);
      }, v;
    }
    function Gc(o, l, v) {
      v = Ya(-1, v), v.tag = 3;
      var S = o.type.getDerivedStateFromError;
      if (typeof S == "function") {
        var C = l.value;
        v.payload = function() {
          return S(C);
        }, v.callback = function() {
          lu(o, l);
        };
      }
      var D = o.stateNode;
      return D !== null && typeof D.componentDidCatch == "function" && (v.callback = function() {
        lu(o, l), typeof S != "function" && (bs === null ? bs = /* @__PURE__ */ new Set([this]) : bs.add(this));
        var Z = l.stack;
        this.componentDidCatch(l.value, { componentStack: Z !== null ? Z : "" });
      }), v;
    }
    function uu(o, l, v) {
      var S = o.pingCache;
      if (S === null) {
        S = o.pingCache = new Ud();
        var C = /* @__PURE__ */ new Set();
        S.set(l, C);
      } else
        C = S.get(l), C === void 0 && (C = /* @__PURE__ */ new Set(), S.set(l, C));
      C.has(v) || (C.add(v), o = La.bind(null, o, l, v), l.then(o, o));
    }
    function Js(o) {
      do {
        var l;
        if ((l = o.tag === 13) && (l = o.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
          return o;
        o = o.return;
      } while (o !== null);
      return null;
    }
    function Wc(o, l, v, S, C) {
      return o.mode & 1 ? (o.flags |= 65536, o.lanes = C, o) : (o === l ? o.flags |= 65536 : (o.flags |= 128, v.flags |= 131072, v.flags &= -52805, v.tag === 1 && (v.alternate === null ? v.tag = 17 : (l = Ya(-1, 1), l.tag = 2, gs(v, l))), v.lanes |= 1), o);
    }
    function Hr(o) {
      o.flags |= 4;
    }
    function qc(o, l) {
      if (o !== null && o.child === l.child)
        return !0;
      if (l.flags & 16)
        return !1;
      for (o = l.child; o !== null; ) {
        if (o.flags & 12854 || o.subtreeFlags & 12854)
          return !1;
        o = o.sibling;
      }
      return !0;
    }
    var Qs, Jo, xs, cu;
    if (At)
      Qs = function(o, l) {
        for (var v = l.child; v !== null; ) {
          if (v.tag === 5 || v.tag === 6)
            le(o, v.stateNode);
          else if (v.tag !== 4 && v.child !== null) {
            v.child.return = v, v = v.child;
            continue;
          }
          if (v === l)
            break;
          for (; v.sibling === null; ) {
            if (v.return === null || v.return === l)
              return;
            v = v.return;
          }
          v.sibling.return = v.return, v = v.sibling;
        }
      }, Jo = function() {
      }, xs = function(o, l, v, S, C) {
        if (o = o.memoizedProps, o !== S) {
          var D = l.stateNode, Z = ta(ir.current);
          v = We(D, v, o, S, C, Z), (l.updateQueue = v) && Hr(l);
        }
      }, cu = function(o, l, v, S) {
        v !== S && Hr(l);
      };
    else if (Ne) {
      Qs = function(o, l, v, S) {
        for (var C = l.child; C !== null; ) {
          if (C.tag === 5) {
            var D = C.stateNode;
            v && S && (D = Ln(D, C.type, C.memoizedProps, C)), le(o, D);
          } else if (C.tag === 6)
            D = C.stateNode, v && S && (D = vr(D, C.memoizedProps, C)), le(o, D);
          else if (C.tag !== 4) {
            if (C.tag === 22 && C.memoizedState !== null)
              D = C.child, D !== null && (D.return = C), Qs(o, C, !0, !0);
            else if (C.child !== null) {
              C.child.return = C, C = C.child;
              continue;
            }
          }
          if (C === l)
            break;
          for (; C.sibling === null; ) {
            if (C.return === null || C.return === l)
              return;
            C = C.return;
          }
          C.sibling.return = C.return, C = C.sibling;
        }
      };
      var Qo = function(o, l, v, S) {
        for (var C = l.child; C !== null; ) {
          if (C.tag === 5) {
            var D = C.stateNode;
            v && S && (D = Ln(D, C.type, C.memoizedProps, C)), bi(o, D);
          } else if (C.tag === 6)
            D = C.stateNode, v && S && (D = vr(D, C.memoizedProps, C)), bi(o, D);
          else if (C.tag !== 4) {
            if (C.tag === 22 && C.memoizedState !== null)
              D = C.child, D !== null && (D.return = C), Qo(o, C, !0, !0);
            else if (C.child !== null) {
              C.child.return = C, C = C.child;
              continue;
            }
          }
          if (C === l)
            break;
          for (; C.sibling === null; ) {
            if (C.return === null || C.return === l)
              return;
            C = C.return;
          }
          C.sibling.return = C.return, C = C.sibling;
        }
      };
      Jo = function(o, l) {
        var v = l.stateNode;
        if (!qc(o, l)) {
          o = v.containerInfo;
          var S = an(o);
          Qo(S, l, !1, !1), v.pendingChildren = S, Hr(l), Sn(o, S);
        }
      }, xs = function(o, l, v, S, C) {
        var D = o.stateNode, Z = o.memoizedProps;
        if ((o = qc(o, l)) && Z === S)
          l.stateNode = D;
        else {
          var ue = l.stateNode, Le = ta(ir.current), Ze = null;
          Z !== S && (Ze = We(ue, v, Z, S, C, Le)), o && Ze === null ? l.stateNode = D : (D = hn(D, Ze, v, Z, S, l, o, ue), Pe(D, v, S, C, Le) && Hr(l), l.stateNode = D, o ? Hr(l) : Qs(D, l, !1, !1));
        }
      }, cu = function(o, l, v, S) {
        v !== S ? (o = ta(ys.current), v = ta(ir.current), l.stateNode = ve(S, o, v, l), Hr(l)) : l.stateNode = o.stateNode;
      };
    } else
      Jo = function() {
      }, xs = function() {
      }, cu = function() {
      };
    function ra(o, l) {
      if (!zn)
        switch (o.tailMode) {
          case "hidden":
            l = o.tail;
            for (var v = null; l !== null; )
              l.alternate !== null && (v = l), l = l.sibling;
            v === null ? o.tail = null : v.sibling = null;
            break;
          case "collapsed":
            v = o.tail;
            for (var S = null; v !== null; )
              v.alternate !== null && (S = v), v = v.sibling;
            S === null ? l || o.tail === null ? o.tail = null : o.tail.sibling = null : S.sibling = null;
        }
    }
    function Tn(o) {
      var l = o.alternate !== null && o.alternate.child === o.child, v = 0, S = 0;
      if (l)
        for (var C = o.child; C !== null; )
          v |= C.lanes | C.childLanes, S |= C.subtreeFlags & 14680064, S |= C.flags & 14680064, C.return = o, C = C.sibling;
      else
        for (C = o.child; C !== null; )
          v |= C.lanes | C.childLanes, S |= C.subtreeFlags, S |= C.flags, C.return = o, C = C.sibling;
      return o.subtreeFlags |= S, o.childLanes = v, l;
    }
    function ey(o, l, v) {
      var S = l.pendingProps;
      switch (Cd(l), l.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Tn(l), null;
        case 1:
          return nr(l.type) && vc(), Tn(l), null;
        case 3:
          return S = l.stateNode, js(), Vt(yn), Vt(gn), Ma(), S.pendingContext && (S.context = S.pendingContext, S.pendingContext = null), (o === null || o.child === null) && (Kl(l) ? Hr(l) : o === null || o.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, Ur !== null && (gu(Ur), Ur = null))), Jo(o, l), Tn(l), null;
        case 5:
          Mr(l), v = ta(ys.current);
          var C = l.type;
          if (o !== null && l.stateNode != null)
            xs(o, l, C, S, v), o.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
          else {
            if (!S) {
              if (l.stateNode === null)
                throw Error(c(166));
              return Tn(l), null;
            }
            if (o = ta(ir.current), Kl(l)) {
              if (!we)
                throw Error(c(175));
              o = Ve(l.stateNode, l.type, l.memoizedProps, v, o, l, !Fo), l.updateQueue = o, o !== null && Hr(l);
            } else {
              var D = de(C, S, v, o, l);
              Qs(D, l, !1, !1), l.stateNode = D, Pe(D, C, S, v, o) && Hr(l);
            }
            l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
          }
          return Tn(l), null;
        case 6:
          if (o && l.stateNode != null)
            cu(o, l, o.memoizedProps, S);
          else {
            if (typeof S != "string" && l.stateNode === null)
              throw Error(c(166));
            if (o = ta(ys.current), v = ta(ir.current), Kl(l)) {
              if (!we)
                throw Error(c(176));
              if (o = l.stateNode, S = l.memoizedProps, (v = at(o, S, l, !Fo)) && (C = Sr, C !== null))
                switch (D = (C.mode & 1) !== 0, C.tag) {
                  case 3:
                    oi(C.stateNode.containerInfo, o, S, D);
                    break;
                  case 5:
                    Ui(C.type, C.memoizedProps, C.stateNode, o, S, D);
                }
              v && Hr(l);
            } else
              l.stateNode = ve(S, o, v, l);
          }
          return Tn(l), null;
        case 13:
          if (Vt(On), S = l.memoizedState, zn && Ei !== null && l.mode & 1 && !(l.flags & 128)) {
            for (o = Ei; o; )
              o = ge(o);
            return Bo(), l.flags |= 98560, l;
          }
          if (S !== null && S.dehydrated !== null) {
            if (S = Kl(l), o === null) {
              if (!S)
                throw Error(c(318));
              if (!we)
                throw Error(c(344));
              if (o = l.memoizedState, o = o !== null ? o.dehydrated : null, !o)
                throw Error(c(317));
              mt(o, l);
            } else
              Bo(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            return Tn(l), null;
          }
          return Ur !== null && (gu(Ur), Ur = null), l.flags & 128 ? (l.lanes = v, l) : (S = S !== null, v = !1, o === null ? Kl(l) : v = o.memoizedState !== null, S && !v && (l.child.flags |= 8192, l.mode & 1 && (o === null || On.current & 1 ? di === 0 && (di = 3) : nh())), l.updateQueue !== null && (l.flags |= 4), Tn(l), null);
        case 4:
          return js(), Jo(o, l), o === null && rt(l.stateNode.containerInfo), Tn(l), null;
        case 10:
          return bc(l.type._context), Tn(l), null;
        case 17:
          return nr(l.type) && vc(), Tn(l), null;
        case 19:
          if (Vt(On), C = l.memoizedState, C === null)
            return Tn(l), null;
          if (S = (l.flags & 128) !== 0, D = C.rendering, D === null)
            if (S)
              ra(C, !1);
            else {
              if (di !== 0 || o !== null && o.flags & 128)
                for (o = l.child; o !== null; ) {
                  if (D = Ys(o), D !== null) {
                    for (l.flags |= 128, ra(C, !1), o = D.updateQueue, o !== null && (l.updateQueue = o, l.flags |= 4), l.subtreeFlags = 0, o = v, S = l.child; S !== null; )
                      v = S, C = o, v.flags &= 14680066, D = v.alternate, D === null ? (v.childLanes = 0, v.lanes = C, v.child = null, v.subtreeFlags = 0, v.memoizedProps = null, v.memoizedState = null, v.updateQueue = null, v.dependencies = null, v.stateNode = null) : (v.childLanes = D.childLanes, v.lanes = D.lanes, v.child = D.child, v.subtreeFlags = 0, v.deletions = null, v.memoizedProps = D.memoizedProps, v.memoizedState = D.memoizedState, v.updateQueue = D.updateQueue, v.type = D.type, C = D.dependencies, v.dependencies = C === null ? null : { lanes: C.lanes, firstContext: C.firstContext }), S = S.sibling;
                    return sn(On, On.current & 1 | 2), l.child;
                  }
                  o = o.sibling;
                }
              C.tail !== null && Gn() > Kd && (l.flags |= 128, S = !0, ra(C, !1), l.lanes = 4194304);
            }
          else {
            if (!S)
              if (o = Ys(D), o !== null) {
                if (l.flags |= 128, S = !0, o = o.updateQueue, o !== null && (l.updateQueue = o, l.flags |= 4), ra(C, !0), C.tail === null && C.tailMode === "hidden" && !D.alternate && !zn)
                  return Tn(l), null;
              } else
                2 * Gn() - C.renderingStartTime > Kd && v !== 1073741824 && (l.flags |= 128, S = !0, ra(C, !1), l.lanes = 4194304);
            C.isBackwards ? (D.sibling = l.child, l.child = D) : (o = C.last, o !== null ? o.sibling = D : l.child = D, C.last = D);
          }
          return C.tail !== null ? (l = C.tail, C.rendering = l, C.tail = l.sibling, C.renderingStartTime = Gn(), l.sibling = null, o = On.current, sn(On, S ? o & 1 | 2 : o & 1), l) : (Tn(l), null);
        case 22:
        case 23:
          return Vr(), S = l.memoizedState !== null, o !== null && o.memoizedState !== null !== S && (l.flags |= 8192), S && l.mode & 1 ? wr & 1073741824 && (Tn(l), At && l.subtreeFlags & 6 && (l.flags |= 8192)) : Tn(l), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(c(156, l.tag));
    }
    var Pn = f.ReactCurrentOwner, Fi = !1;
    function yi(o, l, v, S) {
      l.child = o === null ? Nc(l, null, v, S) : Ho(l, o.child, v, S);
    }
    function Ko(o, l, v, S, C) {
      v = v.render;
      var D = l.ref;
      return Oo(l, C), S = Wo(o, l, v, S, D, C), v = ru(), o !== null && !Fi ? (l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~C, jn(o, l, C)) : (zn && v && Td(l), l.flags |= 1, yi(o, l, S, C), l.child);
    }
    function fu(o, l, v, S, C) {
      if (o === null) {
        var D = v.type;
        return typeof D == "function" && !lo(D) && D.defaultProps === void 0 && v.compare === null && v.defaultProps === void 0 ? (l.tag = 15, l.type = D, Zp(o, l, D, S, C)) : (o = uo(v.type, null, S, l, l.mode, C), o.ref = l.ref, o.return = l, l.child = o);
      }
      if (D = o.child, !(o.lanes & C)) {
        var Z = D.memoizedProps;
        if (v = v.compare, v = v !== null ? v : Sc, v(Z, S) && o.ref === l.ref)
          return jn(o, l, C);
      }
      return l.flags |= 1, o = or(D, S), o.ref = l.ref, o.return = l, l.child = o;
    }
    function Zp(o, l, v, S, C) {
      if (o !== null && Sc(o.memoizedProps, S) && o.ref === l.ref)
        if (Fi = !1, (o.lanes & C) !== 0)
          o.flags & 131072 && (Fi = !0);
        else
          return l.lanes = o.lanes, jn(o, l, C);
      return Fd(o, l, v, S, C);
    }
    function Jp(o, l, v) {
      var S = l.pendingProps, C = S.children, D = o !== null ? o.memoizedState : null;
      if (S.mode === "hidden")
        if (!(l.mode & 1))
          l.memoizedState = { baseLanes: 0, cachePool: null }, sn(al, wr), wr |= v;
        else if (v & 1073741824)
          l.memoizedState = { baseLanes: 0, cachePool: null }, S = D !== null ? D.baseLanes : v, sn(al, wr), wr |= S;
        else
          return o = D !== null ? D.baseLanes | v : v, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: o, cachePool: null }, l.updateQueue = null, sn(al, wr), wr |= o, null;
      else
        D !== null ? (S = D.baseLanes | v, l.memoizedState = null) : S = v, sn(al, wr), wr |= S;
      return yi(o, l, C, v), l.child;
    }
    function Qp(o, l) {
      var v = l.ref;
      (o === null && v !== null || o !== null && o.ref !== v) && (l.flags |= 512, l.flags |= 2097152);
    }
    function Fd(o, l, v, S, C) {
      var D = nr(v) ? Jr : gn.current;
      return D = qa(l, D), Oo(l, C), v = Wo(o, l, v, S, D, C), S = ru(), o !== null && !Fi ? (l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~C, jn(o, l, C)) : (zn && S && Td(l), l.flags |= 1, yi(o, l, v, C), l.child);
    }
    function jc(o, l, v, S, C) {
      if (nr(v)) {
        var D = !0;
        Po(l);
      } else
        D = !1;
      if (Oo(l, C), l.stateNode === null)
        o !== null && (o.alternate = null, l.alternate = null, l.flags |= 2), qp(l, v, S), Ed(l, v, S, C), S = !0;
      else if (o === null) {
        var Z = l.stateNode, ue = l.memoizedProps;
        Z.props = ue;
        var Le = Z.context, Ze = v.contextType;
        typeof Ze == "object" && Ze !== null ? Ze = zr(Ze) : (Ze = nr(v) ? Jr : gn.current, Ze = qa(l, Ze));
        var it = v.getDerivedStateFromProps, It = typeof it == "function" || typeof Z.getSnapshotBeforeUpdate == "function";
        It || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (ue !== S || Le !== Ze) && jp(l, Z, S, Ze), Sa = !1;
        var Nt = l.memoizedState;
        Z.state = Nt, Ec(l, S, Z, C), Le = l.memoizedState, ue !== S || Nt !== Le || yn.current || Sa ? (typeof it == "function" && (Tc(l, v, it, S), Le = l.memoizedState), (ue = Sa || Wp(l, v, ue, S, Nt, Le, Ze)) ? (It || typeof Z.UNSAFE_componentWillMount != "function" && typeof Z.componentWillMount != "function" || (typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount()), typeof Z.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof Z.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = S, l.memoizedState = Le), Z.props = S, Z.state = Le, Z.context = Ze, S = ue) : (typeof Z.componentDidMount == "function" && (l.flags |= 4194308), S = !1);
      } else {
        Z = l.stateNode, Ql(o, l), ue = l.memoizedProps, Ze = l.type === l.elementType ? ue : Kr(l.type, ue), Z.props = Ze, It = l.pendingProps, Nt = Z.context, Le = v.contextType, typeof Le == "object" && Le !== null ? Le = zr(Le) : (Le = nr(v) ? Jr : gn.current, Le = qa(l, Le));
        var Rn = v.getDerivedStateFromProps;
        (it = typeof Rn == "function" || typeof Z.getSnapshotBeforeUpdate == "function") || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (ue !== It || Nt !== Le) && jp(l, Z, S, Le), Sa = !1, Nt = l.memoizedState, Z.state = Nt, Ec(l, S, Z, C);
        var Lt = l.memoizedState;
        ue !== It || Nt !== Lt || yn.current || Sa ? (typeof Rn == "function" && (Tc(l, v, Rn, S), Lt = l.memoizedState), (Ze = Sa || Wp(l, v, Ze, S, Nt, Lt, Le) || !1) ? (it || typeof Z.UNSAFE_componentWillUpdate != "function" && typeof Z.componentWillUpdate != "function" || (typeof Z.componentWillUpdate == "function" && Z.componentWillUpdate(
          S,
          Lt,
          Le
        ), typeof Z.UNSAFE_componentWillUpdate == "function" && Z.UNSAFE_componentWillUpdate(S, Lt, Le)), typeof Z.componentDidUpdate == "function" && (l.flags |= 4), typeof Z.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof Z.componentDidUpdate != "function" || ue === o.memoizedProps && Nt === o.memoizedState || (l.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || ue === o.memoizedProps && Nt === o.memoizedState || (l.flags |= 1024), l.memoizedProps = S, l.memoizedState = Lt), Z.props = S, Z.state = Lt, Z.context = Le, S = Ze) : (typeof Z.componentDidUpdate != "function" || ue === o.memoizedProps && Nt === o.memoizedState || (l.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || ue === o.memoizedProps && Nt === o.memoizedState || (l.flags |= 1024), S = !1);
      }
      return Bd(o, l, v, S, D, C);
    }
    function Bd(o, l, v, S, C, D) {
      Qp(o, l);
      var Z = (l.flags & 128) !== 0;
      if (!S && !Z)
        return C && hd(l, v, !1), jn(o, l, D);
      S = l.stateNode, Pn.current = l;
      var ue = Z && typeof v.getDerivedStateFromError != "function" ? null : S.render();
      return l.flags |= 1, o !== null && Z ? (l.child = Ho(l, o.child, null, D), l.child = Ho(l, null, ue, D)) : yi(o, l, ue, D), l.memoizedState = S.state, C && hd(l, v, !0), l.child;
    }
    function Yc(o) {
      var l = o.stateNode;
      l.pendingContext ? Op(o, l.pendingContext, l.pendingContext !== l.context) : l.context && Op(o, l.context, !1), zc(o, l.containerInfo);
    }
    function Hd(o, l, v, S, C) {
      return Bo(), $l(C), l.flags |= 256, yi(o, l, v, S), l.child;
    }
    var Xc = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Ks(o) {
      return { baseLanes: o, cachePool: null };
    }
    function Kp(o, l, v) {
      var S = l.pendingProps, C = On.current, D = !1, Z = (l.flags & 128) !== 0, ue;
      if ((ue = Z) || (ue = o !== null && o.memoizedState === null ? !1 : (C & 2) !== 0), ue ? (D = !0, l.flags &= -129) : (o === null || o.memoizedState !== null) && (C |= 1), sn(On, C & 1), o === null)
        return Dc(l), o = l.memoizedState, o !== null && (o = o.dehydrated, o !== null) ? (l.mode & 1 ? Pr(o) ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (C = S.children, o = S.fallback, D ? (S = l.mode, D = l.child, C = { mode: "hidden", children: C }, !(S & 1) && D !== null ? (D.childLanes = 0, D.pendingProps = C) : D = xu(C, S, 0, null), o = Cs(o, S, v, null), D.return = l, o.return = l, D.sibling = o, l.child = D, l.child.memoizedState = Ks(v), l.memoizedState = Xc, o) : Zc(l, C));
      if (C = o.memoizedState, C !== null) {
        if (ue = C.dehydrated, ue !== null) {
          if (Z)
            return l.flags & 256 ? (l.flags &= -257, Ca(o, l, v, Error(c(422)))) : l.memoizedState !== null ? (l.child = o.child, l.flags |= 128, null) : (D = S.fallback, C = l.mode, S = xu({ mode: "visible", children: S.children }, C, 0, null), D = Cs(D, C, v, null), D.flags |= 2, S.return = l, D.return = l, S.sibling = D, l.child = S, l.mode & 1 && Ho(
              l,
              o.child,
              null,
              v
            ), l.child.memoizedState = Ks(v), l.memoizedState = Xc, D);
          if (!(l.mode & 1))
            l = Ca(o, l, v, null);
          else if (Pr(ue))
            l = Ca(o, l, v, Error(c(419)));
          else if (S = (v & o.childLanes) !== 0, Fi || S) {
            if (S = ii, S !== null) {
              switch (v & -v) {
                case 4:
                  D = 2;
                  break;
                case 16:
                  D = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  D = 32;
                  break;
                case 536870912:
                  D = 268435456;
                  break;
                default:
                  D = 0;
              }
              S = D & (S.suspendedLanes | v) ? 0 : D, S !== 0 && S !== C.retryLane && (C.retryLane = S, kr(o, S, -1));
            }
            nh(), l = Ca(o, l, v, Error(c(421)));
          } else
            Do(ue) ? (l.flags |= 128, l.child = o.child, l = ry.bind(null, o), j(ue, l), l = null) : (v = C.treeContext, we && (Ei = se(ue), Sr = l, zn = !0, Ur = null, Fo = !1, v !== null && (Or[Ir++] = Xa, Or[Ir++] = Za, Or[Ir++] = Gs, Xa = v.id, Za = v.overflow, Gs = l)), l = Zc(l, l.pendingProps.children), l.flags |= 4096);
          return l;
        }
        return D ? (S = em(o, l, S.children, S.fallback, v), D = l.child, C = o.child.memoizedState, D.memoizedState = C === null ? Ks(v) : { baseLanes: C.baseLanes | v, cachePool: null }, D.childLanes = o.childLanes & ~v, l.memoizedState = Xc, S) : (v = $p(o, l, S.children, v), l.memoizedState = null, v);
      }
      return D ? (S = em(o, l, S.children, S.fallback, v), D = l.child, C = o.child.memoizedState, D.memoizedState = C === null ? Ks(v) : { baseLanes: C.baseLanes | v, cachePool: null }, D.childLanes = o.childLanes & ~v, l.memoizedState = Xc, S) : (v = $p(o, l, S.children, v), l.memoizedState = null, v);
    }
    function Zc(o, l) {
      return l = xu({ mode: "visible", children: l }, o.mode, 0, null), l.return = o, o.child = l;
    }
    function $p(o, l, v, S) {
      var C = o.child;
      return o = C.sibling, v = or(C, { mode: "visible", children: v }), !(l.mode & 1) && (v.lanes = S), v.return = l, v.sibling = null, o !== null && (S = l.deletions, S === null ? (l.deletions = [o], l.flags |= 16) : S.push(o)), l.child = v;
    }
    function em(o, l, v, S, C) {
      var D = l.mode;
      o = o.child;
      var Z = o.sibling, ue = { mode: "hidden", children: v };
      return !(D & 1) && l.child !== o ? (v = l.child, v.childLanes = 0, v.pendingProps = ue, l.deletions = null) : (v = or(o, ue), v.subtreeFlags = o.subtreeFlags & 14680064), Z !== null ? S = or(Z, S) : (S = Cs(S, D, C, null), S.flags |= 2), S.return = l, v.return = l, v.sibling = S, l.child = v, S;
    }
    function Ca(o, l, v, S) {
      return S !== null && $l(S), Ho(l, o.child, null, v), o = Zc(l, l.pendingProps.children), o.flags |= 2, l.memoizedState = null, o;
    }
    function $o(o, l, v) {
      o.lanes |= l;
      var S = o.alternate;
      S !== null && (S.lanes |= l), bd(o.return, l, v);
    }
    function Ka(o, l, v, S, C) {
      var D = o.memoizedState;
      D === null ? o.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: S, tail: v, tailMode: C } : (D.isBackwards = l, D.rendering = null, D.renderingStartTime = 0, D.last = S, D.tail = v, D.tailMode = C);
    }
    function Jc(o, l, v) {
      var S = l.pendingProps, C = S.revealOrder, D = S.tail;
      if (yi(o, l, S.children, v), S = On.current, S & 2)
        S = S & 1 | 2, l.flags |= 128;
      else {
        if (o !== null && o.flags & 128)
          e:
            for (o = l.child; o !== null; ) {
              if (o.tag === 13)
                o.memoizedState !== null && $o(o, v, l);
              else if (o.tag === 19)
                $o(o, v, l);
              else if (o.child !== null) {
                o.child.return = o, o = o.child;
                continue;
              }
              if (o === l)
                break e;
              for (; o.sibling === null; ) {
                if (o.return === null || o.return === l)
                  break e;
                o = o.return;
              }
              o.sibling.return = o.return, o = o.sibling;
            }
        S &= 1;
      }
      if (sn(On, S), !(l.mode & 1))
        l.memoizedState = null;
      else
        switch (C) {
          case "forwards":
            for (v = l.child, C = null; v !== null; )
              o = v.alternate, o !== null && Ys(o) === null && (C = v), v = v.sibling;
            v = C, v === null ? (C = l.child, l.child = null) : (C = v.sibling, v.sibling = null), Ka(l, !1, C, v, D);
            break;
          case "backwards":
            for (v = null, C = l.child, l.child = null; C !== null; ) {
              if (o = C.alternate, o !== null && Ys(o) === null) {
                l.child = C;
                break;
              }
              o = C.sibling, C.sibling = v, v = C, C = o;
            }
            Ka(l, !0, v, null, D);
            break;
          case "together":
            Ka(l, !1, null, null, void 0);
            break;
          default:
            l.memoizedState = null;
        }
      return l.child;
    }
    function jn(o, l, v) {
      if (o !== null && (l.dependencies = o.dependencies), Aa |= l.lanes, !(v & l.childLanes))
        return null;
      if (o !== null && l.child !== o.child)
        throw Error(c(153));
      if (l.child !== null) {
        for (o = l.child, v = or(o, o.pendingProps), l.child = v, v.return = l; o.sibling !== null; )
          o = o.sibling, v = v.sibling = or(o, o.pendingProps), v.return = l;
        v.sibling = null;
      }
      return l.child;
    }
    function el(o, l, v) {
      switch (l.tag) {
        case 3:
          Yc(l), Bo();
          break;
        case 5:
          iu(l);
          break;
        case 1:
          nr(l.type) && Po(l);
          break;
        case 4:
          zc(l, l.stateNode.containerInfo);
          break;
        case 10:
          Md(l, l.type._context, l.memoizedProps.value);
          break;
        case 13:
          var S = l.memoizedState;
          if (S !== null)
            return S.dehydrated !== null ? (sn(On, On.current & 1), l.flags |= 128, null) : v & l.child.childLanes ? Kp(o, l, v) : (sn(On, On.current & 1), o = jn(o, l, v), o !== null ? o.sibling : null);
          sn(On, On.current & 1);
          break;
        case 19:
          if (S = (v & l.childLanes) !== 0, o.flags & 128) {
            if (S)
              return Jc(
                o,
                l,
                v
              );
            l.flags |= 128;
          }
          var C = l.memoizedState;
          if (C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), sn(On, On.current), S)
            break;
          return null;
        case 22:
        case 23:
          return l.lanes = 0, Jp(o, l, v);
      }
      return jn(o, l, v);
    }
    function Wt(o, l) {
      switch (Cd(l), l.tag) {
        case 1:
          return nr(l.type) && vc(), o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
        case 3:
          return js(), Vt(yn), Vt(gn), Ma(), o = l.flags, o & 65536 && !(o & 128) ? (l.flags = o & -65537 | 128, l) : null;
        case 5:
          return Mr(l), null;
        case 13:
          if (Vt(On), o = l.memoizedState, o !== null && o.dehydrated !== null) {
            if (l.alternate === null)
              throw Error(c(340));
            Bo();
          }
          return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
        case 19:
          return Vt(On), null;
        case 4:
          return js(), null;
        case 10:
          return bc(l.type._context), null;
        case 22:
        case 23:
          return Vr(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var $s = !1, Ss = !1, AS = typeof WeakSet == "function" ? WeakSet : Set, ft = null;
    function tl(o, l) {
      var v = o.ref;
      if (v !== null)
        if (typeof v == "function")
          try {
            v(null);
          } catch (S) {
            pn(o, l, S);
          }
        else
          v.current = null;
    }
    function eo(o, l, v) {
      try {
        v();
      } catch (S) {
        pn(o, l, S);
      }
    }
    var tm = !1;
    function nm(o, l) {
      for (J(o.containerInfo), ft = l; ft !== null; )
        if (o = ft, l = o.child, (o.subtreeFlags & 1028) !== 0 && l !== null)
          l.return = o, ft = l;
        else
          for (; ft !== null; ) {
            o = ft;
            try {
              var v = o.alternate;
              if (o.flags & 1024)
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (v !== null) {
                      var S = v.memoizedProps, C = v.memoizedState, D = o.stateNode, Z = D.getSnapshotBeforeUpdate(o.elementType === o.type ? S : Kr(o.type, S), C);
                      D.__reactInternalSnapshotBeforeUpdate = Z;
                    }
                    break;
                  case 3:
                    At && tt(o.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(c(163));
                }
            } catch (ue) {
              pn(o, o.return, ue);
            }
            if (l = o.sibling, l !== null) {
              l.return = o.return, ft = l;
              break;
            }
            ft = o.return;
          }
      return v = tm, tm = !1, v;
    }
    function to(o, l, v) {
      var S = l.updateQueue;
      if (S = S !== null ? S.lastEffect : null, S !== null) {
        var C = S = S.next;
        do {
          if ((C.tag & o) === o) {
            var D = C.destroy;
            C.destroy = void 0, D !== void 0 && eo(l, v, D);
          }
          C = C.next;
        } while (C !== S);
      }
    }
    function no(o, l) {
      if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
        var v = l = l.next;
        do {
          if ((v.tag & o) === o) {
            var S = v.create;
            v.destroy = S();
          }
          v = v.next;
        } while (v !== l);
      }
    }
    function kd(o) {
      var l = o.ref;
      if (l !== null) {
        var v = o.stateNode;
        switch (o.tag) {
          case 5:
            o = Me(v);
            break;
          default:
            o = v;
        }
        typeof l == "function" ? l(o) : l.current = o;
      }
    }
    function Vd(o, l, v) {
      if (ya && typeof ya.onCommitFiberUnmount == "function")
        try {
          ya.onCommitFiberUnmount(_c, l);
        } catch {
        }
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (o = l.updateQueue, o !== null && (o = o.lastEffect, o !== null)) {
            var S = o = o.next;
            do {
              var C = S, D = C.destroy;
              C = C.tag, D !== void 0 && (C & 2 || C & 4) && eo(l, v, D), S = S.next;
            } while (S !== o);
          }
          break;
        case 1:
          if (tl(l, v), o = l.stateNode, typeof o.componentWillUnmount == "function")
            try {
              o.props = l.memoizedProps, o.state = l.memoizedState, o.componentWillUnmount();
            } catch (Z) {
              pn(
                l,
                v,
                Z
              );
            }
          break;
        case 5:
          tl(l, v);
          break;
        case 4:
          At ? fi(o, l, v) : Ne && Ne && (l = l.stateNode.containerInfo, v = an(l), Bt(l, v));
      }
    }
    function Gd(o, l, v) {
      for (var S = l; ; )
        if (Vd(o, S, v), S.child === null || At && S.tag === 4) {
          if (S === l)
            break;
          for (; S.sibling === null; ) {
            if (S.return === null || S.return === l)
              return;
            S = S.return;
          }
          S.sibling.return = S.return, S = S.sibling;
        } else
          S.child.return = S, S = S.child;
    }
    function aa(o) {
      var l = o.alternate;
      l !== null && (o.alternate = null, aa(l)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (l = o.stateNode, l !== null && wt(l)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
    }
    function nl(o) {
      return o.tag === 5 || o.tag === 3 || o.tag === 4;
    }
    function il(o) {
      e:
        for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || nl(o.return))
              return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
            if (o.flags & 2 || o.child === null || o.tag === 4)
              continue e;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & 2))
            return o.stateNode;
        }
    }
    function Qc(o) {
      if (At) {
        e: {
          for (var l = o.return; l !== null; ) {
            if (nl(l))
              break e;
            l = l.return;
          }
          throw Error(c(160));
        }
        var v = l;
        switch (v.tag) {
          case 5:
            l = v.stateNode, v.flags & 32 && (ie(l), v.flags &= -33), v = il(o), br(o, v, l);
            break;
          case 3:
          case 4:
            l = v.stateNode.containerInfo, v = il(o), io(o, v, l);
            break;
          default:
            throw Error(c(161));
        }
      }
    }
    function io(o, l, v) {
      var S = o.tag;
      if (S === 5 || S === 6)
        o = o.stateNode, l ? He(v, o, l) : te(v, o);
      else if (S !== 4 && (o = o.child, o !== null))
        for (io(o, l, v), o = o.sibling; o !== null; )
          io(o, l, v), o = o.sibling;
    }
    function br(o, l, v) {
      var S = o.tag;
      if (S === 5 || S === 6)
        o = o.stateNode, l ? Ee(v, o, l) : Et(v, o);
      else if (S !== 4 && (o = o.child, o !== null))
        for (br(o, l, v), o = o.sibling; o !== null; )
          br(o, l, v), o = o.sibling;
    }
    function fi(o, l, v) {
      for (var S = l, C = !1, D, Z; ; ) {
        if (!C) {
          C = S.return;
          e:
            for (; ; ) {
              if (C === null)
                throw Error(c(160));
              switch (D = C.stateNode, C.tag) {
                case 5:
                  Z = !1;
                  break e;
                case 3:
                  D = D.containerInfo, Z = !0;
                  break e;
                case 4:
                  D = D.containerInfo, Z = !0;
                  break e;
              }
              C = C.return;
            }
          C = !0;
        }
        if (S.tag === 5 || S.tag === 6)
          Gd(o, S, v), Z ? Tt(D, S.stateNode) : Fe(D, S.stateNode);
        else if (S.tag === 18)
          Z ? Ut(D, S.stateNode) : Mt(D, S.stateNode);
        else if (S.tag === 4) {
          if (S.child !== null) {
            D = S.stateNode.containerInfo, Z = !0, S.child.return = S, S = S.child;
            continue;
          }
        } else if (Vd(o, S, v), S.child !== null) {
          S.child.return = S, S = S.child;
          continue;
        }
        if (S === l)
          break;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === l)
            return;
          S = S.return, S.tag === 4 && (C = !1);
        }
        S.sibling.return = S.return, S = S.sibling;
      }
    }
    function Wd(o, l) {
      if (At) {
        switch (l.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            to(3, l, l.return), no(3, l), to(5, l, l.return);
            return;
          case 1:
            return;
          case 5:
            var v = l.stateNode;
            if (v != null) {
              var S = l.memoizedProps;
              o = o !== null ? o.memoizedProps : S;
              var C = l.type, D = l.updateQueue;
              l.updateQueue = null, D !== null && pe(v, D, C, o, S, l);
            }
            return;
          case 6:
            if (l.stateNode === null)
              throw Error(c(162));
            v = l.memoizedProps, he(l.stateNode, o !== null ? o.memoizedProps : v, v);
            return;
          case 3:
            we && o !== null && o.memoizedState.isDehydrated && ht(l.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Kc(l);
            return;
          case 19:
            Kc(l);
            return;
          case 17:
            return;
        }
        throw Error(c(163));
      }
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          to(3, l, l.return), no(3, l), to(5, l, l.return);
          return;
        case 12:
          return;
        case 13:
          Kc(l);
          return;
        case 19:
          Kc(l);
          return;
        case 3:
          we && o !== null && o.memoizedState.isDehydrated && ht(l.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e:
        if (Ne) {
          switch (l.tag) {
            case 1:
            case 5:
            case 6:
              break e;
            case 3:
            case 4:
              l = l.stateNode, Bt(l.containerInfo, l.pendingChildren);
              break e;
          }
          throw Error(c(163));
        }
    }
    function Kc(o) {
      var l = o.updateQueue;
      if (l !== null) {
        o.updateQueue = null;
        var v = o.stateNode;
        v === null && (v = o.stateNode = new AS()), l.forEach(function(S) {
          var C = oo.bind(null, o, S);
          v.has(S) || (v.add(S), S.then(C, C));
        });
      }
    }
    function ty(o, l) {
      for (ft = l; ft !== null; ) {
        l = ft;
        var v = l.deletions;
        if (v !== null)
          for (var S = 0; S < v.length; S++) {
            var C = v[S];
            try {
              var D = o;
              At ? fi(D, C, l) : Gd(D, C, l);
              var Z = C.alternate;
              Z !== null && (Z.return = null), C.return = null;
            } catch (bt) {
              pn(C, l, bt);
            }
          }
        if (v = l.child, l.subtreeFlags & 12854 && v !== null)
          v.return = l, ft = v;
        else
          for (; ft !== null; ) {
            l = ft;
            try {
              var ue = l.flags;
              if (ue & 32 && At && ie(l.stateNode), ue & 512) {
                var Le = l.alternate;
                if (Le !== null) {
                  var Ze = Le.ref;
                  Ze !== null && (typeof Ze == "function" ? Ze(null) : Ze.current = null);
                }
              }
              if (ue & 8192)
                switch (l.tag) {
                  case 13:
                    if (l.memoizedState !== null) {
                      var it = l.alternate;
                      (it === null || it.memoizedState === null) && (Qd = Gn());
                    }
                    break;
                  case 22:
                    var It = l.memoizedState !== null, Nt = l.alternate, Rn = Nt !== null && Nt.memoizedState !== null;
                    if (v = l, At) {
                      e:
                        if (S = v, C = It, D = null, At)
                          for (var Lt = S; ; ) {
                            if (Lt.tag === 5) {
                              if (D === null) {
                                D = Lt;
                                var Ri = Lt.stateNode;
                                C ? Re(Ri) : Ae(Lt.stateNode, Lt.memoizedProps);
                              }
                            } else if (Lt.tag === 6) {
                              if (D === null) {
                                var Wi = Lt.stateNode;
                                C ? fe(Wi) : Be(Wi, Lt.memoizedProps);
                              }
                            } else if ((Lt.tag !== 22 && Lt.tag !== 23 || Lt.memoizedState === null || Lt === S) && Lt.child !== null) {
                              Lt.child.return = Lt, Lt = Lt.child;
                              continue;
                            }
                            if (Lt === S)
                              break;
                            for (; Lt.sibling === null; ) {
                              if (Lt.return === null || Lt.return === S)
                                break e;
                              D === Lt && (D = null), Lt = Lt.return;
                            }
                            D === Lt && (D = null), Lt.sibling.return = Lt.return, Lt = Lt.sibling;
                          }
                    }
                    if (It && !Rn && v.mode & 1) {
                      ft = v;
                      for (var xe = v.child; xe !== null; ) {
                        for (v = ft = xe; ft !== null; ) {
                          S = ft;
                          var ce = S.child;
                          switch (S.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              to(4, S, S.return);
                              break;
                            case 1:
                              tl(S, S.return);
                              var Te = S.stateNode;
                              if (typeof Te.componentWillUnmount == "function") {
                                var ct = S.return;
                                try {
                                  Te.props = S.memoizedProps, Te.state = S.memoizedState, Te.componentWillUnmount();
                                } catch (bt) {
                                  pn(
                                    S,
                                    ct,
                                    bt
                                  );
                                }
                              }
                              break;
                            case 5:
                              tl(S, S.return);
                              break;
                            case 22:
                              if (S.memoizedState !== null) {
                                rm(v);
                                continue;
                              }
                          }
                          ce !== null ? (ce.return = S, ft = ce) : rm(v);
                        }
                        xe = xe.sibling;
                      }
                    }
                }
              switch (ue & 4102) {
                case 2:
                  Qc(l), l.flags &= -3;
                  break;
                case 6:
                  Qc(l), l.flags &= -3, Wd(l.alternate, l);
                  break;
                case 4096:
                  l.flags &= -4097;
                  break;
                case 4100:
                  l.flags &= -4097, Wd(l.alternate, l);
                  break;
                case 4:
                  Wd(l.alternate, l);
              }
            } catch (bt) {
              pn(l, l.return, bt);
            }
            if (v = l.sibling, v !== null) {
              v.return = l.return, ft = v;
              break;
            }
            ft = l.return;
          }
      }
    }
    function im(o, l, v) {
      ft = o, qd(o);
    }
    function qd(o, l, v) {
      for (var S = (o.mode & 1) !== 0; ft !== null; ) {
        var C = ft, D = C.child;
        if (C.tag === 22 && S) {
          var Z = C.memoizedState !== null || $s;
          if (!Z) {
            var ue = C.alternate, Le = ue !== null && ue.memoizedState !== null || Ss;
            ue = $s;
            var Ze = Ss;
            if ($s = Z, (Ss = Le) && !Ze)
              for (ft = C; ft !== null; )
                Z = ft, Le = Z.child, Z.tag === 22 && Z.memoizedState !== null ? am(C) : Le !== null ? (Le.return = Z, ft = Le) : am(C);
            for (; D !== null; )
              ft = D, qd(D), D = D.sibling;
            ft = C, $s = ue, Ss = Ze;
          }
          jd(o);
        } else
          C.subtreeFlags & 8772 && D !== null ? (D.return = C, ft = D) : jd(o);
      }
    }
    function jd(o) {
      for (; ft !== null; ) {
        var l = ft;
        if (l.flags & 8772) {
          var v = l.alternate;
          try {
            if (l.flags & 8772)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  Ss || no(5, l);
                  break;
                case 1:
                  var S = l.stateNode;
                  if (l.flags & 4 && !Ss)
                    if (v === null)
                      S.componentDidMount();
                    else {
                      var C = l.elementType === l.type ? v.memoizedProps : Kr(l.type, v.memoizedProps);
                      S.componentDidUpdate(C, v.memoizedState, S.__reactInternalSnapshotBeforeUpdate);
                    }
                  var D = l.updateQueue;
                  D !== null && Vp(l, D, S);
                  break;
                case 3:
                  var Z = l.updateQueue;
                  if (Z !== null) {
                    if (v = null, l.child !== null)
                      switch (l.child.tag) {
                        case 5:
                          v = Me(l.child.stateNode);
                          break;
                        case 1:
                          v = l.child.stateNode;
                      }
                    Vp(l, Z, v);
                  }
                  break;
                case 5:
                  var ue = l.stateNode;
                  v === null && l.flags & 4 && ae(ue, l.type, l.memoizedProps, l);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (we && l.memoizedState === null) {
                    var Le = l.alternate;
                    if (Le !== null) {
                      var Ze = Le.memoizedState;
                      if (Ze !== null) {
                        var it = Ze.dehydrated;
                        it !== null && Ct(it);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(c(163));
              }
            Ss || l.flags & 512 && kd(l);
          } catch (It) {
            pn(l, l.return, It);
          }
        }
        if (l === o) {
          ft = null;
          break;
        }
        if (v = l.sibling, v !== null) {
          v.return = l.return, ft = v;
          break;
        }
        ft = l.return;
      }
    }
    function rm(o) {
      for (; ft !== null; ) {
        var l = ft;
        if (l === o) {
          ft = null;
          break;
        }
        var v = l.sibling;
        if (v !== null) {
          v.return = l.return, ft = v;
          break;
        }
        ft = l.return;
      }
    }
    function am(o) {
      for (; ft !== null; ) {
        var l = ft;
        try {
          switch (l.tag) {
            case 0:
            case 11:
            case 15:
              var v = l.return;
              try {
                no(4, l);
              } catch (Le) {
                pn(l, v, Le);
              }
              break;
            case 1:
              var S = l.stateNode;
              if (typeof S.componentDidMount == "function") {
                var C = l.return;
                try {
                  S.componentDidMount();
                } catch (Le) {
                  pn(l, C, Le);
                }
              }
              var D = l.return;
              try {
                kd(l);
              } catch (Le) {
                pn(l, D, Le);
              }
              break;
            case 5:
              var Z = l.return;
              try {
                kd(l);
              } catch (Le) {
                pn(l, Z, Le);
              }
          }
        } catch (Le) {
          pn(l, l.return, Le);
        }
        if (l === o) {
          ft = null;
          break;
        }
        var ue = l.sibling;
        if (ue !== null) {
          ue.return = l.return, ft = ue;
          break;
        }
        ft = l.return;
      }
    }
    var $c = 0, Yn = 1, ro = 2, du = 3, $a = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var rl = Symbol.for;
      $c = rl("selector.component"), Yn = rl("selector.has_pseudo_class"), ro = rl("selector.role"), du = rl("selector.test_id"), $a = rl("selector.text");
    }
    function Yd(o) {
      var l = ke(o);
      if (l != null) {
        if (typeof l.memoizedProps["data-testname"] != "string")
          throw Error(c(364));
        return l;
      }
      if (o = Gt(o), o === null)
        throw Error(c(362));
      return o.stateNode.current;
    }
    function Xd(o, l) {
      switch (l.$$typeof) {
        case $c:
          if (o.type === l.value)
            return !0;
          break;
        case Yn:
          e: {
            l = l.value, o = [o, 0];
            for (var v = 0; v < o.length; ) {
              var S = o[v++], C = o[v++], D = l[C];
              if (S.tag !== 5 || !be(S)) {
                for (; D != null && Xd(S, D); )
                  C++, D = l[C];
                if (C === l.length) {
                  l = !0;
                  break e;
                } else
                  for (S = S.child; S !== null; )
                    o.push(S, C), S = S.sibling;
              }
            }
            l = !1;
          }
          return l;
        case ro:
          if (o.tag === 5 && qe(o.stateNode, l.value))
            return !0;
          break;
        case $a:
          if ((o.tag === 5 || o.tag === 6) && (o = H(o), o !== null && 0 <= o.indexOf(l.value)))
            return !0;
          break;
        case du:
          if (o.tag === 5 && (o = o.memoizedProps["data-testname"], typeof o == "string" && o.toLowerCase() === l.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(c(365));
      }
      return !1;
    }
    function Ms(o) {
      switch (o.$$typeof) {
        case $c:
          return "<" + (W(o.value) || "Unknown") + ">";
        case Yn:
          return ":has(" + (Ms(o) || "") + ")";
        case ro:
          return '[role="' + o.value + '"]';
        case $a:
          return '"' + o.value + '"';
        case du:
          return '[data-testname="' + o.value + '"]';
        default:
          throw Error(c(365));
      }
    }
    function Ti(o, l) {
      var v = [];
      o = [o, 0];
      for (var S = 0; S < o.length; ) {
        var C = o[S++], D = o[S++], Z = l[D];
        if (C.tag !== 5 || !be(C)) {
          for (; Z != null && Xd(C, Z); )
            D++, Z = l[D];
          if (D === l.length)
            v.push(C);
          else
            for (C = C.child; C !== null; )
              o.push(C, D), C = C.sibling;
        }
      }
      return v;
    }
    function ut(o, l) {
      if (!kt)
        throw Error(c(363));
      o = Yd(o), o = Ti(o, l), l = [], o = Array.from(o);
      for (var v = 0; v < o.length; ) {
        var S = o[v++];
        if (S.tag === 5)
          be(S) || l.push(S.stateNode);
        else
          for (S = S.child; S !== null; )
            o.push(S), S = S.sibling;
      }
      return l;
    }
    var Ra = Math.ceil, rr = f.ReactCurrentDispatcher, Zd = f.ReactCurrentOwner, Xn = f.ReactCurrentBatchConfig, Xt = 0, ii = null, ri = null, ln = 0, wr = 0, al = tr(0), di = 0, sl = null, Aa = 0, es = 0, Jd = 0, hu = null, ar = null, Qd = 0, Kd = 1 / 0;
    function ol() {
      Kd = Gn() + 500;
    }
    var pu = !1, ef = null, bs = null, tf = !1, ws = null, nf = 0, mu = 0, $d = null, vu = -1, rf = 0;
    function Bi() {
      return Xt & 6 ? Gn() : vu !== -1 ? vu : vu = Gn();
    }
    function Es(o) {
      return o.mode & 1 ? Xt & 2 && ln !== 0 ? ln & -ln : Kg.transition !== null ? (rf === 0 && (o = gc, gc <<= 1, !(gc & 4194240) && (gc = 64), rf = o), rf) : (o = dn, o !== 0 ? o : Xe()) : 1;
    }
    function kr(o, l, v) {
      if (50 < mu)
        throw mu = 0, $d = null, Error(c(185));
      var S = ll(o, l);
      return S === null ? null : (Xl(S, l, v), (!(Xt & 2) || S !== ii) && (S === ii && (!(Xt & 2) && (es |= l), di === 4 && ts(S, ln)), sr(S, v), l === 1 && Xt === 0 && !(o.mode & 1) && (ol(), xc && xa())), S);
    }
    function ll(o, l) {
      o.lanes |= l;
      var v = o.alternate;
      for (v !== null && (v.lanes |= l), v = o, o = o.return; o !== null; )
        o.childLanes |= l, v = o.alternate, v !== null && (v.childLanes |= l), v = o, o = o.return;
      return v.tag === 3 ? v.stateNode : null;
    }
    function sr(o, l) {
      var v = o.callbackNode;
      Yl(o, l);
      var S = yc(o, o === ii ? ln : 0);
      if (S === 0)
        v !== null && Hp(v), o.callbackNode = null, o.callbackPriority = 0;
      else if (l = S & -S, o.callbackPriority !== l) {
        if (v != null && Hp(v), l === 1)
          o.tag === 0 ? Qg(sm.bind(null, o)) : xd(sm.bind(null, o)), St ? pt(function() {
            Xt === 0 && xa();
          }) : vs(gd, xa), v = null;
        else {
          switch (Bp(S)) {
            case 1:
              v = gd;
              break;
            case 4:
              v = Yg;
              break;
            case 16:
              v = yd;
              break;
            case 536870912:
              v = Xg;
              break;
            default:
              v = yd;
          }
          v = cl(v, Er.bind(null, o));
        }
        o.callbackPriority = l, o.callbackNode = v;
      }
    }
    function Er(o, l) {
      if (vu = -1, rf = 0, Xt & 6)
        throw Error(c(327));
      var v = o.callbackNode;
      if (so() && o.callbackNode !== v)
        return null;
      var S = yc(o, o === ii ? ln : 0);
      if (S === 0)
        return null;
      if (S & 30 || S & o.expiredLanes || l)
        l = ao(o, S);
      else {
        l = S;
        var C = Xt;
        Xt |= 2;
        var D = lm();
        (ii !== o || ln !== l) && (ol(), Ts(o, l));
        do
          try {
            um();
            break;
          } catch (ue) {
            om(o, ue);
          }
        while (1);
        Sd(), rr.current = D, Xt = C, ri !== null ? l = 0 : (ii = null, ln = 0, l = di);
      }
      if (l !== 0) {
        if (l === 2 && (C = Gi(o), C !== 0 && (S = C, l = sa(o, C))), l === 1)
          throw v = sl, Ts(o, 0), ts(o, S), sr(o, Gn()), v;
        if (l === 6)
          ts(o, S);
        else {
          if (C = o.current.alternate, !(S & 30) && !eh(C) && (l = ao(o, S), l === 2 && (D = Gi(o), D !== 0 && (S = D, l = sa(o, D))), l === 1))
            throw v = sl, Ts(o, 0), ts(o, S), sr(o, Gn()), v;
          switch (o.finishedWork = C, o.finishedLanes = S, l) {
            case 0:
            case 1:
              throw Error(c(345));
            case 2:
              oa(o, ar);
              break;
            case 3:
              if (ts(o, S), (S & 130023424) === S && (l = Qd + 500 - Gn(), 10 < l)) {
                if (yc(o, 0) !== 0)
                  break;
                if (C = o.suspendedLanes, (C & S) !== S) {
                  Bi(), o.pingedLanes |= o.suspendedLanes & C;
                  break;
                }
                o.timeoutHandle = gt(oa.bind(null, o, ar), l);
                break;
              }
              oa(o, ar);
              break;
            case 4:
              if (ts(o, S), (S & 4194240) === S)
                break;
              for (l = o.eventTimes, C = -1; 0 < S; ) {
                var Z = 31 - Nr(S);
                D = 1 << Z, Z = l[Z], Z > C && (C = Z), S &= ~D;
              }
              if (S = C, S = Gn() - S, S = (120 > S ? 120 : 480 > S ? 480 : 1080 > S ? 1080 : 1920 > S ? 1920 : 3e3 > S ? 3e3 : 4320 > S ? 4320 : 1960 * Ra(S / 1960)) - S, 10 < S) {
                o.timeoutHandle = gt(oa.bind(null, o, ar), S);
                break;
              }
              oa(o, ar);
              break;
            case 5:
              oa(o, ar);
              break;
            default:
              throw Error(c(329));
          }
        }
      }
      return sr(o, Gn()), o.callbackNode === v ? Er.bind(null, o) : null;
    }
    function sa(o, l) {
      var v = hu;
      return o.current.memoizedState.isDehydrated && (Ts(o, l).flags |= 256), o = ao(o, l), o !== 2 && (l = ar, ar = v, l !== null && gu(l)), o;
    }
    function gu(o) {
      ar === null ? ar = o : ar.push.apply(ar, o);
    }
    function eh(o) {
      for (var l = o; ; ) {
        if (l.flags & 16384) {
          var v = l.updateQueue;
          if (v !== null && (v = v.stores, v !== null))
            for (var S = 0; S < v.length; S++) {
              var C = v[S], D = C.getSnapshot;
              C = C.value;
              try {
                if (!_a(D(), C))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (v = l.child, l.subtreeFlags & 16384 && v !== null)
          v.return = l, l = v;
        else {
          if (l === o)
            break;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === o)
              return !0;
            l = l.return;
          }
          l.sibling.return = l.return, l = l.sibling;
        }
      }
      return !0;
    }
    function ts(o, l) {
      for (l &= ~Jd, l &= ~es, o.suspendedLanes |= l, o.pingedLanes &= ~l, o = o.expirationTimes; 0 < l; ) {
        var v = 31 - Nr(l), S = 1 << v;
        o[v] = -1, l &= ~S;
      }
    }
    function sm(o) {
      if (Xt & 6)
        throw Error(c(327));
      so();
      var l = yc(o, 0);
      if (!(l & 1))
        return sr(o, Gn()), null;
      var v = ao(o, l);
      if (o.tag !== 0 && v === 2) {
        var S = Gi(o);
        S !== 0 && (l = S, v = sa(o, S));
      }
      if (v === 1)
        throw v = sl, Ts(o, 0), ts(o, l), sr(o, Gn()), v;
      if (v === 6)
        throw Error(c(345));
      return o.finishedWork = o.current.alternate, o.finishedLanes = l, oa(o, ar), sr(o, Gn()), null;
    }
    function th(o) {
      ws !== null && ws.tag === 0 && !(Xt & 6) && so();
      var l = Xt;
      Xt |= 1;
      var v = Xn.transition, S = dn;
      try {
        if (Xn.transition = null, dn = 1, o)
          return o();
      } finally {
        dn = S, Xn.transition = v, Xt = l, !(Xt & 6) && xa();
      }
    }
    function Vr() {
      wr = al.current, Vt(al);
    }
    function Ts(o, l) {
      o.finishedWork = null, o.finishedLanes = 0;
      var v = o.timeoutHandle;
      if (v !== _t && (o.timeoutHandle = _t, ot(v)), ri !== null)
        for (v = ri.return; v !== null; ) {
          var S = v;
          switch (Cd(S), S.tag) {
            case 1:
              S = S.type.childContextTypes, S != null && vc();
              break;
            case 3:
              js(), Vt(yn), Vt(gn), Ma();
              break;
            case 5:
              Mr(S);
              break;
            case 4:
              js();
              break;
            case 13:
              Vt(On);
              break;
            case 19:
              Vt(On);
              break;
            case 10:
              bc(S.type._context);
              break;
            case 22:
            case 23:
              Vr();
          }
          v = v.return;
        }
      if (ii = o, ri = o = or(o.current, null), ln = wr = l, di = 0, sl = null, Jd = es = Aa = 0, ar = hu = null, $r !== null) {
        for (l = 0; l < $r.length; l++)
          if (v = $r[l], S = v.interleaved, S !== null) {
            v.interleaved = null;
            var C = S.next, D = v.pending;
            if (D !== null) {
              var Z = D.next;
              D.next = C, S.next = Z;
            }
            v.pending = S;
          }
        $r = null;
      }
      return o;
    }
    function om(o, l) {
      do {
        var v = ri;
        try {
          if (Sd(), li.current = Zo, ko) {
            for (var S = on.memoizedState; S !== null; ) {
              var C = S.queue;
              C !== null && (C.pending = null), S = S.next;
            }
            ko = !1;
          }
          if (_s = 0, Cn = Hn = on = null, ba = !1, Vo = 0, Zd.current = null, v === null || v.return === null) {
            di = 1, sl = l, ri = null;
            break;
          }
          e: {
            var D = o, Z = v.return, ue = v, Le = l;
            if (l = ln, ue.flags |= 32768, Le !== null && typeof Le == "object" && typeof Le.then == "function") {
              var Ze = Le, it = ue, It = it.tag;
              if (!(it.mode & 1) && (It === 0 || It === 11 || It === 15)) {
                var Nt = it.alternate;
                Nt ? (it.updateQueue = Nt.updateQueue, it.memoizedState = Nt.memoizedState, it.lanes = Nt.lanes) : (it.updateQueue = null, it.memoizedState = null);
              }
              var Rn = Js(Z);
              if (Rn !== null) {
                Rn.flags &= -257, Wc(Rn, Z, ue, D, l), Rn.mode & 1 && uu(D, Ze, l), l = Rn, Le = Ze;
                var Lt = l.updateQueue;
                if (Lt === null) {
                  var Ri = /* @__PURE__ */ new Set();
                  Ri.add(Le), l.updateQueue = Ri;
                } else
                  Lt.add(Le);
                break e;
              } else {
                if (!(l & 1)) {
                  uu(D, Ze, l), nh();
                  break e;
                }
                Le = Error(c(426));
              }
            } else if (zn && ue.mode & 1) {
              var Wi = Js(Z);
              if (Wi !== null) {
                !(Wi.flags & 65536) && (Wi.flags |= 256), Wc(Wi, Z, ue, D, l), $l(Le);
                break e;
              }
            }
            D = Le, di !== 4 && (di = 2), hu === null ? hu = [D] : hu.push(D), Le = ou(Le, ue), ue = Z;
            do {
              switch (ue.tag) {
                case 3:
                  ue.flags |= 65536, l &= -l, ue.lanes |= l;
                  var xe = Vc(ue, Le, l);
                  kp(ue, xe);
                  break e;
                case 1:
                  D = Le;
                  var ce = ue.type, Te = ue.stateNode;
                  if (!(ue.flags & 128) && (typeof ce.getDerivedStateFromError == "function" || Te !== null && typeof Te.componentDidCatch == "function" && (bs === null || !bs.has(Te)))) {
                    ue.flags |= 65536, l &= -l, ue.lanes |= l;
                    var ct = Gc(ue, D, l);
                    kp(ue, ct);
                    break e;
                  }
              }
              ue = ue.return;
            } while (ue !== null);
          }
          Tr(v);
        } catch (bt) {
          l = bt, ri === v && v !== null && (ri = v = v.return);
          continue;
        }
        break;
      } while (1);
    }
    function lm() {
      var o = rr.current;
      return rr.current = Zo, o === null ? Zo : o;
    }
    function nh() {
      (di === 0 || di === 3 || di === 2) && (di = 4), ii === null || !(Aa & 268435455) && !(es & 268435455) || ts(ii, ln);
    }
    function ao(o, l) {
      var v = Xt;
      Xt |= 2;
      var S = lm();
      ii === o && ln === l || Ts(o, l);
      do
        try {
          ny();
          break;
        } catch (C) {
          om(o, C);
        }
      while (1);
      if (Sd(), Xt = v, rr.current = S, ri !== null)
        throw Error(c(261));
      return ii = null, ln = 0, di;
    }
    function ny() {
      for (; ri !== null; )
        ih(ri);
    }
    function um() {
      for (; ri !== null && !qg(); )
        ih(ri);
    }
    function ih(o) {
      var l = ul(o.alternate, o, wr);
      o.memoizedProps = o.pendingProps, l === null ? Tr(o) : ri = l, Zd.current = null;
    }
    function Tr(o) {
      var l = o;
      do {
        var v = l.alternate;
        if (o = l.return, l.flags & 32768) {
          if (v = Wt(v, l), v !== null) {
            v.flags &= 32767, ri = v;
            return;
          }
          if (o !== null)
            o.flags |= 32768, o.subtreeFlags = 0, o.deletions = null;
          else {
            di = 6, ri = null;
            return;
          }
        } else if (v = ey(v, l, wr), v !== null) {
          ri = v;
          return;
        }
        if (l = l.sibling, l !== null) {
          ri = l;
          return;
        }
        ri = l = o;
      } while (l !== null);
      di === 0 && (di = 5);
    }
    function oa(o, l) {
      var v = dn, S = Xn.transition;
      try {
        Xn.transition = null, dn = 1, iy(o, l, v);
      } finally {
        Xn.transition = S, dn = v;
      }
      return null;
    }
    function iy(o, l, v) {
      do
        so();
      while (ws !== null);
      if (Xt & 6)
        throw Error(c(327));
      var S = o.finishedWork, C = o.finishedLanes;
      if (S === null)
        return null;
      if (o.finishedWork = null, o.finishedLanes = 0, S === o.current)
        throw Error(c(177));
      o.callbackNode = null, o.callbackPriority = 0;
      var D = S.lanes | S.childLanes;
      if (Wg(o, D), o === ii && (ri = ii = null, ln = 0), !(S.subtreeFlags & 2064) && !(S.flags & 2064) || tf || (tf = !0, cl(yd, function() {
        return so(), null;
      })), D = (S.flags & 15990) !== 0, S.subtreeFlags & 15990 || D) {
        D = Xn.transition, Xn.transition = null;
        var Z = dn;
        dn = 1;
        var ue = Xt;
        Xt |= 4, Zd.current = null, nm(o, S), ty(o, S), Y(o.containerInfo), o.current = S, im(S), jg(), Xt = ue, dn = Z, Xn.transition = D;
      } else
        o.current = S;
      if (tf && (tf = !1, ws = o, nf = C), D = o.pendingLanes, D === 0 && (bs = null), Zg(S.stateNode), sr(o, Gn()), l !== null)
        for (v = o.onRecoverableError, S = 0; S < l.length; S++)
          v(l[S]);
      if (pu)
        throw pu = !1, o = ef, ef = null, o;
      return nf & 1 && o.tag !== 0 && so(), D = o.pendingLanes, D & 1 ? o === $d ? mu++ : (mu = 0, $d = o) : mu = 0, xa(), null;
    }
    function so() {
      if (ws !== null) {
        var o = Bp(nf), l = Xn.transition, v = dn;
        try {
          if (Xn.transition = null, dn = 16 > o ? 16 : o, ws === null)
            var S = !1;
          else {
            if (o = ws, ws = null, nf = 0, Xt & 6)
              throw Error(c(331));
            var C = Xt;
            for (Xt |= 4, ft = o.current; ft !== null; ) {
              var D = ft, Z = D.child;
              if (ft.flags & 16) {
                var ue = D.deletions;
                if (ue !== null) {
                  for (var Le = 0; Le < ue.length; Le++) {
                    var Ze = ue[Le];
                    for (ft = Ze; ft !== null; ) {
                      var it = ft;
                      switch (it.tag) {
                        case 0:
                        case 11:
                        case 15:
                          to(8, it, D);
                      }
                      var It = it.child;
                      if (It !== null)
                        It.return = it, ft = It;
                      else
                        for (; ft !== null; ) {
                          it = ft;
                          var Nt = it.sibling, Rn = it.return;
                          if (aa(it), it === Ze) {
                            ft = null;
                            break;
                          }
                          if (Nt !== null) {
                            Nt.return = Rn, ft = Nt;
                            break;
                          }
                          ft = Rn;
                        }
                    }
                  }
                  var Lt = D.alternate;
                  if (Lt !== null) {
                    var Ri = Lt.child;
                    if (Ri !== null) {
                      Lt.child = null;
                      do {
                        var Wi = Ri.sibling;
                        Ri.sibling = null, Ri = Wi;
                      } while (Ri !== null);
                    }
                  }
                  ft = D;
                }
              }
              if (D.subtreeFlags & 2064 && Z !== null)
                Z.return = D, ft = Z;
              else
                e:
                  for (; ft !== null; ) {
                    if (D = ft, D.flags & 2048)
                      switch (D.tag) {
                        case 0:
                        case 11:
                        case 15:
                          to(9, D, D.return);
                      }
                    var xe = D.sibling;
                    if (xe !== null) {
                      xe.return = D.return, ft = xe;
                      break e;
                    }
                    ft = D.return;
                  }
            }
            var ce = o.current;
            for (ft = ce; ft !== null; ) {
              Z = ft;
              var Te = Z.child;
              if (Z.subtreeFlags & 2064 && Te !== null)
                Te.return = Z, ft = Te;
              else
                e:
                  for (Z = ce; ft !== null; ) {
                    if (ue = ft, ue.flags & 2048)
                      try {
                        switch (ue.tag) {
                          case 0:
                          case 11:
                          case 15:
                            no(9, ue);
                        }
                      } catch (bt) {
                        pn(ue, ue.return, bt);
                      }
                    if (ue === Z) {
                      ft = null;
                      break e;
                    }
                    var ct = ue.sibling;
                    if (ct !== null) {
                      ct.return = ue.return, ft = ct;
                      break e;
                    }
                    ft = ue.return;
                  }
            }
            if (Xt = C, xa(), ya && typeof ya.onPostCommitFiberRoot == "function")
              try {
                ya.onPostCommitFiberRoot(_c, o);
              } catch {
              }
            S = !0;
          }
          return S;
        } finally {
          dn = v, Xn.transition = l;
        }
      }
      return !1;
    }
    function Ci(o, l, v) {
      l = ou(v, l), l = Vc(o, l, 1), gs(o, l), l = Bi(), o = ll(o, 1), o !== null && (Xl(o, 1, l), sr(o, l));
    }
    function pn(o, l, v) {
      if (o.tag === 3)
        Ci(o, o, v);
      else
        for (; l !== null; ) {
          if (l.tag === 3) {
            Ci(l, o, v);
            break;
          } else if (l.tag === 1) {
            var S = l.stateNode;
            if (typeof l.type.getDerivedStateFromError == "function" || typeof S.componentDidCatch == "function" && (bs === null || !bs.has(S))) {
              o = ou(v, o), o = Gc(l, o, 1), gs(l, o), o = Bi(), l = ll(l, 1), l !== null && (Xl(l, 1, o), sr(l, o));
              break;
            }
          }
          l = l.return;
        }
    }
    function La(o, l, v) {
      var S = o.pingCache;
      S !== null && S.delete(l), l = Bi(), o.pingedLanes |= o.suspendedLanes & v, ii === o && (ln & v) === v && (di === 4 || di === 3 && (ln & 130023424) === ln && 500 > Gn() - Qd ? Ts(o, 0) : Jd |= v), sr(o, l);
    }
    function Gr(o, l) {
      l === 0 && (o.mode & 1 ? (l = No, No <<= 1, !(No & 130023424) && (No = 4194304)) : l = 1);
      var v = Bi();
      o = ll(o, l), o !== null && (Xl(o, l, v), sr(o, v));
    }
    function ry(o) {
      var l = o.memoizedState, v = 0;
      l !== null && (v = l.retryLane), Gr(o, v);
    }
    function oo(o, l) {
      var v = 0;
      switch (o.tag) {
        case 13:
          var S = o.stateNode, C = o.memoizedState;
          C !== null && (v = C.retryLane);
          break;
        case 19:
          S = o.stateNode;
          break;
        default:
          throw Error(c(314));
      }
      S !== null && S.delete(l), Gr(o, v);
    }
    var ul;
    ul = function(o, l, v) {
      if (o !== null)
        if (o.memoizedProps !== l.pendingProps || yn.current)
          Fi = !0;
        else {
          if (!(o.lanes & v) && !(l.flags & 128))
            return Fi = !1, el(o, l, v);
          Fi = !!(o.flags & 131072);
        }
      else
        Fi = !1, zn && l.flags & 1048576 && Yp(l, Ac, l.index);
      switch (l.lanes = 0, l.tag) {
        case 2:
          var S = l.type;
          o !== null && (o.alternate = null, l.alternate = null, l.flags |= 2), o = l.pendingProps;
          var C = qa(l, gn.current);
          Oo(l, v), C = Wo(null, l, S, o, C, v);
          var D = ru();
          return l.flags |= 1, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, nr(S) ? (D = !0, Po(l)) : D = !1, l.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, wd(l), C.updater = Cc, l.stateNode = C, C._reactInternals = l, Ed(l, S, o, v), l = Bd(null, l, S, !0, D, v)) : (l.tag = 0, zn && D && Td(l), yi(null, l, C, v), l = l.child), l;
        case 16:
          S = l.elementType;
          e: {
            switch (o !== null && (o.alternate = null, l.alternate = null, l.flags |= 2), o = l.pendingProps, C = S._init, S = C(S._payload), l.type = S, C = l.tag = _u(S), o = Kr(S, o), C) {
              case 0:
                l = Fd(null, l, S, o, v);
                break e;
              case 1:
                l = jc(
                  null,
                  l,
                  S,
                  o,
                  v
                );
                break e;
              case 11:
                l = Ko(null, l, S, o, v);
                break e;
              case 14:
                l = fu(null, l, S, Kr(S.type, o), v);
                break e;
            }
            throw Error(c(306, S, ""));
          }
          return l;
        case 0:
          return S = l.type, C = l.pendingProps, C = l.elementType === S ? C : Kr(S, C), Fd(o, l, S, C, v);
        case 1:
          return S = l.type, C = l.pendingProps, C = l.elementType === S ? C : Kr(S, C), jc(o, l, S, C, v);
        case 3:
          e: {
            if (Yc(l), o === null)
              throw Error(c(387));
            S = l.pendingProps, D = l.memoizedState, C = D.element, Ql(o, l), Ec(l, S, null, v);
            var Z = l.memoizedState;
            if (S = Z.element, we && D.isDehydrated)
              if (D = {
                element: S,
                isDehydrated: !1,
                cache: Z.cache,
                transitions: Z.transitions
              }, l.updateQueue.baseState = D, l.memoizedState = D, l.flags & 256) {
                C = Error(c(423)), l = Hd(o, l, S, v, C);
                break e;
              } else if (S !== C) {
                C = Error(c(424)), l = Hd(o, l, S, v, C);
                break e;
              } else
                for (we && (Ei = Q(l.stateNode.containerInfo), Sr = l, zn = !0, Ur = null, Fo = !1), v = Nc(l, null, S, v), l.child = v; v; )
                  v.flags = v.flags & -3 | 4096, v = v.sibling;
            else {
              if (Bo(), S === C) {
                l = jn(o, l, v);
                break e;
              }
              yi(o, l, S, v);
            }
            l = l.child;
          }
          return l;
        case 5:
          return iu(l), o === null && Dc(l), S = l.type, C = l.pendingProps, D = o !== null ? o.memoizedProps : null, Z = C.children, $e(S, C) ? Z = null : D !== null && $e(S, D) && (l.flags |= 32), Qp(o, l), yi(o, l, Z, v), l.child;
        case 6:
          return o === null && Dc(l), null;
        case 13:
          return Kp(o, l, v);
        case 4:
          return zc(l, l.stateNode.containerInfo), S = l.pendingProps, o === null ? l.child = Ho(l, null, S, v) : yi(o, l, S, v), l.child;
        case 11:
          return S = l.type, C = l.pendingProps, C = l.elementType === S ? C : Kr(S, C), Ko(o, l, S, C, v);
        case 7:
          return yi(o, l, l.pendingProps, v), l.child;
        case 8:
          return yi(o, l, l.pendingProps.children, v), l.child;
        case 12:
          return yi(o, l, l.pendingProps.children, v), l.child;
        case 10:
          e: {
            if (S = l.type._context, C = l.pendingProps, D = l.memoizedProps, Z = C.value, Md(l, S, Z), D !== null)
              if (_a(D.value, Z)) {
                if (D.children === C.children && !yn.current) {
                  l = jn(o, l, v);
                  break e;
                }
              } else
                for (D = l.child, D !== null && (D.return = l); D !== null; ) {
                  var ue = D.dependencies;
                  if (ue !== null) {
                    Z = D.child;
                    for (var Le = ue.firstContext; Le !== null; ) {
                      if (Le.context === S) {
                        if (D.tag === 1) {
                          Le = Ya(-1, v & -v), Le.tag = 2;
                          var Ze = D.updateQueue;
                          if (Ze !== null) {
                            Ze = Ze.shared;
                            var it = Ze.pending;
                            it === null ? Le.next = Le : (Le.next = it.next, it.next = Le), Ze.pending = Le;
                          }
                        }
                        D.lanes |= v, Le = D.alternate, Le !== null && (Le.lanes |= v), bd(D.return, v, l), ue.lanes |= v;
                        break;
                      }
                      Le = Le.next;
                    }
                  } else if (D.tag === 10)
                    Z = D.type === l.type ? null : D.child;
                  else if (D.tag === 18) {
                    if (Z = D.return, Z === null)
                      throw Error(c(341));
                    Z.lanes |= v, ue = Z.alternate, ue !== null && (ue.lanes |= v), bd(Z, v, l), Z = D.sibling;
                  } else
                    Z = D.child;
                  if (Z !== null)
                    Z.return = D;
                  else
                    for (Z = D; Z !== null; ) {
                      if (Z === l) {
                        Z = null;
                        break;
                      }
                      if (D = Z.sibling, D !== null) {
                        D.return = Z.return, Z = D;
                        break;
                      }
                      Z = Z.return;
                    }
                  D = Z;
                }
            yi(o, l, C.children, v), l = l.child;
          }
          return l;
        case 9:
          return C = l.type, S = l.pendingProps.children, Oo(l, v), C = zr(C), S = S(C), l.flags |= 1, yi(o, l, S, v), l.child;
        case 14:
          return S = l.type, C = Kr(S, l.pendingProps), C = Kr(S.type, C), fu(o, l, S, C, v);
        case 15:
          return Zp(o, l, l.type, l.pendingProps, v);
        case 17:
          return S = l.type, C = l.pendingProps, C = l.elementType === S ? C : Kr(S, C), o !== null && (o.alternate = null, l.alternate = null, l.flags |= 2), l.tag = 1, nr(S) ? (o = !0, Po(l)) : o = !1, Oo(l, v), qp(l, S, C), Ed(l, S, C, v), Bd(null, l, S, !0, o, v);
        case 19:
          return Jc(o, l, v);
        case 22:
          return Jp(o, l, v);
      }
      throw Error(c(156, l.tag));
    };
    function cl(o, l) {
      return vs(o, l);
    }
    function yu(o, l, v, S) {
      this.tag = o, this.key = v, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = S, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Hi(o, l, v, S) {
      return new yu(o, l, v, S);
    }
    function lo(o) {
      return o = o.prototype, !(!o || !o.isReactComponent);
    }
    function _u(o) {
      if (typeof o == "function")
        return lo(o) ? 1 : 0;
      if (o != null) {
        if (o = o.$$typeof, o === E)
          return 11;
        if (o === A)
          return 14;
      }
      return 2;
    }
    function or(o, l) {
      var v = o.alternate;
      return v === null ? (v = Hi(o.tag, l, o.key, o.mode), v.elementType = o.elementType, v.type = o.type, v.stateNode = o.stateNode, v.alternate = o, o.alternate = v) : (v.pendingProps = l, v.type = o.type, v.flags = 0, v.subtreeFlags = 0, v.deletions = null), v.flags = o.flags & 14680064, v.childLanes = o.childLanes, v.lanes = o.lanes, v.child = o.child, v.memoizedProps = o.memoizedProps, v.memoizedState = o.memoizedState, v.updateQueue = o.updateQueue, l = o.dependencies, v.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, v.sibling = o.sibling, v.index = o.index, v.ref = o.ref, v;
    }
    function uo(o, l, v, S, C, D) {
      var Z = 2;
      if (S = o, typeof o == "function")
        lo(o) && (Z = 1);
      else if (typeof o == "string")
        Z = 5;
      else
        e:
          switch (o) {
            case g:
              return Cs(v.children, C, D, l);
            case _:
              Z = 8, C |= 8;
              break;
            case x:
              return o = Hi(12, v, l, C | 2), o.elementType = x, o.lanes = D, o;
            case w:
              return o = Hi(13, v, l, C), o.elementType = w, o.lanes = D, o;
            case R:
              return o = Hi(19, v, l, C), o.elementType = R, o.lanes = D, o;
            case N:
              return xu(v, C, D, l);
            default:
              if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                  case M:
                    Z = 10;
                    break e;
                  case b:
                    Z = 9;
                    break e;
                  case E:
                    Z = 11;
                    break e;
                  case A:
                    Z = 14;
                    break e;
                  case P:
                    Z = 16, S = null;
                    break e;
                }
              throw Error(c(130, o == null ? o : typeof o, ""));
          }
      return l = Hi(Z, v, l, C), l.elementType = o, l.type = S, l.lanes = D, l;
    }
    function Cs(o, l, v, S) {
      return o = Hi(7, o, S, l), o.lanes = v, o;
    }
    function xu(o, l, v, S) {
      return o = Hi(22, o, S, l), o.elementType = N, o.lanes = v, o.stateNode = {}, o;
    }
    function af(o, l, v) {
      return o = Hi(6, o, null, l), o.lanes = v, o;
    }
    function Su(o, l, v) {
      return l = Hi(4, o.children !== null ? o.children : [], o.key, l), l.lanes = v, l.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, l;
    }
    function ay(o, l, v, S, C) {
      this.tag = l, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = _t, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = md(0), this.expirationTimes = md(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = md(0), this.identifierPrefix = S, this.onRecoverableError = C, we && (this.mutableSourceEagerHydrationData = null);
    }
    function cm(o, l, v, S, C, D, Z, ue, Le) {
      return o = new ay(o, l, v, ue, Le), l === 1 ? (l = 1, D === !0 && (l |= 8)) : l = 0, D = Hi(3, null, null, l), o.current = D, D.stateNode = o, D.memoizedState = { element: S, isDehydrated: v, cache: null, transitions: null }, wd(D), o;
    }
    function Wr(o) {
      if (!o)
        return xr;
      o = o._reactInternals;
      e: {
        if (k(o) !== o || o.tag !== 1)
          throw Error(c(170));
        var l = o;
        do {
          switch (l.tag) {
            case 3:
              l = l.stateNode.context;
              break e;
            case 1:
              if (nr(l.type)) {
                l = l.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          l = l.return;
        } while (l !== null);
        throw Error(c(171));
      }
      if (o.tag === 1) {
        var v = o.type;
        if (nr(v))
          return Ip(o, v, l);
      }
      return l;
    }
    function Mu(o) {
      var l = o._reactInternals;
      if (l === void 0)
        throw typeof o.render == "function" ? Error(c(188)) : (o = Object.keys(o).join(","), Error(c(268, o)));
      return o = oe(l), o === null ? null : o.stateNode;
    }
    function fl(o, l) {
      if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
        var v = o.retryLane;
        o.retryLane = v !== 0 && v < l ? v : l;
      }
    }
    function dl(o, l) {
      fl(o, l), (o = o.alternate) && fl(o, l);
    }
    function hl(o) {
      return o = oe(o), o === null ? null : o.stateNode;
    }
    function rh() {
      return null;
    }
    return t.attemptContinuousHydration = function(o) {
      if (o.tag === 13) {
        var l = Bi();
        kr(o, 134217728, l), dl(o, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(o) {
      if (o.tag === 13) {
        var l = Bi(), v = Es(o);
        kr(o, v, l), dl(o, v);
      }
    }, t.attemptSynchronousHydration = function(o) {
      switch (o.tag) {
        case 3:
          var l = o.stateNode;
          if (l.current.memoizedState.isDehydrated) {
            var v = ms(l.pendingLanes);
            v !== 0 && (vd(l, v | 1), sr(l, Gn()), !(Xt & 6) && (ol(), xa()));
          }
          break;
        case 13:
          var S = Bi();
          th(function() {
            return kr(o, 1, S);
          }), dl(o, 1);
      }
    }, t.batchedUpdates = function(o, l) {
      var v = Xt;
      Xt |= 1;
      try {
        return o(l);
      } finally {
        Xt = v, Xt === 0 && (ol(), xc && xa());
      }
    }, t.createComponentSelector = function(o) {
      return { $$typeof: $c, value: o };
    }, t.createContainer = function(o, l, v, S, C, D, Z) {
      return cm(o, l, !1, null, v, S, C, D, Z);
    }, t.createHasPseudoClassSelector = function(o) {
      return { $$typeof: Yn, value: o };
    }, t.createHydrationContainer = function(o, l, v, S, C, D, Z, ue, Le) {
      return o = cm(v, S, !0, o, C, D, Z, ue, Le), o.context = Wr(null), v = o.current, S = Bi(), C = Es(v), D = Ya(S, C), D.callback = l ?? null, gs(v, D), o.current.lanes = C, Xl(o, C, S), sr(o, S), o;
    }, t.createPortal = function(o, l, v) {
      var S = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: m, key: S == null ? null : "" + S, children: o, containerInfo: l, implementation: v };
    }, t.createRoleSelector = function(o) {
      return { $$typeof: ro, value: o };
    }, t.createTestNameSelector = function(o) {
      return { $$typeof: du, value: o };
    }, t.createTextSelector = function(o) {
      return { $$typeof: $a, value: o };
    }, t.deferredUpdates = function(o) {
      var l = dn, v = Xn.transition;
      try {
        return Xn.transition = null, dn = 16, o();
      } finally {
        dn = l, Xn.transition = v;
      }
    }, t.discreteUpdates = function(o, l, v, S, C) {
      var D = dn, Z = Xn.transition;
      try {
        return Xn.transition = null, dn = 1, o(l, v, S, C);
      } finally {
        dn = D, Xn.transition = Z, Xt === 0 && ol();
      }
    }, t.findAllNodes = ut, t.findBoundingRects = function(o, l) {
      if (!kt)
        throw Error(c(363));
      l = ut(o, l), o = [];
      for (var v = 0; v < l.length; v++)
        o.push(X(l[v]));
      for (l = o.length - 1; 0 < l; l--) {
        v = o[l];
        for (var S = v.x, C = S + v.width, D = v.y, Z = D + v.height, ue = l - 1; 0 <= ue; ue--)
          if (l !== ue) {
            var Le = o[ue], Ze = Le.x, it = Ze + Le.width, It = Le.y, Nt = It + Le.height;
            if (S >= Ze && D >= It && C <= it && Z <= Nt) {
              o.splice(l, 1);
              break;
            } else if (S !== Ze || v.width !== Le.width || Nt < D || It > Z) {
              if (!(D !== It || v.height !== Le.height || it < S || Ze > C)) {
                Ze > S && (Le.width += Ze - S, Le.x = S), it < C && (Le.width = C - Ze), o.splice(l, 1);
                break;
              }
            } else {
              It > D && (Le.height += It - D, Le.y = D), Nt < Z && (Le.height = Z - It), o.splice(l, 1);
              break;
            }
          }
      }
      return o;
    }, t.findHostInstance = Mu, t.findHostInstanceWithNoPortals = function(o) {
      return o = $(o), o = o !== null ? ee(o) : null, o === null ? null : o.stateNode;
    }, t.findHostInstanceWithWarning = function(o) {
      return Mu(o);
    }, t.flushControlled = function(o) {
      var l = Xt;
      Xt |= 1;
      var v = Xn.transition, S = dn;
      try {
        Xn.transition = null, dn = 1, o();
      } finally {
        dn = S, Xn.transition = v, Xt = l, Xt === 0 && (ol(), xa());
      }
    }, t.flushPassiveEffects = so, t.flushSync = th, t.focusWithin = function(o, l) {
      if (!kt)
        throw Error(c(363));
      for (o = Yd(o), l = Ti(o, l), l = Array.from(l), o = 0; o < l.length; ) {
        var v = l[o++];
        if (!be(v)) {
          if (v.tag === 5 && Ye(v.stateNode))
            return !0;
          for (v = v.child; v !== null; )
            l.push(v), v = v.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return dn;
    }, t.getFindAllNodesFailureDescription = function(o, l) {
      if (!kt)
        throw Error(c(363));
      var v = 0, S = [];
      o = [Yd(o), 0];
      for (var C = 0; C < o.length; ) {
        var D = o[C++], Z = o[C++], ue = l[Z];
        if ((D.tag !== 5 || !be(D)) && (Xd(D, ue) && (S.push(Ms(ue)), Z++, Z > v && (v = Z)), Z < l.length))
          for (D = D.child; D !== null; )
            o.push(D, Z), D = D.sibling;
      }
      if (v < l.length) {
        for (o = []; v < l.length; v++)
          o.push(Ms(l[v]));
        return `findAllNodes was able to match part of the selector:
  ` + (S.join(" > ") + `

No matching component was found for:
  `) + o.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(o) {
      if (o = o.current, !o.child)
        return null;
      switch (o.child.tag) {
        case 5:
          return Me(o.child.stateNode);
        default:
          return o.child.stateNode;
      }
    }, t.injectIntoDevTools = function(o) {
      if (o = { bundleType: o.bundleType, version: o.version, rendererPackageName: o.rendererPackageName, rendererConfig: o.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: f.ReactCurrentDispatcher, findHostInstanceByFiber: hl, findFiberByHostInstance: o.findFiberByHostInstance || rh, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        o = !1;
      else {
        var l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (l.isDisabled || !l.supportsFiber)
          o = !0;
        else {
          try {
            _c = l.inject(o), ya = l;
          } catch {
          }
          o = !!l.checkDCE;
        }
      }
      return o;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(o, l, v, S) {
      if (!kt)
        throw Error(c(363));
      o = ut(o, l);
      var C = Ke(o, v, S).disconnect;
      return { disconnect: function() {
        C();
      } };
    }, t.registerMutableSourceForHydration = function(o, l) {
      var v = l._getVersion;
      v = v(l._source), o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [l, v] : o.mutableSourceEagerHydrationData.push(l, v);
    }, t.runWithPriority = function(o, l) {
      var v = dn;
      try {
        return dn = o, l();
      } finally {
        dn = v;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(o, l, v, S) {
      var C = l.current, D = Bi(), Z = Es(C);
      return v = Wr(v), l.context === null ? l.context = v : l.pendingContext = v, l = Ya(D, Z), l.payload = { element: o }, S = S === void 0 ? null : S, S !== null && (l.callback = S), gs(C, l), o = kr(C, Z, D), o !== null && wc(o, C, Z), Z;
    }, t;
  }), V_;
}
var G_ = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kw;
function UU() {
  return Kw || (Kw = 1, process.env.NODE_ENV !== "production" && (G_.exports = function(e) {
    var t = {}, n = Cg, r = SC(), s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, c = !1;
    function f(i) {
      c = i;
    }
    function h(i) {
      if (!c) {
        for (var a = arguments.length, d = new Array(a > 1 ? a - 1 : 0), p = 1; p < a; p++)
          d[p - 1] = arguments[p];
        g("warn", i, d);
      }
    }
    function m(i) {
      if (!c) {
        for (var a = arguments.length, d = new Array(a > 1 ? a - 1 : 0), p = 1; p < a; p++)
          d[p - 1] = arguments[p];
        g("error", i, d);
      }
    }
    function g(i, a, d) {
      {
        var p = s.ReactDebugCurrentFrame, y = p.getStackAddendum();
        y !== "" && (a += "%s", d = d.concat([y]));
        var T = d.map(function(L) {
          return String(L);
        });
        T.unshift("Warning: " + a), Function.prototype.apply.call(console[i], console, T);
      }
    }
    var _ = Object.assign;
    function x(i) {
      return i._reactInternals;
    }
    function M(i, a) {
      i._reactInternals = a;
    }
    var b = !1, E = !1, w = !1, R = !1, A = !1, P = !1, N = !0, I = !0, B = !0, W = 0, z = 1, k = 2, G = 3, $ = 4, oe = 5, ne = 6, ee = 7, ye = 8, Me = 9, De = 10, V = 11, J = 12, Y = 13, de = 14, le = 15, Pe = 16, We = 17, $e = 18, ve = 19, gt = 21, ot = 22, _t = 23, Qe = 24, At = 25, Ne = Symbol.for("react.element"), we = Symbol.for("react.portal"), ke = Symbol.for("react.fragment"), rt = Symbol.for("react.strict_mode"), Xe = Symbol.for("react.profiler"), wt = Symbol.for("react.provider"), St = Symbol.for("react.context"), pt = Symbol.for("react.forward_ref"), kt = Symbol.for("react.suspense"), Gt = Symbol.for("react.suspense_list"), X = Symbol.for("react.memo"), H = Symbol.for("react.lazy"), be = Symbol.for("react.scope"), qe = Symbol.for("react.debug_trace_mode"), Ye = Symbol.for("react.offscreen"), Ke = Symbol.for("react.legacy_hidden"), Et = Symbol.for("react.cache"), te = Symbol.for("react.tracing_marker"), he = Symbol.iterator, ae = "@@iterator";
    function pe(i) {
      if (i === null || typeof i != "object")
        return null;
      var a = he && i[he] || i[ae];
      return typeof a == "function" ? a : null;
    }
    function Ee(i, a, d) {
      var p = i.displayName;
      if (p)
        return p;
      var y = a.displayName || a.name || "";
      return y !== "" ? d + "(" + y + ")" : d;
    }
    function He(i) {
      return i.displayName || "Context";
    }
    function Fe(i) {
      if (i == null)
        return null;
      if (typeof i.tag == "number" && m("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof i == "function")
        return i.displayName || i.name || null;
      if (typeof i == "string")
        return i;
      switch (i) {
        case ke:
          return "Fragment";
        case we:
          return "Portal";
        case Xe:
          return "Profiler";
        case rt:
          return "StrictMode";
        case kt:
          return "Suspense";
        case Gt:
          return "SuspenseList";
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case St:
            var a = i;
            return He(a) + ".Consumer";
          case wt:
            var d = i;
            return He(d._context) + ".Provider";
          case pt:
            return Ee(i, i.render, "ForwardRef");
          case X:
            var p = i.displayName || null;
            return p !== null ? p : Fe(i.type) || "Memo";
          case H: {
            var y = i, T = y._payload, L = y._init;
            try {
              return Fe(L(T));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Tt(i, a, d) {
      var p = a.displayName || a.name || "";
      return i.displayName || (p !== "" ? d + "(" + p + ")" : d);
    }
    function ie(i) {
      return i.displayName || "Context";
    }
    function Re(i) {
      var a = i.tag, d = i.type;
      switch (a) {
        case Qe:
          return "Cache";
        case Me:
          var p = d;
          return ie(p) + ".Consumer";
        case De:
          var y = d;
          return ie(y._context) + ".Provider";
        case $e:
          return "DehydratedFragment";
        case V:
          return Tt(d, d.render, "ForwardRef");
        case ee:
          return "Fragment";
        case oe:
          return d;
        case $:
          return "Portal";
        case G:
          return "Root";
        case ne:
          return "Text";
        case Pe:
          return Fe(d);
        case ye:
          return d === rt ? "StrictMode" : "Mode";
        case ot:
          return "Offscreen";
        case J:
          return "Profiler";
        case gt:
          return "Scope";
        case Y:
          return "Suspense";
        case ve:
          return "SuspenseList";
        case At:
          return "TracingMarker";
        case z:
        case W:
        case We:
        case k:
        case de:
        case le:
          if (typeof d == "function")
            return d.displayName || d.name || null;
          if (typeof d == "string")
            return d;
          break;
      }
      return null;
    }
    var fe = (
      /*                      */
      0
    ), Ae = (
      /*                */
      1
    ), Be = (
      /*                    */
      2
    ), tt = (
      /*                       */
      4
    ), hn = (
      /*           */
      Be | tt
    ), an = (
      /*                */
      16
    ), bi = (
      /*                 */
      32
    ), Sn = (
      /*                     */
      64
    ), Bt = (
      /*                   */
      128
    ), Ln = (
      /*            */
      256
    ), vr = (
      /*                          */
      512
    ), $i = (
      /*                     */
      1024
    ), Ii = (
      /*                      */
      2048
    ), wi = (
      /*                    */
      4096
    ), Do = (
      /*           */
      wi | tt
    ), Pr = (
      /*                   */
      8192
    ), j = (
      /*             */
      16384
    ), ge = Ii | tt | Sn | vr | $i | j, U = (
      /*               */
      32767
    ), Q = (
      /*                   */
      32768
    ), se = (
      /*                */
      65536
    ), Ve = (
      /* */
      131072
    ), at = (
      /*                       */
      1048576
    ), mt = (
      /*                    */
      2097152
    ), nt = (
      /*                 */
      4194304
    ), ht = (
      /*                */
      8388608
    ), Ct = (
      /*               */
      16777216
    ), Mt = (
      /*              */
      33554432
    ), Ut = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      tt | $i | 0
    ), Dn = Be | tt | an | bi | vr | wi | Pr, oi = tt | Sn | vr | Pr, Ui = Ii | an, fn = nt | ht | mt, tn = s.ReactCurrentOwner;
    function gr(i) {
      var a = i, d = i;
      if (i.alternate)
        for (; a.return; )
          a = a.return;
      else {
        var p = a;
        do
          a = p, (a.flags & (Be | wi)) !== fe && (d = a.return), p = a.return;
        while (p);
      }
      return a.tag === G ? d : null;
    }
    function Bn(i) {
      return gr(i) === i;
    }
    function er(i) {
      {
        var a = tn.current;
        if (a !== null && a.tag === z) {
          var d = a, p = d.stateNode;
          p._warnedAboutRefsInRender || m("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Re(d) || "A component"), p._warnedAboutRefsInRender = !0;
        }
      }
      var y = x(i);
      return y ? gr(y) === y : !1;
    }
    function yr(i) {
      if (gr(i) !== i)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function _r(i) {
      var a = i.alternate;
      if (!a) {
        var d = gr(i);
        if (d === null)
          throw new Error("Unable to find node on an unmounted component.");
        return d !== i ? null : i;
      }
      for (var p = i, y = a; ; ) {
        var T = p.return;
        if (T === null)
          break;
        var L = T.alternate;
        if (L === null) {
          var O = T.return;
          if (O !== null) {
            p = y = O;
            continue;
          }
          break;
        }
        if (T.child === L.child) {
          for (var F = T.child; F; ) {
            if (F === p)
              return yr(T), i;
            if (F === y)
              return yr(T), a;
            F = F.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (p.return !== y.return)
          p = T, y = L;
        else {
          for (var K = !1, re = T.child; re; ) {
            if (re === p) {
              K = !0, p = T, y = L;
              break;
            }
            if (re === y) {
              K = !0, y = T, p = L;
              break;
            }
            re = re.sibling;
          }
          if (!K) {
            for (re = L.child; re; ) {
              if (re === p) {
                K = !0, p = L, y = T;
                break;
              }
              if (re === y) {
                K = !0, y = L, p = T;
                break;
              }
              re = re.sibling;
            }
            if (!K)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (p.alternate !== y)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (p.tag !== G)
        throw new Error("Unable to find node on an unmounted component.");
      return p.stateNode.current === p ? i : a;
    }
    function tr(i) {
      var a = _r(i);
      return a !== null ? Vt(a) : null;
    }
    function Vt(i) {
      if (i.tag === oe || i.tag === ne)
        return i;
      for (var a = i.child; a !== null; ) {
        var d = Vt(a);
        if (d !== null)
          return d;
        a = a.sibling;
      }
      return null;
    }
    function sn(i) {
      var a = _r(i);
      return a !== null ? xr(a) : null;
    }
    function xr(i) {
      if (i.tag === oe || i.tag === ne)
        return i;
      for (var a = i.child; a !== null; ) {
        if (a.tag !== $) {
          var d = xr(a);
          if (d !== null)
            return d;
        }
        a = a.sibling;
      }
      return null;
    }
    var gn = Array.isArray;
    function yn(i) {
      return gn(i);
    }
    var Jr = e.getPublicInstance, qa = e.getRootHostContext, nr = e.getChildHostContext, vc = e.prepareForCommit, Op = e.resetAfterCommit, Ip = e.createInstance, Po = e.appendInitialChild, hd = e.finalizeInitialChildren, Nr = e.prepareUpdate, pd = e.shouldSetTextContent, Up = e.createTextInstance, Fp = e.scheduleTimeout, gc = e.cancelTimeout, No = e.noTimeout;
    e.now;
    var ms = e.isPrimaryRenderer, yc = e.warnsIfNotActing, Qr = e.supportsMutation, Yl = e.supportsPersistence, Gi = e.supportsHydration, md = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var Xl = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var Wg = e.getCurrentEventPriority, vd = e.detachDeletedInstance, dn = e.supportsMicrotasks, Bp = e.scheduleMicrotask, vs = e.supportsTestSelectors, Hp = e.findFiberRoot, qg = e.getBoundingRect, jg = e.getTextContent, Gn = e.isHiddenSubtree, gd = e.matchAccessibilityRole, Yg = e.setFocusIfFocusable, yd = e.setupIntersectionObserver, Xg = e.appendChild, _c = e.appendChildToContainer, ya = e.commitTextUpdate, Zg = e.commitMount, Jg = e.commitUpdate, _a = e.insertBefore, ja = e.insertInContainerBefore, xc = e.removeChild, _d = e.removeChildFromContainer, xd = e.resetTextContent, Qg = e.hideInstance, xa = e.hideTextInstance, Kg = e.unhideInstance, Sc = e.unhideTextInstance, $g = e.clearContainer, Kr = e.cloneInstance, Zl = e.createContainerChildSet, Jl = e.appendChildToContainerChildSet, zo = e.finalizeContainerChildren, Mc = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var Sd = e.getOffscreenContainerProps, Md = e.cloneHiddenInstance, bc = e.cloneHiddenTextInstance, bd = e.canHydrateInstance, Oo = e.canHydrateTextInstance, zr = e.canHydrateSuspenseInstance, $r = e.isSuspenseInstancePending, Sa = e.isSuspenseInstanceFallback, wd = e.registerSuspenseInstanceRetry, Ql = e.getNextHydratableSibling, Ya = e.getFirstHydratableChild, gs = e.getFirstHydratableChildWithinContainer, wc = e.getFirstHydratableChildWithinSuspenseInstance, kp = e.hydrateInstance, Ec = e.hydrateTextInstance, Vp = e.hydrateSuspenseInstance, Gp = e.getNextHydratableInstanceAfterSuspenseInstance, Tc = e.commitHydratedContainer, Cc = e.commitHydratedSuspenseInstance, Wp = e.clearSuspenseBoundary, qp = e.clearSuspenseBoundaryFromContainer, jp = e.shouldDeleteUnhydratedTailInstances, Ed = e.didNotMatchHydratedContainerTextInstance, Io = e.didNotMatchHydratedTextInstance, Uo = e.didNotHydrateInstanceWithinContainer, Rc = e.didNotHydrateInstanceWithinSuspenseInstance, Ac = e.didNotHydrateInstance, Or = e.didNotFindHydratableInstanceWithinContainer, Ir = e.didNotFindHydratableTextInstanceWithinContainer, Gs = e.didNotFindHydratableSuspenseInstanceWithinContainer, Xa = e.didNotFindHydratableInstanceWithinSuspenseInstance, Za = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, Ws = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Yp = e.didNotFindHydratableInstance, Td = e.didNotFindHydratableTextInstance, Cd = e.didNotFindHydratableSuspenseInstance, Sr = e.errorHydratingContainer, Ei = 0, zn, Fo, Ur, Rd, Ad, Lc, Dc;
    function Ld() {
    }
    Ld.__reactDisabledLog = !0;
    function Kl() {
      {
        if (Ei === 0) {
          zn = console.log, Fo = console.info, Ur = console.warn, Rd = console.error, Ad = console.group, Lc = console.groupCollapsed, Dc = console.groupEnd;
          var i = {
            configurable: !0,
            enumerable: !0,
            value: Ld,
            writable: !0
          };
          Object.defineProperties(console, {
            info: i,
            log: i,
            warn: i,
            error: i,
            group: i,
            groupCollapsed: i,
            groupEnd: i
          });
        }
        Ei++;
      }
    }
    function Bo() {
      {
        if (Ei--, Ei === 0) {
          var i = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: _({}, i, {
              value: zn
            }),
            info: _({}, i, {
              value: Fo
            }),
            warn: _({}, i, {
              value: Ur
            }),
            error: _({}, i, {
              value: Rd
            }),
            group: _({}, i, {
              value: Ad
            }),
            groupCollapsed: _({}, i, {
              value: Lc
            }),
            groupEnd: _({}, i, {
              value: Dc
            })
          });
        }
        Ei < 0 && m("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var $l = s.ReactCurrentDispatcher, qs;
    function ea(i, a, d) {
      {
        if (qs === void 0)
          try {
            throw Error();
          } catch (y) {
            var p = y.stack.trim().match(/\n( *(at )?)/);
            qs = p && p[1] || "";
          }
        return `
` + qs + i;
      }
    }
    var Pc = !1, eu;
    {
      var Ho = typeof WeakMap == "function" ? WeakMap : Map;
      eu = new Ho();
    }
    function Nc(i, a) {
      if (!i || Pc)
        return "";
      {
        var d = eu.get(i);
        if (d !== void 0)
          return d;
      }
      var p;
      Pc = !0;
      var y = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var T;
      T = $l.current, $l.current = null, Kl();
      try {
        if (a) {
          var L = function() {
            throw Error();
          };
          if (Object.defineProperty(L.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(L, []);
            } catch (je) {
              p = je;
            }
            Reflect.construct(i, [], L);
          } else {
            try {
              L.call();
            } catch (je) {
              p = je;
            }
            i.call(L.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            p = je;
          }
          i();
        }
      } catch (je) {
        if (je && p && typeof je.stack == "string") {
          for (var O = je.stack.split(`
`), F = p.stack.split(`
`), K = O.length - 1, re = F.length - 1; K >= 1 && re >= 0 && O[K] !== F[re]; )
            re--;
          for (; K >= 1 && re >= 0; K--, re--)
            if (O[K] !== F[re]) {
              if (K !== 1 || re !== 1)
                do
                  if (K--, re--, re < 0 || O[K] !== F[re]) {
                    var me = `
` + O[K].replace(" at new ", " at ");
                    return i.displayName && me.includes("<anonymous>") && (me = me.replace("<anonymous>", i.displayName)), typeof i == "function" && eu.set(i, me), me;
                  }
                while (K >= 1 && re >= 0);
              break;
            }
        }
      } finally {
        Pc = !1, $l.current = T, Bo(), Error.prepareStackTrace = y;
      }
      var Ce = i ? i.displayName || i.name : "", ze = Ce ? ea(Ce) : "";
      return typeof i == "function" && eu.set(i, ze), ze;
    }
    function tu(i, a, d) {
      return Nc(i, !0);
    }
    function ir(i, a, d) {
      return Nc(i, !1);
    }
    function nu(i) {
      var a = i.prototype;
      return !!(a && a.isReactComponent);
    }
    function ys(i, a, d) {
      if (i == null)
        return "";
      if (typeof i == "function")
        return Nc(i, nu(i));
      if (typeof i == "string")
        return ea(i);
      switch (i) {
        case kt:
          return ea("Suspense");
        case Gt:
          return ea("SuspenseList");
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case pt:
            return ir(i.render);
          case X:
            return ys(i.type, a, d);
          case H: {
            var p = i, y = p._payload, T = p._init;
            try {
              return ys(T(y), a, d);
            } catch {
            }
          }
        }
      return "";
    }
    var ta = Object.prototype.hasOwnProperty, zc = {}, js = s.ReactDebugCurrentFrame;
    function iu(i) {
      if (i) {
        var a = i._owner, d = ys(i.type, i._source, a ? a.type : null);
        js.setExtraStackFrame(d);
      } else
        js.setExtraStackFrame(null);
    }
    function Mr(i, a, d, p, y) {
      {
        var T = Function.call.bind(ta);
        for (var L in i)
          if (T(i, L)) {
            var O = void 0;
            try {
              if (typeof i[L] != "function") {
                var F = Error((p || "React class") + ": " + d + " type `" + L + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[L] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw F.name = "Invariant Violation", F;
              }
              O = i[L](a, L, p, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (K) {
              O = K;
            }
            O && !(O instanceof Error) && (iu(y), m("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", p || "React class", d, L, typeof O), iu(null)), O instanceof Error && !(O.message in zc) && (zc[O.message] = !0, iu(y), m("Failed %s type: %s", d, O.message), iu(null));
          }
      }
    }
    var On = [], Ys;
    Ys = [];
    var na = -1;
    function Ma(i) {
      return {
        current: i
      };
    }
    function li(i, a) {
      if (na < 0) {
        m("Unexpected pop.");
        return;
      }
      a !== Ys[na] && m("Unexpected Fiber popped."), i.current = On[na], On[na] = null, Ys[na] = null, na--;
    }
    function En(i, a, d) {
      na++, On[na] = i.current, Ys[na] = d, i.current = a;
    }
    var _s;
    _s = {};
    var on = {};
    Object.freeze(on);
    var Hn = Ma(on), Cn = Ma(!1), ko = on;
    function ba(i, a, d) {
      return d && Fr(a) ? ko : Hn.current;
    }
    function Vo(i, a, d) {
      {
        var p = i.stateNode;
        p.__reactInternalMemoizedUnmaskedChildContext = a, p.__reactInternalMemoizedMaskedChildContext = d;
      }
    }
    function Go(i, a) {
      {
        var d = i.type, p = d.contextTypes;
        if (!p)
          return on;
        var y = i.stateNode;
        if (y && y.__reactInternalMemoizedUnmaskedChildContext === a)
          return y.__reactInternalMemoizedMaskedChildContext;
        var T = {};
        for (var L in p)
          T[L] = a[L];
        {
          var O = Re(i) || "Unknown";
          Mr(p, T, "context", O);
        }
        return y && Vo(i, a, T), T;
      }
    }
    function ui() {
      return Cn.current;
    }
    function Fr(i) {
      {
        var a = i.childContextTypes;
        return a != null;
      }
    }
    function Wo(i) {
      li(Cn, i), li(Hn, i);
    }
    function ru(i) {
      li(Cn, i), li(Hn, i);
    }
    function wa(i, a, d) {
      {
        if (Hn.current !== on)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        En(Hn, a, i), En(Cn, d, i);
      }
    }
    function ia(i, a, d) {
      {
        var p = i.stateNode, y = a.childContextTypes;
        if (typeof p.getChildContext != "function") {
          {
            var T = Re(i) || "Unknown";
            _s[T] || (_s[T] = !0, m("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", T, T));
          }
          return d;
        }
        var L = p.getChildContext();
        for (var O in L)
          if (!(O in y))
            throw new Error((Re(i) || "Unknown") + '.getChildContext(): key "' + O + '" is not defined in childContextTypes.');
        {
          var F = Re(i) || "Unknown";
          Mr(y, L, "child context", F);
        }
        return _({}, d, L);
      }
    }
    function Ea(i) {
      {
        var a = i.stateNode, d = a && a.__reactInternalMemoizedMergedChildContext || on;
        return ko = Hn.current, En(Hn, d, i), En(Cn, Cn.current, i), !0;
      }
    }
    function au(i, a, d) {
      {
        var p = i.stateNode;
        if (!p)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (d) {
          var y = ia(i, a, ko);
          p.__reactInternalMemoizedMergedChildContext = y, li(Cn, i), li(Hn, i), En(Hn, y, i), En(Cn, d, i);
        } else
          li(Cn, i), En(Cn, d, i);
      }
    }
    function Oc(i) {
      {
        if (!Bn(i) || i.tag !== z)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var a = i;
        do {
          switch (a.tag) {
            case G:
              return a.stateNode.context;
            case z: {
              var d = a.type;
              if (Fr(d))
                return a.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          a = a.return;
        } while (a !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Xs = 0, Dd = 1, Ft = (
      /*                         */
      0
    ), Mn = (
      /*                 */
      1
    ), cn = (
      /*                    */
      2
    ), qn = (
      /*               */
      8
    ), Br = (
      /*              */
      16
    ), qo = Math.clz32 ? Math.clz32 : Uc, Xp = Math.log, Ic = Math.LN2;
    function Uc(i) {
      var a = i >>> 0;
      return a === 0 ? 32 : 31 - (Xp(a) / Ic | 0) | 0;
    }
    var su = 31, Ge = (
      /*                        */
      0
    ), ci = (
      /*                          */
      0
    ), $t = (
      /*                        */
      1
    ), Zs = (
      /*    */
      2
    ), Ja = (
      /*            */
      4
    ), Qa = (
      /*            */
      8
    ), Ta = (
      /*                    */
      16
    ), jo = (
      /*                */
      32
    ), Yo = (
      /*                       */
      4194240
    ), Xo = (
      /*                        */
      64
    ), Pd = (
      /*                        */
      128
    ), Nd = (
      /*                        */
      256
    ), Fc = (
      /*                        */
      512
    ), Bc = (
      /*                        */
      1024
    ), Hc = (
      /*                        */
      2048
    ), kc = (
      /*                        */
      4096
    ), Zo = (
      /*                        */
      8192
    ), zd = (
      /*                        */
      16384
    ), Od = (
      /*                       */
      32768
    ), Id = (
      /*                       */
      65536
    ), ou = (
      /*                       */
      131072
    ), lu = (
      /*                       */
      262144
    ), Ud = (
      /*                       */
      524288
    ), Vc = (
      /*                       */
      1048576
    ), Gc = (
      /*                       */
      2097152
    ), uu = (
      /*                            */
      130023424
    ), Js = (
      /*                             */
      4194304
    ), Wc = (
      /*                             */
      8388608
    ), Hr = (
      /*                             */
      16777216
    ), qc = (
      /*                             */
      33554432
    ), Qs = (
      /*                             */
      67108864
    ), Jo = Js, xs = (
      /*          */
      134217728
    ), cu = (
      /*                                 */
      268435455
    ), Qo = (
      /*               */
      268435456
    ), ra = (
      /*                       */
      536870912
    ), Tn = (
      /*                   */
      1073741824
    );
    function ey(i) {
      {
        if (i & $t)
          return "Sync";
        if (i & Zs)
          return "InputContinuousHydration";
        if (i & Ja)
          return "InputContinuous";
        if (i & Qa)
          return "DefaultHydration";
        if (i & Ta)
          return "Default";
        if (i & jo)
          return "TransitionHydration";
        if (i & Yo)
          return "Transition";
        if (i & uu)
          return "Retry";
        if (i & xs)
          return "SelectiveHydration";
        if (i & Qo)
          return "IdleHydration";
        if (i & ra)
          return "Idle";
        if (i & Tn)
          return "Offscreen";
      }
    }
    var Pn = -1, Fi = Xo, yi = Js;
    function Ko(i) {
      switch (Ca(i)) {
        case $t:
          return $t;
        case Zs:
          return Zs;
        case Ja:
          return Ja;
        case Qa:
          return Qa;
        case Ta:
          return Ta;
        case jo:
          return jo;
        case Xo:
        case Pd:
        case Nd:
        case Fc:
        case Bc:
        case Hc:
        case kc:
        case Zo:
        case zd:
        case Od:
        case Id:
        case ou:
        case lu:
        case Ud:
        case Vc:
        case Gc:
          return i & Yo;
        case Js:
        case Wc:
        case Hr:
        case qc:
        case Qs:
          return i & uu;
        case xs:
          return xs;
        case Qo:
          return Qo;
        case ra:
          return ra;
        case Tn:
          return Tn;
        default:
          return m("Should have found matching lanes. This is a bug in React."), i;
      }
    }
    function fu(i, a) {
      var d = i.pendingLanes;
      if (d === Ge)
        return Ge;
      var p = Ge, y = i.suspendedLanes, T = i.pingedLanes, L = d & cu;
      if (L !== Ge) {
        var O = L & ~y;
        if (O !== Ge)
          p = Ko(O);
        else {
          var F = L & T;
          F !== Ge && (p = Ko(F));
        }
      } else {
        var K = d & ~y;
        K !== Ge ? p = Ko(K) : T !== Ge && (p = Ko(T));
      }
      if (p === Ge)
        return Ge;
      if (a !== Ge && a !== p && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (a & y) === Ge) {
        var re = Ca(p), me = Ca(a);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          re >= me || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          re === Ta && (me & Yo) !== Ge
        )
          return a;
      }
      (p & Ja) !== Ge && (p |= d & Ta);
      var Ce = i.entangledLanes;
      if (Ce !== Ge)
        for (var ze = i.entanglements, je = p & Ce; je > 0; ) {
          var Je = Ka(je), Pt = 1 << Je;
          p |= ze[Je], je &= ~Pt;
        }
      return p;
    }
    function Zp(i, a) {
      for (var d = i.eventTimes, p = Pn; a > 0; ) {
        var y = Ka(a), T = 1 << y, L = d[y];
        L > p && (p = L), a &= ~T;
      }
      return p;
    }
    function Jp(i, a) {
      switch (i) {
        case $t:
        case Zs:
        case Ja:
          return a + 250;
        case Qa:
        case Ta:
        case jo:
        case Xo:
        case Pd:
        case Nd:
        case Fc:
        case Bc:
        case Hc:
        case kc:
        case Zo:
        case zd:
        case Od:
        case Id:
        case ou:
        case lu:
        case Ud:
        case Vc:
        case Gc:
          return a + 5e3;
        case Js:
        case Wc:
        case Hr:
        case qc:
        case Qs:
          return Pn;
        case xs:
        case Qo:
        case ra:
        case Tn:
          return Pn;
        default:
          return m("Should have found matching lanes. This is a bug in React."), Pn;
      }
    }
    function Qp(i, a) {
      for (var d = i.pendingLanes, p = i.suspendedLanes, y = i.pingedLanes, T = i.expirationTimes, L = d; L > 0; ) {
        var O = Ka(L), F = 1 << O, K = T[O];
        K === Pn ? ((F & p) === Ge || (F & y) !== Ge) && (T[O] = Jp(F, a)) : K <= a && (i.expiredLanes |= F), L &= ~F;
      }
    }
    function Fd(i) {
      return Ko(i.pendingLanes);
    }
    function jc(i) {
      var a = i.pendingLanes & ~Tn;
      return a !== Ge ? a : a & Tn ? Tn : Ge;
    }
    function Bd(i) {
      return (i & $t) !== Ge;
    }
    function Yc(i) {
      return (i & cu) !== Ge;
    }
    function Hd(i) {
      return (i & uu) === i;
    }
    function Xc(i) {
      return (i & Yo) === i;
    }
    function Ks(i, a) {
      var d = Zs | Ja | Qa | Ta;
      return (a & d) !== Ge;
    }
    function Kp(i, a) {
      return (a & i.expiredLanes) !== Ge;
    }
    function Zc(i) {
      return (i & Yo) !== 0;
    }
    function $p() {
      var i = Fi;
      return Fi <<= 1, Fi & Yo || (Fi = Xo), i;
    }
    function em() {
      var i = yi;
      return yi <<= 1, yi & uu || (yi = Js), i;
    }
    function Ca(i) {
      return i & -i;
    }
    function $o(i) {
      return Ca(i);
    }
    function Ka(i) {
      return 31 - qo(i);
    }
    function Jc(i) {
      return Ka(i);
    }
    function jn(i, a) {
      return (i & a) !== Ge;
    }
    function el(i, a) {
      return (i & a) === a;
    }
    function Wt(i, a) {
      return i | a;
    }
    function $s(i, a) {
      return i & ~a;
    }
    function Ss(i, a) {
      return i & a;
    }
    function AS(i) {
      return i;
    }
    function ft(i, a) {
      return i !== ci && i < a ? i : a;
    }
    function tl(i) {
      for (var a = [], d = 0; d < su; d++)
        a.push(i);
      return a;
    }
    function eo(i, a, d) {
      i.pendingLanes |= a, a !== ra && (i.suspendedLanes = Ge, i.pingedLanes = Ge);
      var p = i.eventTimes, y = Jc(a);
      p[y] = d;
    }
    function tm(i, a) {
      i.suspendedLanes |= a, i.pingedLanes &= ~a;
      for (var d = i.expirationTimes, p = a; p > 0; ) {
        var y = Ka(p), T = 1 << y;
        d[y] = Pn, p &= ~T;
      }
    }
    function nm(i, a, d) {
      i.pingedLanes |= i.suspendedLanes & a;
    }
    function to(i, a) {
      var d = i.pendingLanes & ~a;
      i.pendingLanes = a, i.suspendedLanes = 0, i.pingedLanes = 0, i.expiredLanes &= a, i.mutableReadLanes &= a, i.entangledLanes &= a;
      for (var p = i.entanglements, y = i.eventTimes, T = i.expirationTimes, L = d; L > 0; ) {
        var O = Ka(L), F = 1 << O;
        p[O] = Ge, y[O] = Pn, T[O] = Pn, L &= ~F;
      }
    }
    function no(i, a) {
      for (var d = i.entangledLanes |= a, p = i.entanglements, y = d; y; ) {
        var T = Ka(y), L = 1 << T;
        // Is this one of the newly entangled lanes?
        L & a | // Is this lane transitively entangled with the newly entangled lanes?
        p[T] & a && (p[T] |= a), y &= ~L;
      }
    }
    function kd(i, a) {
      var d = Ca(a), p;
      switch (d) {
        case Ja:
          p = Zs;
          break;
        case Ta:
          p = Qa;
          break;
        case Xo:
        case Pd:
        case Nd:
        case Fc:
        case Bc:
        case Hc:
        case kc:
        case Zo:
        case zd:
        case Od:
        case Id:
        case ou:
        case lu:
        case Ud:
        case Vc:
        case Gc:
        case Js:
        case Wc:
        case Hr:
        case qc:
        case Qs:
          p = jo;
          break;
        case ra:
          p = Qo;
          break;
        default:
          p = ci;
          break;
      }
      return (p & (i.suspendedLanes | a)) !== ci ? ci : p;
    }
    function Vd(i, a, d) {
      if (rr)
        for (var p = i.pendingUpdatersLaneMap; d > 0; ) {
          var y = Jc(d), T = 1 << y, L = p[y];
          L.add(a), d &= ~T;
        }
    }
    function Gd(i, a) {
      if (rr)
        for (var d = i.pendingUpdatersLaneMap, p = i.memoizedUpdaters; a > 0; ) {
          var y = Jc(a), T = 1 << y, L = d[y];
          L.size > 0 && (L.forEach(function(O) {
            var F = O.alternate;
            (F === null || !p.has(F)) && p.add(O);
          }), L.clear()), a &= ~T;
        }
    }
    var aa = $t, nl = Ja, il = Ta, Qc = ra, io = ci;
    function br() {
      return io;
    }
    function fi(i) {
      io = i;
    }
    function Wd(i, a) {
      var d = io;
      try {
        return io = i, a();
      } finally {
        io = d;
      }
    }
    function Kc(i, a) {
      return i !== 0 && i < a ? i : a;
    }
    function ty(i, a) {
      return i === 0 || i > a ? i : a;
    }
    function im(i, a) {
      return i !== 0 && i < a;
    }
    function qd(i) {
      var a = Ca(i);
      return im(aa, a) ? im(nl, a) ? Yc(a) ? il : Qc : nl : aa;
    }
    var jd = r.unstable_scheduleCallback, rm = r.unstable_cancelCallback, am = r.unstable_shouldYield, $c = r.unstable_requestPaint, Yn = r.unstable_now, ro = r.unstable_ImmediatePriority, du = r.unstable_UserBlockingPriority, $a = r.unstable_NormalPriority, rl = r.unstable_IdlePriority, Yd = r.unstable_yieldValue, Xd = r.unstable_setDisableYieldValue, Ms = null, Ti = null, ut = null, Ra = !1, rr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Zd(i) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (a.isDisabled)
        return !0;
      if (!a.supportsFiber)
        return m("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        N && (i = _({}, i, {
          getLaneLabelMap: al,
          injectProfilingHooks: wr
        })), Ms = a.inject(i), Ti = a;
      } catch (d) {
        m("React instrumentation encountered an error: %s.", d);
      }
      return !!a.checkDCE;
    }
    function Xn(i, a) {
      if (Ti && typeof Ti.onScheduleFiberRoot == "function")
        try {
          Ti.onScheduleFiberRoot(Ms, i, a);
        } catch (d) {
          Ra || (Ra = !0, m("React instrumentation encountered an error: %s", d));
        }
    }
    function Xt(i, a) {
      if (Ti && typeof Ti.onCommitFiberRoot == "function")
        try {
          var d = (i.current.flags & Bt) === Bt;
          if (I) {
            var p;
            switch (a) {
              case aa:
                p = ro;
                break;
              case nl:
                p = du;
                break;
              case il:
                p = $a;
                break;
              case Qc:
                p = rl;
                break;
              default:
                p = $a;
                break;
            }
            Ti.onCommitFiberRoot(Ms, i, p, d);
          }
        } catch (y) {
          Ra || (Ra = !0, m("React instrumentation encountered an error: %s", y));
        }
    }
    function ii(i) {
      if (Ti && typeof Ti.onPostCommitFiberRoot == "function")
        try {
          Ti.onPostCommitFiberRoot(Ms, i);
        } catch (a) {
          Ra || (Ra = !0, m("React instrumentation encountered an error: %s", a));
        }
    }
    function ri(i) {
      if (Ti && typeof Ti.onCommitFiberUnmount == "function")
        try {
          Ti.onCommitFiberUnmount(Ms, i);
        } catch (a) {
          Ra || (Ra = !0, m("React instrumentation encountered an error: %s", a));
        }
    }
    function ln(i) {
      if (typeof Yd == "function" && (Xd(i), f(i)), Ti && typeof Ti.setStrictMode == "function")
        try {
          Ti.setStrictMode(Ms, i);
        } catch (a) {
          Ra || (Ra = !0, m("React instrumentation encountered an error: %s", a));
        }
    }
    function wr(i) {
      ut = i;
    }
    function al() {
      {
        for (var i = /* @__PURE__ */ new Map(), a = 1, d = 0; d < su; d++) {
          var p = ey(a);
          i.set(a, p), a *= 2;
        }
        return i;
      }
    }
    function di(i) {
      ut !== null && typeof ut.markCommitStarted == "function" && ut.markCommitStarted(i);
    }
    function sl() {
      ut !== null && typeof ut.markCommitStopped == "function" && ut.markCommitStopped();
    }
    function Aa(i) {
      ut !== null && typeof ut.markComponentRenderStarted == "function" && ut.markComponentRenderStarted(i);
    }
    function es() {
      ut !== null && typeof ut.markComponentRenderStopped == "function" && ut.markComponentRenderStopped();
    }
    function Jd(i) {
      ut !== null && typeof ut.markComponentPassiveEffectMountStarted == "function" && ut.markComponentPassiveEffectMountStarted(i);
    }
    function hu() {
      ut !== null && typeof ut.markComponentPassiveEffectMountStopped == "function" && ut.markComponentPassiveEffectMountStopped();
    }
    function ar(i) {
      ut !== null && typeof ut.markComponentPassiveEffectUnmountStarted == "function" && ut.markComponentPassiveEffectUnmountStarted(i);
    }
    function Qd() {
      ut !== null && typeof ut.markComponentPassiveEffectUnmountStopped == "function" && ut.markComponentPassiveEffectUnmountStopped();
    }
    function Kd(i) {
      ut !== null && typeof ut.markComponentLayoutEffectMountStarted == "function" && ut.markComponentLayoutEffectMountStarted(i);
    }
    function ol() {
      ut !== null && typeof ut.markComponentLayoutEffectMountStopped == "function" && ut.markComponentLayoutEffectMountStopped();
    }
    function pu(i) {
      ut !== null && typeof ut.markComponentLayoutEffectUnmountStarted == "function" && ut.markComponentLayoutEffectUnmountStarted(i);
    }
    function ef() {
      ut !== null && typeof ut.markComponentLayoutEffectUnmountStopped == "function" && ut.markComponentLayoutEffectUnmountStopped();
    }
    function bs(i, a, d) {
      ut !== null && typeof ut.markComponentErrored == "function" && ut.markComponentErrored(i, a, d);
    }
    function tf(i, a, d) {
      ut !== null && typeof ut.markComponentSuspended == "function" && ut.markComponentSuspended(i, a, d);
    }
    function ws(i) {
      ut !== null && typeof ut.markLayoutEffectsStarted == "function" && ut.markLayoutEffectsStarted(i);
    }
    function nf() {
      ut !== null && typeof ut.markLayoutEffectsStopped == "function" && ut.markLayoutEffectsStopped();
    }
    function mu(i) {
      ut !== null && typeof ut.markPassiveEffectsStarted == "function" && ut.markPassiveEffectsStarted(i);
    }
    function $d() {
      ut !== null && typeof ut.markPassiveEffectsStopped == "function" && ut.markPassiveEffectsStopped();
    }
    function vu(i) {
      ut !== null && typeof ut.markRenderStarted == "function" && ut.markRenderStarted(i);
    }
    function rf() {
      ut !== null && typeof ut.markRenderYielded == "function" && ut.markRenderYielded();
    }
    function Bi() {
      ut !== null && typeof ut.markRenderStopped == "function" && ut.markRenderStopped();
    }
    function Es(i) {
      ut !== null && typeof ut.markRenderScheduled == "function" && ut.markRenderScheduled(i);
    }
    function kr(i, a) {
      ut !== null && typeof ut.markForceUpdateScheduled == "function" && ut.markForceUpdateScheduled(i, a);
    }
    function ll(i, a) {
      ut !== null && typeof ut.markStateUpdateScheduled == "function" && ut.markStateUpdateScheduled(i, a);
    }
    function sr(i, a) {
      return i === a && (i !== 0 || 1 / i === 1 / a) || i !== i && a !== a;
    }
    var Er = typeof Object.is == "function" ? Object.is : sr, sa = null, gu = !1, eh = !1;
    function ts(i) {
      sa === null ? sa = [i] : sa.push(i);
    }
    function sm(i) {
      gu = !0, ts(i);
    }
    function th() {
      gu && Vr();
    }
    function Vr() {
      if (!eh && sa !== null) {
        eh = !0;
        var i = 0, a = br();
        try {
          var d = !0, p = sa;
          for (fi(aa); i < p.length; i++) {
            var y = p[i];
            do
              y = y(d);
            while (y !== null);
          }
          sa = null, gu = !1;
        } catch (T) {
          throw sa !== null && (sa = sa.slice(i + 1)), jd(ro, Vr), T;
        } finally {
          fi(a), eh = !1;
        }
      }
      return null;
    }
    function Ts(i) {
      var a = i.current.memoizedState;
      return a.isDehydrated;
    }
    var om = s.ReactCurrentBatchConfig, lm = null;
    function nh() {
      return om.transition;
    }
    function ao(i, a) {
      if (Er(i, a))
        return !0;
      if (typeof i != "object" || i === null || typeof a != "object" || a === null)
        return !1;
      var d = Object.keys(i), p = Object.keys(a);
      if (d.length !== p.length)
        return !1;
      for (var y = 0; y < d.length; y++) {
        var T = d[y];
        if (!ta.call(a, T) || !Er(i[T], a[T]))
          return !1;
      }
      return !0;
    }
    function ny(i) {
      switch (i._debugOwner && i._debugOwner.type, i._debugSource, i.tag) {
        case oe:
          return ea(i.type);
        case Pe:
          return ea("Lazy");
        case Y:
          return ea("Suspense");
        case ve:
          return ea("SuspenseList");
        case W:
        case k:
        case le:
          return ir(i.type);
        case V:
          return ir(i.type.render);
        case z:
          return tu(i.type);
        default:
          return "";
      }
    }
    function um(i) {
      try {
        var a = "", d = i;
        do
          a += ny(d), d = d.return;
        while (d);
        return a;
      } catch (p) {
        return `
Error generating stack: ` + p.message + `
` + p.stack;
      }
    }
    var ih = s.ReactDebugCurrentFrame, Tr = null, oa = !1;
    function iy() {
      {
        if (Tr === null)
          return null;
        var i = Tr._debugOwner;
        if (i !== null && typeof i < "u")
          return Re(i);
      }
      return null;
    }
    function so() {
      return Tr === null ? "" : um(Tr);
    }
    function Ci() {
      ih.getCurrentStack = null, Tr = null, oa = !1;
    }
    function pn(i) {
      ih.getCurrentStack = so, Tr = i, oa = !1;
    }
    function La(i) {
      oa = i;
    }
    var Gr = {
      recordUnsafeLifecycleWarnings: function(i, a) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(i, a) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var ry = function(i) {
        for (var a = null, d = i; d !== null; )
          d.mode & qn && (a = d), d = d.return;
        return a;
      }, oo = function(i) {
        var a = [];
        return i.forEach(function(d) {
          a.push(d);
        }), a.sort().join(", ");
      }, ul = [], cl = [], yu = [], Hi = [], lo = [], _u = [], or = /* @__PURE__ */ new Set();
      Gr.recordUnsafeLifecycleWarnings = function(i, a) {
        or.has(i.type) || (typeof a.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        a.componentWillMount.__suppressDeprecationWarning !== !0 && ul.push(i), i.mode & qn && typeof a.UNSAFE_componentWillMount == "function" && cl.push(i), typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && yu.push(i), i.mode & qn && typeof a.UNSAFE_componentWillReceiveProps == "function" && Hi.push(i), typeof a.componentWillUpdate == "function" && a.componentWillUpdate.__suppressDeprecationWarning !== !0 && lo.push(i), i.mode & qn && typeof a.UNSAFE_componentWillUpdate == "function" && _u.push(i));
      }, Gr.flushPendingUnsafeLifecycleWarnings = function() {
        var i = /* @__PURE__ */ new Set();
        ul.length > 0 && (ul.forEach(function(Ce) {
          i.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), ul = []);
        var a = /* @__PURE__ */ new Set();
        cl.length > 0 && (cl.forEach(function(Ce) {
          a.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), cl = []);
        var d = /* @__PURE__ */ new Set();
        yu.length > 0 && (yu.forEach(function(Ce) {
          d.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), yu = []);
        var p = /* @__PURE__ */ new Set();
        Hi.length > 0 && (Hi.forEach(function(Ce) {
          p.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), Hi = []);
        var y = /* @__PURE__ */ new Set();
        lo.length > 0 && (lo.forEach(function(Ce) {
          y.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), lo = []);
        var T = /* @__PURE__ */ new Set();
        if (_u.length > 0 && (_u.forEach(function(Ce) {
          T.add(Re(Ce) || "Component"), or.add(Ce.type);
        }), _u = []), a.size > 0) {
          var L = oo(a);
          m(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, L);
        }
        if (p.size > 0) {
          var O = oo(p);
          m(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, O);
        }
        if (T.size > 0) {
          var F = oo(T);
          m(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, F);
        }
        if (i.size > 0) {
          var K = oo(i);
          h(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, K);
        }
        if (d.size > 0) {
          var re = oo(d);
          h(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, re);
        }
        if (y.size > 0) {
          var me = oo(y);
          h(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, me);
        }
      };
      var uo = /* @__PURE__ */ new Map(), Cs = /* @__PURE__ */ new Set();
      Gr.recordLegacyContextWarning = function(i, a) {
        var d = ry(i);
        if (d === null) {
          m("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Cs.has(i.type)) {
          var p = uo.get(d);
          (i.type.contextTypes != null || i.type.childContextTypes != null || a !== null && typeof a.getChildContext == "function") && (p === void 0 && (p = [], uo.set(d, p)), p.push(i));
        }
      }, Gr.flushLegacyContextWarning = function() {
        uo.forEach(function(i, a) {
          if (i.length !== 0) {
            var d = i[0], p = /* @__PURE__ */ new Set();
            i.forEach(function(T) {
              p.add(Re(T) || "Component"), Cs.add(T.type);
            });
            var y = oo(p);
            try {
              pn(d), m(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, y);
            } finally {
              Ci();
            }
          }
        });
      }, Gr.discardPendingWarnings = function() {
        ul = [], cl = [], yu = [], Hi = [], lo = [], _u = [], uo = /* @__PURE__ */ new Map();
      };
    }
    function xu(i) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, d = a && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return d;
      }
    }
    function af(i) {
      try {
        return Su(i), !1;
      } catch {
        return !0;
      }
    }
    function Su(i) {
      return "" + i;
    }
    function ay(i) {
      if (af(i))
        return m("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xu(i)), Su(i);
    }
    function cm(i, a) {
      if (af(i))
        return m("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", a, xu(i)), Su(i);
    }
    function Wr(i, a) {
      if (i && i.defaultProps) {
        var d = _({}, a), p = i.defaultProps;
        for (var y in p)
          d[y] === void 0 && (d[y] = p[y]);
        return d;
      }
      return a;
    }
    var Mu = Ma(null), fl;
    fl = {};
    var dl = null, hl = null, rh = null, o = !1;
    function l() {
      dl = null, hl = null, rh = null, o = !1;
    }
    function v() {
      o = !0;
    }
    function S() {
      o = !1;
    }
    function C(i, a, d) {
      ms ? (En(Mu, a._currentValue, i), a._currentValue = d, a._currentRenderer !== void 0 && a._currentRenderer !== null && a._currentRenderer !== fl && m("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer = fl) : (En(Mu, a._currentValue2, i), a._currentValue2 = d, a._currentRenderer2 !== void 0 && a._currentRenderer2 !== null && a._currentRenderer2 !== fl && m("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer2 = fl);
    }
    function D(i, a) {
      var d = Mu.current;
      li(Mu, a), ms ? i._currentValue = d : i._currentValue2 = d;
    }
    function Z(i, a, d) {
      for (var p = i; p !== null; ) {
        var y = p.alternate;
        if (el(p.childLanes, a) ? y !== null && !el(y.childLanes, a) && (y.childLanes = Wt(y.childLanes, a)) : (p.childLanes = Wt(p.childLanes, a), y !== null && (y.childLanes = Wt(y.childLanes, a))), p === d)
          break;
        p = p.return;
      }
      p !== d && m("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ue(i, a, d) {
      Le(i, a, d);
    }
    function Le(i, a, d) {
      var p = i.child;
      for (p !== null && (p.return = i); p !== null; ) {
        var y = void 0, T = p.dependencies;
        if (T !== null) {
          y = p.child;
          for (var L = T.firstContext; L !== null; ) {
            if (L.context === a) {
              if (p.tag === z) {
                var O = $o(d), F = zt(Pn, O);
                F.tag = Wi;
                var K = p.updateQueue;
                if (K !== null) {
                  var re = K.shared, me = re.pending;
                  me === null ? F.next = F : (F.next = me.next, me.next = F), re.pending = F;
                }
              }
              p.lanes = Wt(p.lanes, d);
              var Ce = p.alternate;
              Ce !== null && (Ce.lanes = Wt(Ce.lanes, d)), Z(p.return, d, i), T.lanes = Wt(T.lanes, d);
              break;
            }
            L = L.next;
          }
        } else if (p.tag === De)
          y = p.type === i.type ? null : p.child;
        else if (p.tag === $e) {
          var ze = p.return;
          if (ze === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          ze.lanes = Wt(ze.lanes, d);
          var je = ze.alternate;
          je !== null && (je.lanes = Wt(je.lanes, d)), Z(ze, d, i), y = p.sibling;
        } else
          y = p.child;
        if (y !== null)
          y.return = p;
        else
          for (y = p; y !== null; ) {
            if (y === i) {
              y = null;
              break;
            }
            var Je = y.sibling;
            if (Je !== null) {
              Je.return = y.return, y = Je;
              break;
            }
            y = y.return;
          }
        p = y;
      }
    }
    function Ze(i, a) {
      dl = i, hl = null, rh = null;
      var d = i.dependencies;
      if (d !== null) {
        var p = d.firstContext;
        p !== null && (jn(d.lanes, a) && Ym(), d.firstContext = null);
      }
    }
    function it(i) {
      o && m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var a = ms ? i._currentValue : i._currentValue2;
      if (rh !== i) {
        var d = {
          context: i,
          memoizedValue: a,
          next: null
        };
        if (hl === null) {
          if (dl === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          hl = d, dl.dependencies = {
            lanes: Ge,
            firstContext: d
          };
        } else
          hl = hl.next = d;
      }
      return a;
    }
    var It = null;
    function Nt(i) {
      It === null ? It = [i] : It.push(i);
    }
    function Rn() {
      if (It !== null) {
        for (var i = 0; i < It.length; i++) {
          var a = It[i], d = a.interleaved;
          if (d !== null) {
            a.interleaved = null;
            var p = d.next, y = a.pending;
            if (y !== null) {
              var T = y.next;
              y.next = p, d.next = T;
            }
            a.pending = d;
          }
        }
        It = null;
      }
    }
    var Lt = 0, Ri = 1, Wi = 2, xe = 3, ce = !1, Te, ct;
    Te = !1, ct = null;
    function bt(i) {
      var a = {
        baseState: i.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ge
        },
        effects: null
      };
      i.updateQueue = a;
    }
    function qt(i, a) {
      var d = a.updateQueue, p = i.updateQueue;
      if (d === p) {
        var y = {
          baseState: p.baseState,
          firstBaseUpdate: p.firstBaseUpdate,
          lastBaseUpdate: p.lastBaseUpdate,
          shared: p.shared,
          effects: p.effects
        };
        a.updateQueue = y;
      }
    }
    function zt(i, a) {
      var d = {
        eventTime: i,
        lane: a,
        tag: Lt,
        payload: null,
        callback: null,
        next: null
      };
      return d;
    }
    function Zt(i, a, d) {
      var p = i.updateQueue;
      if (p !== null) {
        var y = p.shared;
        if (LM(i)) {
          var T = y.interleaved;
          T === null ? (a.next = a, Nt(y)) : (a.next = T.next, T.next = a), y.interleaved = a;
        } else {
          var L = y.pending;
          L === null ? a.next = a : (a.next = L.next, L.next = a), y.pending = a;
        }
        ct === y && !Te && (m("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Te = !0);
      }
    }
    function Zn(i, a, d) {
      var p = a.updateQueue;
      if (p !== null) {
        var y = p.shared;
        if (Zc(d)) {
          var T = y.lanes;
          T = Ss(T, i.pendingLanes);
          var L = Wt(T, d);
          y.lanes = L, no(i, L);
        }
      }
    }
    function un(i, a) {
      var d = i.updateQueue, p = i.alternate;
      if (p !== null) {
        var y = p.updateQueue;
        if (d === y) {
          var T = null, L = null, O = d.firstBaseUpdate;
          if (O !== null) {
            var F = O;
            do {
              var K = {
                eventTime: F.eventTime,
                lane: F.lane,
                tag: F.tag,
                payload: F.payload,
                callback: F.callback,
                next: null
              };
              L === null ? T = L = K : (L.next = K, L = K), F = F.next;
            } while (F !== null);
            L === null ? T = L = a : (L.next = a, L = a);
          } else
            T = L = a;
          d = {
            baseState: y.baseState,
            firstBaseUpdate: T,
            lastBaseUpdate: L,
            shared: y.shared,
            effects: y.effects
          }, i.updateQueue = d;
          return;
        }
      }
      var re = d.lastBaseUpdate;
      re === null ? d.firstBaseUpdate = a : re.next = a, d.lastBaseUpdate = a;
    }
    function Rs(i, a, d, p, y, T) {
      switch (d.tag) {
        case Ri: {
          var L = d.payload;
          if (typeof L == "function") {
            v();
            var O = L.call(T, p, y);
            {
              if (i.mode & qn) {
                ln(!0);
                try {
                  L.call(T, p, y);
                } finally {
                  ln(!1);
                }
              }
              S();
            }
            return O;
          }
          return L;
        }
        case xe:
          i.flags = i.flags & ~se | Bt;
        case Lt: {
          var F = d.payload, K;
          if (typeof F == "function") {
            v(), K = F.call(T, p, y);
            {
              if (i.mode & qn) {
                ln(!0);
                try {
                  F.call(T, p, y);
                } finally {
                  ln(!1);
                }
              }
              S();
            }
          } else
            K = F;
          return K == null ? p : _({}, p, K);
        }
        case Wi:
          return ce = !0, p;
      }
      return p;
    }
    function sf(i, a, d, p) {
      var y = i.updateQueue;
      ce = !1, ct = y.shared;
      var T = y.firstBaseUpdate, L = y.lastBaseUpdate, O = y.shared.pending;
      if (O !== null) {
        y.shared.pending = null;
        var F = O, K = F.next;
        F.next = null, L === null ? T = K : L.next = K, L = F;
        var re = i.alternate;
        if (re !== null) {
          var me = re.updateQueue, Ce = me.lastBaseUpdate;
          Ce !== L && (Ce === null ? me.firstBaseUpdate = K : Ce.next = K, me.lastBaseUpdate = F);
        }
      }
      if (T !== null) {
        var ze = y.baseState, je = Ge, Je = null, Pt = null, jt = null, Ot = T;
        do {
          var kn = Ot.lane, Vn = Ot.eventTime;
          if (el(p, kn)) {
            if (jt !== null) {
              var Oe = {
                eventTime: Vn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ci,
                tag: Ot.tag,
                payload: Ot.payload,
                callback: Ot.callback,
                next: null
              };
              jt = jt.next = Oe;
            }
            ze = Rs(i, y, Ot, ze, a, d);
            var _e = Ot.callback;
            if (_e !== null && // If the update was already committed, we should not queue its
            // callback again.
            Ot.lane !== ci) {
              i.flags |= Sn;
              var et = y.effects;
              et === null ? y.effects = [Ot] : et.push(Ot);
            }
          } else {
            var Se = {
              eventTime: Vn,
              lane: kn,
              tag: Ot.tag,
              payload: Ot.payload,
              callback: Ot.callback,
              next: null
            };
            jt === null ? (Pt = jt = Se, Je = ze) : jt = jt.next = Se, je = Wt(je, kn);
          }
          if (Ot = Ot.next, Ot === null) {
            if (O = y.shared.pending, O === null)
              break;
            var Dt = O, yt = Dt.next;
            Dt.next = null, Ot = yt, y.lastBaseUpdate = Dt, y.shared.pending = null;
          }
        } while (!0);
        jt === null && (Je = ze), y.baseState = Je, y.firstBaseUpdate = Pt, y.lastBaseUpdate = jt;
        var rn = y.shared.interleaved;
        if (rn !== null) {
          var bn = rn;
          do
            je = Wt(je, bn.lane), bn = bn.next;
          while (bn !== rn);
        } else
          T === null && (y.shared.lanes = Ge);
        vv(je), i.lanes = je, i.memoizedState = ze;
      }
      ct = null;
    }
    function BC(i, a) {
      if (typeof i != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + i));
      i.call(a);
    }
    function LS() {
      ce = !1;
    }
    function fm() {
      return ce;
    }
    function DS(i, a, d) {
      var p = a.effects;
      if (a.effects = null, p !== null)
        for (var y = 0; y < p.length; y++) {
          var T = p[y], L = T.callback;
          L !== null && (T.callback = null, BC(L, d));
        }
    }
    var sy = {}, PS = new n.Component().refs, oy, ly, uy, cy, fy, NS, dm, dy, hy, py;
    {
      oy = /* @__PURE__ */ new Set(), ly = /* @__PURE__ */ new Set(), uy = /* @__PURE__ */ new Set(), cy = /* @__PURE__ */ new Set(), dy = /* @__PURE__ */ new Set(), fy = /* @__PURE__ */ new Set(), hy = /* @__PURE__ */ new Set(), py = /* @__PURE__ */ new Set();
      var zS = /* @__PURE__ */ new Set();
      dm = function(i, a) {
        if (!(i === null || typeof i == "function")) {
          var d = a + "_" + i;
          zS.has(d) || (zS.add(d), m("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, i));
        }
      }, NS = function(i, a) {
        if (a === void 0) {
          var d = Fe(i) || "Component";
          fy.has(d) || (fy.add(d), m("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      }, Object.defineProperty(sy, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(sy);
    }
    function my(i, a, d, p) {
      var y = i.memoizedState, T = d(p, y);
      {
        if (i.mode & qn) {
          ln(!0);
          try {
            T = d(p, y);
          } finally {
            ln(!1);
          }
        }
        NS(a, T);
      }
      var L = T == null ? y : _({}, y, T);
      if (i.memoizedState = L, i.lanes === Ge) {
        var O = i.updateQueue;
        O.baseState = L;
      }
    }
    var vy = {
      isMounted: er,
      enqueueSetState: function(i, a, d) {
        var p = x(i), y = Rr(), T = Sl(p), L = zt(y, T);
        L.payload = a, d != null && (dm(d, "setState"), L.callback = d), Zt(p, L);
        var O = Pi(p, T, y);
        O !== null && Zn(O, p, T), ll(p, T);
      },
      enqueueReplaceState: function(i, a, d) {
        var p = x(i), y = Rr(), T = Sl(p), L = zt(y, T);
        L.tag = Ri, L.payload = a, d != null && (dm(d, "replaceState"), L.callback = d), Zt(p, L);
        var O = Pi(p, T, y);
        O !== null && Zn(O, p, T), ll(p, T);
      },
      enqueueForceUpdate: function(i, a) {
        var d = x(i), p = Rr(), y = Sl(d), T = zt(p, y);
        T.tag = Wi, a != null && (dm(a, "forceUpdate"), T.callback = a), Zt(d, T);
        var L = Pi(d, y, p);
        L !== null && Zn(L, d, y), kr(d, y);
      }
    };
    function OS(i, a, d, p, y, T, L) {
      var O = i.stateNode;
      if (typeof O.shouldComponentUpdate == "function") {
        var F = O.shouldComponentUpdate(p, T, L);
        {
          if (i.mode & qn) {
            ln(!0);
            try {
              F = O.shouldComponentUpdate(p, T, L);
            } finally {
              ln(!1);
            }
          }
          F === void 0 && m("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Fe(a) || "Component");
        }
        return F;
      }
      return a.prototype && a.prototype.isPureReactComponent ? !ao(d, p) || !ao(y, T) : !0;
    }
    function HC(i, a, d) {
      var p = i.stateNode;
      {
        var y = Fe(a) || "Component", T = p.render;
        T || (a.prototype && typeof a.prototype.render == "function" ? m("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", y) : m("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", y)), p.getInitialState && !p.getInitialState.isReactClassApproved && !p.state && m("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", y), p.getDefaultProps && !p.getDefaultProps.isReactClassApproved && m("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", y), p.propTypes && m("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", y), p.contextType && m("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", y), p.contextTypes && m("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", y), a.contextType && a.contextTypes && !hy.has(a) && (hy.add(a), m("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", y)), typeof p.componentShouldUpdate == "function" && m("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", y), a.prototype && a.prototype.isPureReactComponent && typeof p.shouldComponentUpdate < "u" && m("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Fe(a) || "A pure component"), typeof p.componentDidUnmount == "function" && m("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", y), typeof p.componentDidReceiveProps == "function" && m("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", y), typeof p.componentWillRecieveProps == "function" && m("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", y), typeof p.UNSAFE_componentWillRecieveProps == "function" && m("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", y);
        var L = p.props !== d;
        p.props !== void 0 && L && m("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", y, y), p.defaultProps && m("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", y, y), typeof p.getSnapshotBeforeUpdate == "function" && typeof p.componentDidUpdate != "function" && !uy.has(a) && (uy.add(a), m("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Fe(a))), typeof p.getDerivedStateFromProps == "function" && m("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", y), typeof p.getDerivedStateFromError == "function" && m("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", y), typeof a.getSnapshotBeforeUpdate == "function" && m("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", y);
        var O = p.state;
        O && (typeof O != "object" || yn(O)) && m("%s.state: must be set to an object or null", y), typeof p.getChildContext == "function" && typeof a.childContextTypes != "object" && m("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", y);
      }
    }
    function IS(i, a) {
      a.updater = vy, i.stateNode = a, M(a, i), a._reactInternalInstance = sy;
    }
    function US(i, a, d) {
      var p = !1, y = on, T = on, L = a.contextType;
      if ("contextType" in a) {
        var O = (
          // Allow null for conditional declaration
          L === null || L !== void 0 && L.$$typeof === St && L._context === void 0
        );
        if (!O && !py.has(a)) {
          py.add(a);
          var F = "";
          L === void 0 ? F = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof L != "object" ? F = " However, it is set to a " + typeof L + "." : L.$$typeof === wt ? F = " Did you accidentally pass the Context.Provider instead?" : L._context !== void 0 ? F = " Did you accidentally pass the Context.Consumer instead?" : F = " However, it is set to an object with keys {" + Object.keys(L).join(", ") + "}.", m("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Fe(a) || "Component", F);
        }
      }
      if (typeof L == "object" && L !== null)
        T = it(L);
      else {
        y = ba(i, a, !0);
        var K = a.contextTypes;
        p = K != null, T = p ? Go(i, y) : on;
      }
      var re = new a(d, T);
      if (i.mode & qn) {
        ln(!0);
        try {
          re = new a(d, T);
        } finally {
          ln(!1);
        }
      }
      var me = i.memoizedState = re.state !== null && re.state !== void 0 ? re.state : null;
      IS(i, re);
      {
        if (typeof a.getDerivedStateFromProps == "function" && me === null) {
          var Ce = Fe(a) || "Component";
          ly.has(Ce) || (ly.add(Ce), m("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Ce, re.state === null ? "null" : "undefined", Ce));
        }
        if (typeof a.getDerivedStateFromProps == "function" || typeof re.getSnapshotBeforeUpdate == "function") {
          var ze = null, je = null, Je = null;
          if (typeof re.componentWillMount == "function" && re.componentWillMount.__suppressDeprecationWarning !== !0 ? ze = "componentWillMount" : typeof re.UNSAFE_componentWillMount == "function" && (ze = "UNSAFE_componentWillMount"), typeof re.componentWillReceiveProps == "function" && re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? je = "componentWillReceiveProps" : typeof re.UNSAFE_componentWillReceiveProps == "function" && (je = "UNSAFE_componentWillReceiveProps"), typeof re.componentWillUpdate == "function" && re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Je = "componentWillUpdate" : typeof re.UNSAFE_componentWillUpdate == "function" && (Je = "UNSAFE_componentWillUpdate"), ze !== null || je !== null || Je !== null) {
            var Pt = Fe(a) || "Component", jt = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            cy.has(Pt) || (cy.add(Pt), m(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Pt, jt, ze !== null ? `
  ` + ze : "", je !== null ? `
  ` + je : "", Je !== null ? `
  ` + Je : ""));
          }
        }
      }
      return p && Vo(i, y, T), re;
    }
    function kC(i, a) {
      var d = a.state;
      typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), d !== a.state && (m("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Re(i) || "Component"), vy.enqueueReplaceState(a, a.state, null));
    }
    function FS(i, a, d, p) {
      var y = a.state;
      if (typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(d, p), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(d, p), a.state !== y) {
        {
          var T = Re(i) || "Component";
          oy.has(T) || (oy.add(T), m("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", T));
        }
        vy.enqueueReplaceState(a, a.state, null);
      }
    }
    function gy(i, a, d, p) {
      HC(i, a, d);
      var y = i.stateNode;
      y.props = d, y.state = i.memoizedState, y.refs = PS, bt(i);
      var T = a.contextType;
      if (typeof T == "object" && T !== null)
        y.context = it(T);
      else {
        var L = ba(i, a, !0);
        y.context = Go(i, L);
      }
      {
        if (y.state === d) {
          var O = Fe(a) || "Component";
          dy.has(O) || (dy.add(O), m("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", O));
        }
        i.mode & qn && Gr.recordLegacyContextWarning(i, y), Gr.recordUnsafeLifecycleWarnings(i, y);
      }
      y.state = i.memoizedState;
      var F = a.getDerivedStateFromProps;
      if (typeof F == "function" && (my(i, a, F, d), y.state = i.memoizedState), typeof a.getDerivedStateFromProps != "function" && typeof y.getSnapshotBeforeUpdate != "function" && (typeof y.UNSAFE_componentWillMount == "function" || typeof y.componentWillMount == "function") && (kC(i, y), sf(i, d, y, p), y.state = i.memoizedState), typeof y.componentDidMount == "function") {
        var K = tt;
        K |= nt, (i.mode & Br) !== Ft && (K |= Ct), i.flags |= K;
      }
    }
    function VC(i, a, d, p) {
      var y = i.stateNode, T = i.memoizedProps;
      y.props = T;
      var L = y.context, O = a.contextType, F = on;
      if (typeof O == "object" && O !== null)
        F = it(O);
      else {
        var K = ba(i, a, !0);
        F = Go(i, K);
      }
      var re = a.getDerivedStateFromProps, me = typeof re == "function" || typeof y.getSnapshotBeforeUpdate == "function";
      !me && (typeof y.UNSAFE_componentWillReceiveProps == "function" || typeof y.componentWillReceiveProps == "function") && (T !== d || L !== F) && FS(i, y, d, F), LS();
      var Ce = i.memoizedState, ze = y.state = Ce;
      if (sf(i, d, y, p), ze = i.memoizedState, T === d && Ce === ze && !ui() && !fm()) {
        if (typeof y.componentDidMount == "function") {
          var je = tt;
          je |= nt, (i.mode & Br) !== Ft && (je |= Ct), i.flags |= je;
        }
        return !1;
      }
      typeof re == "function" && (my(i, a, re, d), ze = i.memoizedState);
      var Je = fm() || OS(i, a, T, d, Ce, ze, F);
      if (Je) {
        if (!me && (typeof y.UNSAFE_componentWillMount == "function" || typeof y.componentWillMount == "function") && (typeof y.componentWillMount == "function" && y.componentWillMount(), typeof y.UNSAFE_componentWillMount == "function" && y.UNSAFE_componentWillMount()), typeof y.componentDidMount == "function") {
          var Pt = tt;
          Pt |= nt, (i.mode & Br) !== Ft && (Pt |= Ct), i.flags |= Pt;
        }
      } else {
        if (typeof y.componentDidMount == "function") {
          var jt = tt;
          jt |= nt, (i.mode & Br) !== Ft && (jt |= Ct), i.flags |= jt;
        }
        i.memoizedProps = d, i.memoizedState = ze;
      }
      return y.props = d, y.state = ze, y.context = F, Je;
    }
    function GC(i, a, d, p, y) {
      var T = a.stateNode;
      qt(i, a);
      var L = a.memoizedProps, O = a.type === a.elementType ? L : Wr(a.type, L);
      T.props = O;
      var F = a.pendingProps, K = T.context, re = d.contextType, me = on;
      if (typeof re == "object" && re !== null)
        me = it(re);
      else {
        var Ce = ba(a, d, !0);
        me = Go(a, Ce);
      }
      var ze = d.getDerivedStateFromProps, je = typeof ze == "function" || typeof T.getSnapshotBeforeUpdate == "function";
      !je && (typeof T.UNSAFE_componentWillReceiveProps == "function" || typeof T.componentWillReceiveProps == "function") && (L !== F || K !== me) && FS(a, T, p, me), LS();
      var Je = a.memoizedState, Pt = T.state = Je;
      if (sf(a, p, T, y), Pt = a.memoizedState, L === F && Je === Pt && !ui() && !fm() && !w)
        return typeof T.componentDidUpdate == "function" && (L !== i.memoizedProps || Je !== i.memoizedState) && (a.flags |= tt), typeof T.getSnapshotBeforeUpdate == "function" && (L !== i.memoizedProps || Je !== i.memoizedState) && (a.flags |= $i), !1;
      typeof ze == "function" && (my(a, d, ze, p), Pt = a.memoizedState);
      var jt = fm() || OS(a, d, O, p, Je, Pt, me) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      w;
      return jt ? (!je && (typeof T.UNSAFE_componentWillUpdate == "function" || typeof T.componentWillUpdate == "function") && (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(p, Pt, me), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(p, Pt, me)), typeof T.componentDidUpdate == "function" && (a.flags |= tt), typeof T.getSnapshotBeforeUpdate == "function" && (a.flags |= $i)) : (typeof T.componentDidUpdate == "function" && (L !== i.memoizedProps || Je !== i.memoizedState) && (a.flags |= tt), typeof T.getSnapshotBeforeUpdate == "function" && (L !== i.memoizedProps || Je !== i.memoizedState) && (a.flags |= $i), a.memoizedProps = p, a.memoizedState = Pt), T.props = p, T.state = Pt, T.context = me, jt;
    }
    var of = [], lf = 0, hm = null, pm = 0, Da = [], Pa = 0, bu = null, co = 1, fo = "";
    function WC(i) {
      return Eu(), (i.flags & at) !== fe;
    }
    function qC(i) {
      return Eu(), pm;
    }
    function jC() {
      var i = fo, a = co, d = a & ~YC(a);
      return d.toString(32) + i;
    }
    function wu(i, a) {
      Eu(), of[lf++] = pm, of[lf++] = hm, hm = i, pm = a;
    }
    function BS(i, a, d) {
      Eu(), Da[Pa++] = co, Da[Pa++] = fo, Da[Pa++] = bu, bu = i;
      var p = co, y = fo, T = mm(p) - 1, L = p & ~(1 << T), O = d + 1, F = mm(a) + T;
      if (F > 30) {
        var K = T - T % 5, re = (1 << K) - 1, me = (L & re).toString(32), Ce = L >> K, ze = T - K, je = mm(a) + ze, Je = O << ze, Pt = Je | Ce, jt = me + y;
        co = 1 << je | Pt, fo = jt;
      } else {
        var Ot = O << T, kn = Ot | L, Vn = y;
        co = 1 << F | kn, fo = Vn;
      }
    }
    function yy(i) {
      Eu();
      var a = i.return;
      if (a !== null) {
        var d = 1, p = 0;
        wu(i, d), BS(i, d, p);
      }
    }
    function mm(i) {
      return 32 - qo(i);
    }
    function YC(i) {
      return 1 << mm(i) - 1;
    }
    function _y(i) {
      for (; i === hm; )
        hm = of[--lf], of[lf] = null, pm = of[--lf], of[lf] = null;
      for (; i === bu; )
        bu = Da[--Pa], Da[Pa] = null, fo = Da[--Pa], Da[Pa] = null, co = Da[--Pa], Da[Pa] = null;
    }
    function XC() {
      return Eu(), bu !== null ? {
        id: co,
        overflow: fo
      } : null;
    }
    function ZC(i, a) {
      Eu(), Da[Pa++] = co, Da[Pa++] = fo, Da[Pa++] = bu, co = a.id, fo = a.overflow, bu = i;
    }
    function Eu() {
      lr() || m("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var qi = null, Na = null, ns = !1, Tu = !1, pl = null;
    function JC() {
      ns && m("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function QC() {
      Tu = !0;
    }
    function KC(i) {
      if (!Gi)
        return !1;
      var a = i.stateNode.containerInfo;
      return Na = gs(a), qi = i, ns = !0, pl = null, Tu = !1, !0;
    }
    function $C(i, a, d) {
      return Gi ? (Na = wc(a), qi = i, ns = !0, pl = null, Tu = !1, d !== null && ZC(i, d), !0) : !1;
    }
    function HS(i, a) {
      switch (i.tag) {
        case G:
          Uo(i.stateNode.containerInfo, a);
          break;
        case oe:
          Ac(i.type, i.memoizedProps, i.stateNode, a);
          break;
        case Y:
          var d = i.memoizedState;
          d.dehydrated !== null && Rc(d.dehydrated, a);
          break;
      }
    }
    function kS(i, a) {
      HS(i, a);
      var d = e2();
      d.stateNode = a, d.return = i;
      var p = i.deletions;
      p === null ? (i.deletions = [d], i.flags |= an) : p.push(d);
    }
    function xy(i, a) {
      {
        if (Tu)
          return;
        switch (i.tag) {
          case G: {
            var d = i.stateNode.containerInfo;
            switch (a.tag) {
              case oe:
                var p = a.type, y = a.pendingProps;
                Or(d, p, y);
                break;
              case ne:
                var T = a.pendingProps;
                Ir(d, T);
                break;
              case Y:
                Gs(d);
                break;
            }
            break;
          }
          case oe: {
            var L = i.type, O = i.memoizedProps, F = i.stateNode;
            switch (a.tag) {
              case oe:
                var K = a.type, re = a.pendingProps;
                Yp(L, O, F, K, re);
                break;
              case ne:
                var me = a.pendingProps;
                Td(L, O, F, me);
                break;
              case Y:
                Cd(L, O, F);
                break;
            }
            break;
          }
          case Y: {
            var Ce = i.memoizedState, ze = Ce.dehydrated;
            if (ze !== null)
              switch (a.tag) {
                case oe:
                  var je = a.type, Je = a.pendingProps;
                  Xa(ze, je, Je);
                  break;
                case ne:
                  var Pt = a.pendingProps;
                  Za(ze, Pt);
                  break;
                case Y:
                  Ws(ze);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function VS(i, a) {
      a.flags = a.flags & ~wi | Be, xy(i, a);
    }
    function GS(i, a) {
      switch (i.tag) {
        case oe: {
          var d = i.type, p = i.pendingProps, y = bd(a, d, p);
          return y !== null ? (i.stateNode = y, qi = i, Na = Ya(y), !0) : !1;
        }
        case ne: {
          var T = i.pendingProps, L = Oo(a, T);
          return L !== null ? (i.stateNode = L, qi = i, Na = null, !0) : !1;
        }
        case Y: {
          {
            var O = zr(a);
            if (O !== null) {
              var F = {
                dehydrated: O,
                treeContext: XC(),
                retryLane: Tn
              };
              i.memoizedState = F;
              var K = t2(O);
              return K.return = i, i.child = K, qi = i, Na = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Sy(i) {
      return (i.mode & Mn) !== Ft && (i.flags & Bt) === fe;
    }
    function My(i) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function by(i) {
      if (ns) {
        var a = Na;
        if (!a) {
          Sy(i) && (xy(qi, i), My()), VS(qi, i), ns = !1, qi = i;
          return;
        }
        var d = a;
        if (!GS(i, a)) {
          Sy(i) && (xy(qi, i), My()), a = Ql(d);
          var p = qi;
          if (!a || !GS(i, a)) {
            VS(qi, i), ns = !1, qi = i;
            return;
          }
          kS(p, d);
        }
      }
    }
    function eR(i, a, d) {
      if (!Gi)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var p = i.stateNode, y = !Tu, T = kp(p, i.type, i.memoizedProps, a, d, i, y);
      return i.updateQueue = T, T !== null;
    }
    function tR(i) {
      if (!Gi)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = i.stateNode, d = i.memoizedProps, p = !Tu, y = Ec(a, d, i, p);
      if (y) {
        var T = qi;
        if (T !== null) {
          var L = (T.mode & Mn) !== Ft;
          switch (T.tag) {
            case G: {
              var O = T.stateNode.containerInfo;
              Ed(
                O,
                a,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                L
              );
              break;
            }
            case oe: {
              var F = T.type, K = T.memoizedProps, re = T.stateNode;
              Io(
                F,
                K,
                re,
                a,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                L
              );
              break;
            }
          }
        }
      }
      return y;
    }
    function nR(i) {
      if (!Gi)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = i.memoizedState, d = a !== null ? a.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Vp(d, i);
    }
    function iR(i) {
      if (!Gi)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var a = i.memoizedState, d = a !== null ? a.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Gp(d);
    }
    function WS(i) {
      for (var a = i.return; a !== null && a.tag !== oe && a.tag !== G && a.tag !== Y; )
        a = a.return;
      qi = a;
    }
    function ah(i) {
      if (!Gi || i !== qi)
        return !1;
      if (!ns)
        return WS(i), ns = !0, !1;
      if (i.tag !== G && (i.tag !== oe || jp(i.type) && !pd(i.type, i.memoizedProps))) {
        var a = Na;
        if (a)
          if (Sy(i))
            qS(i), My();
          else
            for (; a; )
              kS(i, a), a = Ql(a);
      }
      return WS(i), i.tag === Y ? Na = iR(i) : Na = qi ? Ql(i.stateNode) : null, !0;
    }
    function rR() {
      return ns && Na !== null;
    }
    function qS(i) {
      for (var a = Na; a; )
        HS(i, a), a = Ql(a);
    }
    function uf() {
      Gi && (qi = null, Na = null, ns = !1, Tu = !1);
    }
    function jS() {
      pl !== null && (PM(pl), pl = null);
    }
    function lr() {
      return ns;
    }
    function wy(i) {
      pl === null ? pl = [i] : pl.push(i);
    }
    var Ey, Ty, Cy, Ry, Ay, YS = function(i, a) {
    };
    Ey = !1, Ty = !1, Cy = {}, Ry = {}, Ay = {}, YS = function(i, a) {
      if (!(i === null || typeof i != "object") && !(!i._store || i._store.validated || i.key != null)) {
        if (typeof i._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        i._store.validated = !0;
        var d = Re(a) || "Component";
        Ry[d] || (Ry[d] = !0, m('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function sh(i, a, d) {
      var p = d.ref;
      if (p !== null && typeof p != "function" && typeof p != "object") {
        if ((i.mode & qn || P) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(d._owner && d._self && d._owner.stateNode !== d._self)) {
          var y = Re(i) || "Component";
          Cy[y] || (m('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', p), Cy[y] = !0);
        }
        if (d._owner) {
          var T = d._owner, L;
          if (T) {
            var O = T;
            if (O.tag !== z)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            L = O.stateNode;
          }
          if (!L)
            throw new Error("Missing owner for string ref " + p + ". This error is likely caused by a bug in React. Please file an issue.");
          var F = L;
          cm(p, "ref");
          var K = "" + p;
          if (a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === K)
            return a.ref;
          var re = function(me) {
            var Ce = F.refs;
            Ce === PS && (Ce = F.refs = {}), me === null ? delete Ce[K] : Ce[K] = me;
          };
          return re._stringRef = K, re;
        } else {
          if (typeof p != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!d._owner)
            throw new Error("Element ref was specified as a string (" + p + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return p;
    }
    function vm(i, a) {
      var d = Object.prototype.toString.call(a);
      throw new Error("Objects are not valid as a React child (found: " + (d === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : d) + "). If you meant to render a collection of children, use an array instead.");
    }
    function gm(i) {
      {
        var a = Re(i) || "Component";
        if (Ay[a])
          return;
        Ay[a] = !0, m("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function XS(i) {
      var a = i._payload, d = i._init;
      return d(a);
    }
    function ZS(i) {
      function a(Se, Oe) {
        if (i) {
          var _e = Se.deletions;
          _e === null ? (Se.deletions = [Oe], Se.flags |= an) : _e.push(Oe);
        }
      }
      function d(Se, Oe) {
        if (!i)
          return null;
        for (var _e = Oe; _e !== null; )
          a(Se, _e), _e = _e.sibling;
        return null;
      }
      function p(Se, Oe) {
        for (var _e = /* @__PURE__ */ new Map(), et = Oe; et !== null; )
          et.key !== null ? _e.set(et.key, et) : _e.set(et.index, et), et = et.sibling;
        return _e;
      }
      function y(Se, Oe) {
        var _e = Nu(Se, Oe);
        return _e.index = 0, _e.sibling = null, _e;
      }
      function T(Se, Oe, _e) {
        if (Se.index = _e, !i)
          return Se.flags |= at, Oe;
        var et = Se.alternate;
        if (et !== null) {
          var Dt = et.index;
          return Dt < Oe ? (Se.flags |= Be, Oe) : Dt;
        } else
          return Se.flags |= Be, Oe;
      }
      function L(Se) {
        return i && Se.alternate === null && (Se.flags |= Be), Se;
      }
      function O(Se, Oe, _e, et) {
        if (Oe === null || Oe.tag !== ne) {
          var Dt = K0(_e, Se.mode, et);
          return Dt.return = Se, Dt;
        } else {
          var yt = y(Oe, _e);
          return yt.return = Se, yt;
        }
      }
      function F(Se, Oe, _e, et) {
        var Dt = _e.type;
        if (Dt === ke)
          return re(Se, Oe, _e.props.children, et, _e.key);
        if (Oe !== null && (Oe.elementType === Dt || // Keep this check inline so it only runs on the false path:
        YM(Oe, _e) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Dt == "object" && Dt !== null && Dt.$$typeof === H && XS(Dt) === Oe.type)) {
          var yt = y(Oe, _e.props);
          return yt.ref = sh(Se, Oe, _e), yt.return = Se, yt._debugSource = _e._source, yt._debugOwner = _e._owner, yt;
        }
        var rn = Q0(_e, Se.mode, et);
        return rn.ref = sh(Se, Oe, _e), rn.return = Se, rn;
      }
      function K(Se, Oe, _e, et) {
        if (Oe === null || Oe.tag !== $ || Oe.stateNode.containerInfo !== _e.containerInfo || Oe.stateNode.implementation !== _e.implementation) {
          var Dt = $0(_e, Se.mode, et);
          return Dt.return = Se, Dt;
        } else {
          var yt = y(Oe, _e.children || []);
          return yt.return = Se, yt;
        }
      }
      function re(Se, Oe, _e, et, Dt) {
        if (Oe === null || Oe.tag !== ee) {
          var yt = bl(_e, Se.mode, et, Dt);
          return yt.return = Se, yt;
        } else {
          var rn = y(Oe, _e);
          return rn.return = Se, rn;
        }
      }
      function me(Se, Oe, _e) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") {
          var et = K0("" + Oe, Se.mode, _e);
          return et.return = Se, et;
        }
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case Ne: {
              var Dt = Q0(Oe, Se.mode, _e);
              return Dt.ref = sh(Se, null, Oe), Dt.return = Se, Dt;
            }
            case we: {
              var yt = $0(Oe, Se.mode, _e);
              return yt.return = Se, yt;
            }
            case H: {
              var rn = Oe._payload, bn = Oe._init;
              return me(Se, bn(rn), _e);
            }
          }
          if (yn(Oe) || pe(Oe)) {
            var In = bl(Oe, Se.mode, _e, null);
            return In.return = Se, In;
          }
          vm(Se, Oe);
        }
        return typeof Oe == "function" && gm(Se), null;
      }
      function Ce(Se, Oe, _e, et) {
        var Dt = Oe !== null ? Oe.key : null;
        if (typeof _e == "string" && _e !== "" || typeof _e == "number")
          return Dt !== null ? null : O(Se, Oe, "" + _e, et);
        if (typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case Ne:
              return _e.key === Dt ? F(Se, Oe, _e, et) : null;
            case we:
              return _e.key === Dt ? K(Se, Oe, _e, et) : null;
            case H: {
              var yt = _e._payload, rn = _e._init;
              return Ce(Se, Oe, rn(yt), et);
            }
          }
          if (yn(_e) || pe(_e))
            return Dt !== null ? null : re(Se, Oe, _e, et, null);
          vm(Se, _e);
        }
        return typeof _e == "function" && gm(Se), null;
      }
      function ze(Se, Oe, _e, et, Dt) {
        if (typeof et == "string" && et !== "" || typeof et == "number") {
          var yt = Se.get(_e) || null;
          return O(Oe, yt, "" + et, Dt);
        }
        if (typeof et == "object" && et !== null) {
          switch (et.$$typeof) {
            case Ne: {
              var rn = Se.get(et.key === null ? _e : et.key) || null;
              return F(Oe, rn, et, Dt);
            }
            case we: {
              var bn = Se.get(et.key === null ? _e : et.key) || null;
              return K(Oe, bn, et, Dt);
            }
            case H: {
              var In = et._payload, wn = et._init;
              return ze(Se, Oe, _e, wn(In), Dt);
            }
          }
          if (yn(et) || pe(et)) {
            var $n = Se.get(_e) || null;
            return re(Oe, $n, et, Dt, null);
          }
          vm(Oe, et);
        }
        return typeof et == "function" && gm(Oe), null;
      }
      function je(Se, Oe, _e) {
        {
          if (typeof Se != "object" || Se === null)
            return Oe;
          switch (Se.$$typeof) {
            case Ne:
            case we:
              YS(Se, _e);
              var et = Se.key;
              if (typeof et != "string")
                break;
              if (Oe === null) {
                Oe = /* @__PURE__ */ new Set(), Oe.add(et);
                break;
              }
              if (!Oe.has(et)) {
                Oe.add(et);
                break;
              }
              m("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", et);
              break;
            case H: {
              var Dt = Se._payload, yt = Se._init;
              je(yt(Dt), Oe, _e);
              break;
            }
          }
        }
        return Oe;
      }
      function Je(Se, Oe, _e, et) {
        for (var Dt = null, yt = 0; yt < _e.length; yt++) {
          var rn = _e[yt];
          Dt = je(rn, Dt, Se);
        }
        for (var bn = null, In = null, wn = Oe, $n = 0, mn = 0, en = null; wn !== null && mn < _e.length; mn++) {
          wn.index > mn ? (en = wn, wn = null) : en = wn.sibling;
          var pi = Ce(Se, wn, _e[mn], et);
          if (pi === null) {
            wn === null && (wn = en);
            break;
          }
          i && wn && pi.alternate === null && a(Se, wn), $n = T(pi, $n, mn), In === null ? bn = pi : In.sibling = pi, In = pi, wn = en;
        }
        if (mn === _e.length) {
          if (d(Se, wn), lr()) {
            var ei = mn;
            wu(Se, ei);
          }
          return bn;
        }
        if (wn === null) {
          for (; mn < _e.length; mn++) {
            var Ba = me(Se, _e[mn], et);
            Ba !== null && ($n = T(Ba, $n, mn), In === null ? bn = Ba : In.sibling = Ba, In = Ba);
          }
          if (lr()) {
            var Ji = mn;
            wu(Se, Ji);
          }
          return bn;
        }
        for (var ua = p(Se, wn); mn < _e.length; mn++) {
          var ca = ze(ua, Se, mn, _e[mn], et);
          ca !== null && (i && ca.alternate !== null && ua.delete(ca.key === null ? mn : ca.key), $n = T(ca, $n, mn), In === null ? bn = ca : In.sibling = ca, In = ca);
        }
        if (i && ua.forEach(function(Ef) {
          return a(Se, Ef);
        }), lr()) {
          var Os = mn;
          wu(Se, Os);
        }
        return bn;
      }
      function Pt(Se, Oe, _e, et) {
        var Dt = pe(_e);
        if (typeof Dt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          _e[Symbol.toStringTag] === "Generator" && (Ty || m("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ty = !0), _e.entries === Dt && (Ey || m("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ey = !0);
          var yt = Dt.call(_e);
          if (yt)
            for (var rn = null, bn = yt.next(); !bn.done; bn = yt.next()) {
              var In = bn.value;
              rn = je(In, rn, Se);
            }
        }
        var wn = Dt.call(_e);
        if (wn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var $n = null, mn = null, en = Oe, pi = 0, ei = 0, Ba = null, Ji = wn.next(); en !== null && !Ji.done; ei++, Ji = wn.next()) {
          en.index > ei ? (Ba = en, en = null) : Ba = en.sibling;
          var ua = Ce(Se, en, Ji.value, et);
          if (ua === null) {
            en === null && (en = Ba);
            break;
          }
          i && en && ua.alternate === null && a(Se, en), pi = T(ua, pi, ei), mn === null ? $n = ua : mn.sibling = ua, mn = ua, en = Ba;
        }
        if (Ji.done) {
          if (d(Se, en), lr()) {
            var ca = ei;
            wu(Se, ca);
          }
          return $n;
        }
        if (en === null) {
          for (; !Ji.done; ei++, Ji = wn.next()) {
            var Os = me(Se, Ji.value, et);
            Os !== null && (pi = T(Os, pi, ei), mn === null ? $n = Os : mn.sibling = Os, mn = Os);
          }
          if (lr()) {
            var Ef = ei;
            wu(Se, Ef);
          }
          return $n;
        }
        for (var Tf = p(Se, en); !Ji.done; ei++, Ji = wn.next()) {
          var fa = ze(Tf, Se, ei, Ji.value, et);
          fa !== null && (i && fa.alternate !== null && Tf.delete(fa.key === null ? ei : fa.key), pi = T(fa, pi, ei), mn === null ? $n = fa : mn.sibling = fa, mn = fa);
        }
        if (i && Tf.forEach(function(r_) {
          return a(Se, r_);
        }), lr()) {
          var zu = ei;
          wu(Se, zu);
        }
        return $n;
      }
      function jt(Se, Oe, _e, et) {
        if (Oe !== null && Oe.tag === ne) {
          d(Se, Oe.sibling);
          var Dt = y(Oe, _e);
          return Dt.return = Se, Dt;
        }
        d(Se, Oe);
        var yt = K0(_e, Se.mode, et);
        return yt.return = Se, yt;
      }
      function Ot(Se, Oe, _e, et) {
        for (var Dt = _e.key, yt = Oe; yt !== null; ) {
          if (yt.key === Dt) {
            var rn = _e.type;
            if (rn === ke) {
              if (yt.tag === ee) {
                d(Se, yt.sibling);
                var bn = y(yt, _e.props.children);
                return bn.return = Se, bn._debugSource = _e._source, bn._debugOwner = _e._owner, bn;
              }
            } else if (yt.elementType === rn || // Keep this check inline so it only runs on the false path:
            YM(yt, _e) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof rn == "object" && rn !== null && rn.$$typeof === H && XS(rn) === yt.type) {
              d(Se, yt.sibling);
              var In = y(yt, _e.props);
              return In.ref = sh(Se, yt, _e), In.return = Se, In._debugSource = _e._source, In._debugOwner = _e._owner, In;
            }
            d(Se, yt);
            break;
          } else
            a(Se, yt);
          yt = yt.sibling;
        }
        if (_e.type === ke) {
          var wn = bl(_e.props.children, Se.mode, et, _e.key);
          return wn.return = Se, wn;
        } else {
          var $n = Q0(_e, Se.mode, et);
          return $n.ref = sh(Se, Oe, _e), $n.return = Se, $n;
        }
      }
      function kn(Se, Oe, _e, et) {
        for (var Dt = _e.key, yt = Oe; yt !== null; ) {
          if (yt.key === Dt)
            if (yt.tag === $ && yt.stateNode.containerInfo === _e.containerInfo && yt.stateNode.implementation === _e.implementation) {
              d(Se, yt.sibling);
              var rn = y(yt, _e.children || []);
              return rn.return = Se, rn;
            } else {
              d(Se, yt);
              break;
            }
          else
            a(Se, yt);
          yt = yt.sibling;
        }
        var bn = $0(_e, Se.mode, et);
        return bn.return = Se, bn;
      }
      function Vn(Se, Oe, _e, et) {
        var Dt = typeof _e == "object" && _e !== null && _e.type === ke && _e.key === null;
        if (Dt && (_e = _e.props.children), typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case Ne:
              return L(Ot(Se, Oe, _e, et));
            case we:
              return L(kn(Se, Oe, _e, et));
            case H: {
              var yt = _e._payload, rn = _e._init;
              return Vn(Se, Oe, rn(yt), et);
            }
          }
          if (yn(_e))
            return Je(Se, Oe, _e, et);
          if (pe(_e))
            return Pt(Se, Oe, _e, et);
          vm(Se, _e);
        }
        return typeof _e == "string" && _e !== "" || typeof _e == "number" ? L(jt(Se, Oe, "" + _e, et)) : (typeof _e == "function" && gm(Se), d(Se, Oe));
      }
      return Vn;
    }
    var cf = ZS(!0), JS = ZS(!1);
    function aR(i, a) {
      if (i !== null && a.child !== i.child)
        throw new Error("Resuming work not yet implemented.");
      if (a.child !== null) {
        var d = a.child, p = Nu(d, d.pendingProps);
        for (a.child = p, p.return = a; d.sibling !== null; )
          d = d.sibling, p = p.sibling = Nu(d, d.pendingProps), p.return = a;
        p.sibling = null;
      }
    }
    function sR(i, a) {
      for (var d = i.child; d !== null; )
        Z3(d, a), d = d.sibling;
    }
    var oh = {}, ml = Ma(oh), lh = Ma(oh), ym = Ma(oh);
    function _m(i) {
      if (i === oh)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return i;
    }
    function Ly() {
      var i = _m(ym.current);
      return i;
    }
    function Dy(i, a) {
      En(ym, a, i), En(lh, i, i), En(ml, oh, i);
      var d = qa(a);
      li(ml, i), En(ml, d, i);
    }
    function ff(i) {
      li(ml, i), li(lh, i), li(ym, i);
    }
    function uh() {
      var i = _m(ml.current);
      return i;
    }
    function QS(i) {
      var a = _m(ym.current), d = _m(ml.current), p = nr(d, i.type, a);
      d !== p && (En(lh, i, i), En(ml, p, i));
    }
    function Py(i) {
      lh.current === i && (li(ml, i), li(lh, i));
    }
    var oR = 0, KS = 1, $S = 1, ch = 2, is = Ma(oR);
    function Ny(i, a) {
      return (i & a) !== 0;
    }
    function df(i) {
      return i & KS;
    }
    function zy(i, a) {
      return i & KS | a;
    }
    function lR(i, a) {
      return i | a;
    }
    function vl(i, a) {
      En(is, a, i);
    }
    function hf(i) {
      li(is, i);
    }
    function uR(i, a) {
      var d = i.memoizedState;
      return d !== null ? d.dehydrated !== null : (i.memoizedProps, !0);
    }
    function xm(i) {
      for (var a = i; a !== null; ) {
        if (a.tag === Y) {
          var d = a.memoizedState;
          if (d !== null) {
            var p = d.dehydrated;
            if (p === null || $r(p) || Sa(p))
              return a;
          }
        } else if (a.tag === ve && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        a.memoizedProps.revealOrder !== void 0) {
          var y = (a.flags & Bt) !== fe;
          if (y)
            return a;
        } else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === i)
          return null;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === i)
            return null;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return null;
    }
    var As = (
      /*   */
      0
    ), Jn = (
      /* */
      1
    ), gl = (
      /*  */
      2
    ), hi = (
      /*    */
      4
    ), ji = (
      /*   */
      8
    ), Oy = [];
    function Iy() {
      for (var i = 0; i < Oy.length; i++) {
        var a = Oy[i];
        ms ? a._workInProgressVersionPrimary = null : a._workInProgressVersionSecondary = null;
      }
      Oy.length = 0;
    }
    function cR(i, a) {
      var d = a._getVersion, p = d(a._source);
      i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [a, p] : i.mutableSourceEagerHydrationData.push(a, p);
    }
    var vt = s.ReactCurrentDispatcher, qr = s.ReactCurrentBatchConfig, Uy, pf;
    Uy = /* @__PURE__ */ new Set();
    var mf = Ge, Nn = null, ur = null, Ai = null, Sm = !1, fh = !1, dh = 0, fR = 0, dR = 25, Ie = null, za = null, yl = -1, Fy = !1;
    function _n() {
      {
        var i = Ie;
        za === null ? za = [i] : za.push(i);
      }
    }
    function st() {
      {
        var i = Ie;
        za !== null && (yl++, za[yl] !== i && hR(i));
      }
    }
    function vf(i) {
      i != null && !yn(i) && m("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Ie, typeof i);
    }
    function hR(i) {
      {
        var a = Re(Nn);
        if (!Uy.has(a) && (Uy.add(a), za !== null)) {
          for (var d = "", p = 30, y = 0; y <= yl; y++) {
            for (var T = za[y], L = y === yl ? i : T, O = y + 1 + ". " + T; O.length < p; )
              O += " ";
            O += L + `
`, d += O;
          }
          m(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, a, d);
        }
      }
    }
    function cr() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function By(i, a) {
      if (Fy)
        return !1;
      if (a === null)
        return m("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Ie), !1;
      i.length !== a.length && m(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Ie, "[" + a.join(", ") + "]", "[" + i.join(", ") + "]");
      for (var d = 0; d < a.length && d < i.length; d++)
        if (!Er(i[d], a[d]))
          return !1;
      return !0;
    }
    function gf(i, a, d, p, y, T) {
      mf = T, Nn = a, za = i !== null ? i._debugHookTypes : null, yl = -1, Fy = i !== null && i.type !== a.type, a.memoizedState = null, a.updateQueue = null, a.lanes = Ge, i !== null && i.memoizedState !== null ? vt.current = S1 : za !== null ? vt.current = x1 : vt.current = _1;
      var L = d(p, y);
      if (fh) {
        var O = 0;
        do {
          if (fh = !1, dh = 0, O >= dR)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          O += 1, Fy = !1, ur = null, Ai = null, a.updateQueue = null, yl = -1, vt.current = M1, L = d(p, y);
        } while (fh);
      }
      vt.current = zm, a._debugHookTypes = za;
      var F = ur !== null && ur.next !== null;
      if (mf = Ge, Nn = null, ur = null, Ai = null, Ie = null, za = null, yl = -1, i !== null && (i.flags & fn) !== (a.flags & fn) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (i.mode & Mn) !== Ft && m("Internal React error: Expected static flag was missing. Please notify the React team."), Sm = !1, F)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return L;
    }
    function yf() {
      var i = dh !== 0;
      return dh = 0, i;
    }
    function e1(i, a, d) {
      a.updateQueue = i.updateQueue, (a.mode & Br) !== Ft ? a.flags &= ~(Mt | Ct | Ii | tt) : a.flags &= ~(Ii | tt), i.lanes = $s(i.lanes, d);
    }
    function t1() {
      if (vt.current = zm, Sm) {
        for (var i = Nn.memoizedState; i !== null; ) {
          var a = i.queue;
          a !== null && (a.pending = null), i = i.next;
        }
        Sm = !1;
      }
      mf = Ge, Nn = null, ur = null, Ai = null, za = null, yl = -1, Ie = null, h1 = !1, fh = !1, dh = 0;
    }
    function ho() {
      var i = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ai === null ? Nn.memoizedState = Ai = i : Ai = Ai.next = i, Ai;
    }
    function Ls() {
      var i;
      if (ur === null) {
        var a = Nn.alternate;
        a !== null ? i = a.memoizedState : i = null;
      } else
        i = ur.next;
      var d;
      if (Ai === null ? d = Nn.memoizedState : d = Ai.next, d !== null)
        Ai = d, d = Ai.next, ur = i;
      else {
        if (i === null)
          throw new Error("Rendered more hooks than during the previous render.");
        ur = i;
        var p = {
          memoizedState: ur.memoizedState,
          baseState: ur.baseState,
          baseQueue: ur.baseQueue,
          queue: ur.queue,
          next: null
        };
        Ai === null ? Nn.memoizedState = Ai = p : Ai = Ai.next = p;
      }
      return Ai;
    }
    function n1() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Hy(i, a) {
      return typeof a == "function" ? a(i) : a;
    }
    function ky(i, a, d) {
      var p = ho(), y;
      d !== void 0 ? y = d(a) : y = a, p.memoizedState = p.baseState = y;
      var T = {
        pending: null,
        interleaved: null,
        lanes: Ge,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: y
      };
      p.queue = T;
      var L = T.dispatch = gR.bind(null, Nn, T);
      return [p.memoizedState, L];
    }
    function Vy(i, a, d) {
      var p = Ls(), y = p.queue;
      if (y === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      y.lastRenderedReducer = i;
      var T = ur, L = T.baseQueue, O = y.pending;
      if (O !== null) {
        if (L !== null) {
          var F = L.next, K = O.next;
          L.next = K, O.next = F;
        }
        T.baseQueue !== L && m("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), T.baseQueue = L = O, y.pending = null;
      }
      if (L !== null) {
        var re = L.next, me = T.baseState, Ce = null, ze = null, je = null, Je = re;
        do {
          var Pt = Je.lane;
          if (el(mf, Pt)) {
            if (je !== null) {
              var Ot = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: ci,
                action: Je.action,
                hasEagerState: Je.hasEagerState,
                eagerState: Je.eagerState,
                next: null
              };
              je = je.next = Ot;
            }
            if (Je.hasEagerState)
              me = Je.eagerState;
            else {
              var kn = Je.action;
              me = i(me, kn);
            }
          } else {
            var jt = {
              lane: Pt,
              action: Je.action,
              hasEagerState: Je.hasEagerState,
              eagerState: Je.eagerState,
              next: null
            };
            je === null ? (ze = je = jt, Ce = me) : je = je.next = jt, Nn.lanes = Wt(Nn.lanes, Pt), vv(Pt);
          }
          Je = Je.next;
        } while (Je !== null && Je !== re);
        je === null ? Ce = me : je.next = ze, Er(me, p.memoizedState) || Ym(), p.memoizedState = me, p.baseState = Ce, p.baseQueue = je, y.lastRenderedState = me;
      }
      var Vn = y.interleaved;
      if (Vn !== null) {
        var Se = Vn;
        do {
          var Oe = Se.lane;
          Nn.lanes = Wt(Nn.lanes, Oe), vv(Oe), Se = Se.next;
        } while (Se !== Vn);
      } else
        L === null && (y.lanes = Ge);
      var _e = y.dispatch;
      return [p.memoizedState, _e];
    }
    function Gy(i, a, d) {
      var p = Ls(), y = p.queue;
      if (y === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      y.lastRenderedReducer = i;
      var T = y.dispatch, L = y.pending, O = p.memoizedState;
      if (L !== null) {
        y.pending = null;
        var F = L.next, K = F;
        do {
          var re = K.action;
          O = i(O, re), K = K.next;
        } while (K !== F);
        Er(O, p.memoizedState) || Ym(), p.memoizedState = O, p.baseQueue === null && (p.baseState = O), y.lastRenderedState = O;
      }
      return [O, T];
    }
    function LF(i, a, d) {
    }
    function DF(i, a, d) {
    }
    function Wy(i, a, d) {
      var p = Nn, y = ho(), T, L = lr();
      if (L) {
        if (d === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        T = d(), pf || T !== d() && (m("The result of getServerSnapshot should be cached to avoid an infinite loop"), pf = !0);
      } else {
        if (T = a(), !pf) {
          var O = a();
          Er(T, O) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), pf = !0);
        }
        var F = dv();
        if (F === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ks(F, mf) || i1(p, a, T);
      }
      y.memoizedState = T;
      var K = {
        value: T,
        getSnapshot: a
      };
      return y.queue = K, vh(a1.bind(null, p, K, i), [i]), p.flags |= Ii, ph(Jn | ji, r1.bind(null, p, K, T, a), void 0, null), T;
    }
    function Mm(i, a, d) {
      var p = Nn, y = Ls(), T = a();
      if (!pf) {
        var L = a();
        Er(T, L) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), pf = !0);
      }
      var O = y.memoizedState, F = !Er(O, T);
      F && (y.memoizedState = T, Ym());
      var K = y.queue;
      if (Cu(a1.bind(null, p, K, i), [i]), K.getSnapshot !== a || F || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ai !== null && Ai.memoizedState.tag & Jn) {
        p.flags |= Ii, ph(Jn | ji, r1.bind(null, p, K, T, a), void 0, null);
        var re = dv();
        if (re === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ks(re, mf) || i1(p, a, T);
      }
      return T;
    }
    function i1(i, a, d) {
      i.flags |= j;
      var p = {
        getSnapshot: a,
        value: d
      }, y = Nn.updateQueue;
      if (y === null)
        y = n1(), Nn.updateQueue = y, y.stores = [p];
      else {
        var T = y.stores;
        T === null ? y.stores = [p] : T.push(p);
      }
    }
    function r1(i, a, d, p) {
      a.value = d, a.getSnapshot = p, s1(a) && o1(i);
    }
    function a1(i, a, d) {
      var p = function() {
        s1(a) && o1(i);
      };
      return d(p);
    }
    function s1(i) {
      var a = i.getSnapshot, d = i.value;
      try {
        var p = a();
        return !Er(d, p);
      } catch {
        return !0;
      }
    }
    function o1(i) {
      Pi(i, $t, Pn);
    }
    function hh(i) {
      var a = ho();
      typeof i == "function" && (i = i()), a.memoizedState = a.baseState = i;
      var d = {
        pending: null,
        interleaved: null,
        lanes: Ge,
        dispatch: null,
        lastRenderedReducer: Hy,
        lastRenderedState: i
      };
      a.queue = d;
      var p = d.dispatch = yR.bind(null, Nn, d);
      return [a.memoizedState, p];
    }
    function bm(i) {
      return Vy(Hy);
    }
    function wm(i) {
      return Gy(Hy);
    }
    function ph(i, a, d, p) {
      var y = {
        tag: i,
        create: a,
        destroy: d,
        deps: p,
        // Circular
        next: null
      }, T = Nn.updateQueue;
      if (T === null)
        T = n1(), Nn.updateQueue = T, T.lastEffect = y.next = y;
      else {
        var L = T.lastEffect;
        if (L === null)
          T.lastEffect = y.next = y;
        else {
          var O = L.next;
          L.next = y, y.next = O, T.lastEffect = y;
        }
      }
      return y;
    }
    function qy(i) {
      var a = ho();
      {
        var d = {
          current: i
        };
        return a.memoizedState = d, d;
      }
    }
    function Em(i) {
      var a = Ls();
      return a.memoizedState;
    }
    function mh(i, a, d, p) {
      var y = ho(), T = p === void 0 ? null : p;
      Nn.flags |= i, y.memoizedState = ph(Jn | a, d, void 0, T);
    }
    function Tm(i, a, d, p) {
      var y = Ls(), T = p === void 0 ? null : p, L = void 0;
      if (ur !== null) {
        var O = ur.memoizedState;
        if (L = O.destroy, T !== null) {
          var F = O.deps;
          if (By(T, F)) {
            y.memoizedState = ph(a, d, L, T);
            return;
          }
        }
      }
      Nn.flags |= i, y.memoizedState = ph(Jn | a, d, L, T);
    }
    function vh(i, a) {
      return (Nn.mode & Br) !== Ft ? mh(Mt | Ii | ht, ji, i, a) : mh(Ii | ht, ji, i, a);
    }
    function Cu(i, a) {
      return Tm(Ii, ji, i, a);
    }
    function jy(i, a) {
      return mh(tt, gl, i, a);
    }
    function Cm(i, a) {
      return Tm(tt, gl, i, a);
    }
    function Yy(i, a) {
      var d = tt;
      return d |= nt, (Nn.mode & Br) !== Ft && (d |= Ct), mh(d, hi, i, a);
    }
    function Rm(i, a) {
      return Tm(tt, hi, i, a);
    }
    function l1(i, a) {
      if (typeof a == "function") {
        var d = a, p = i();
        return d(p), function() {
          d(null);
        };
      } else if (a != null) {
        var y = a;
        y.hasOwnProperty("current") || m("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(y).join(", ") + "}");
        var T = i();
        return y.current = T, function() {
          y.current = null;
        };
      }
    }
    function Xy(i, a, d) {
      typeof a != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var p = d != null ? d.concat([i]) : null, y = tt;
      return y |= nt, (Nn.mode & Br) !== Ft && (y |= Ct), mh(y, hi, l1.bind(null, a, i), p);
    }
    function Am(i, a, d) {
      typeof a != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var p = d != null ? d.concat([i]) : null;
      return Tm(tt, hi, l1.bind(null, a, i), p);
    }
    function pR(i, a) {
    }
    var Lm = pR;
    function Zy(i, a) {
      var d = ho(), p = a === void 0 ? null : a;
      return d.memoizedState = [i, p], i;
    }
    function Dm(i, a) {
      var d = Ls(), p = a === void 0 ? null : a, y = d.memoizedState;
      if (y !== null && p !== null) {
        var T = y[1];
        if (By(p, T))
          return y[0];
      }
      return d.memoizedState = [i, p], i;
    }
    function Jy(i, a) {
      var d = ho(), p = a === void 0 ? null : a, y = i();
      return d.memoizedState = [y, p], y;
    }
    function Pm(i, a) {
      var d = Ls(), p = a === void 0 ? null : a, y = d.memoizedState;
      if (y !== null && p !== null) {
        var T = y[1];
        if (By(p, T))
          return y[0];
      }
      var L = i();
      return d.memoizedState = [L, p], L;
    }
    function Qy(i) {
      var a = hh(i), d = a[0], p = a[1];
      return vh(function() {
        var y = qr.transition;
        qr.transition = {};
        try {
          p(i);
        } finally {
          qr.transition = y;
        }
      }, [i]), d;
    }
    function u1(i) {
      var a = bm(), d = a[0], p = a[1];
      return Cu(function() {
        var y = qr.transition;
        qr.transition = {};
        try {
          p(i);
        } finally {
          qr.transition = y;
        }
      }, [i]), d;
    }
    function c1(i) {
      var a = wm(), d = a[0], p = a[1];
      return Cu(function() {
        var y = qr.transition;
        qr.transition = {};
        try {
          p(i);
        } finally {
          qr.transition = y;
        }
      }, [i]), d;
    }
    function mR(i, a, d) {
      var p = br();
      fi(Kc(p, nl)), i(!0);
      var y = qr.transition;
      qr.transition = {};
      var T = qr.transition;
      qr.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        i(!1), a();
      } finally {
        if (fi(p), qr.transition = y, y === null && T._updatedFibers) {
          var L = T._updatedFibers.size;
          L > 10 && h("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), T._updatedFibers.clear();
        }
      }
    }
    function Ky() {
      var i = hh(!1), a = i[0], d = i[1], p = mR.bind(null, d), y = ho();
      return y.memoizedState = p, [a, p];
    }
    function f1() {
      var i = bm(), a = i[0], d = Ls(), p = d.memoizedState;
      return [a, p];
    }
    function d1() {
      var i = wm(), a = i[0], d = Ls(), p = d.memoizedState;
      return [a, p];
    }
    var h1 = !1;
    function vR() {
      return h1;
    }
    function $y() {
      var i = ho(), a = dv(), d = a.identifierPrefix, p;
      if (lr()) {
        var y = jC();
        p = ":" + d + "R" + y;
        var T = dh++;
        T > 0 && (p += "H" + T.toString(32)), p += ":";
      } else {
        var L = fR++;
        p = ":" + d + "r" + L.toString(32) + ":";
      }
      return i.memoizedState = p, p;
    }
    function Nm() {
      var i = Ls(), a = i.memoizedState;
      return a;
    }
    function gR(i, a, d) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var p = Sl(i), y = {
        lane: p,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (p1(i))
        m1(a, y);
      else {
        v1(i, a, y);
        var T = Rr(), L = Pi(i, p, T);
        L !== null && g1(L, a, p);
      }
      y1(i, p);
    }
    function yR(i, a, d) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var p = Sl(i), y = {
        lane: p,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (p1(i))
        m1(a, y);
      else {
        v1(i, a, y);
        var T = i.alternate;
        if (i.lanes === Ge && (T === null || T.lanes === Ge)) {
          var L = a.lastRenderedReducer;
          if (L !== null) {
            var O;
            O = vt.current, vt.current = rs;
            try {
              var F = a.lastRenderedState, K = L(F, d);
              if (y.hasEagerState = !0, y.eagerState = K, Er(K, F))
                return;
            } catch {
            } finally {
              vt.current = O;
            }
          }
        }
        var re = Rr(), me = Pi(i, p, re);
        me !== null && g1(me, a, p);
      }
      y1(i, p);
    }
    function p1(i) {
      var a = i.alternate;
      return i === Nn || a !== null && a === Nn;
    }
    function m1(i, a) {
      fh = Sm = !0;
      var d = i.pending;
      d === null ? a.next = a : (a.next = d.next, d.next = a), i.pending = a;
    }
    function v1(i, a, d, p) {
      if (LM(i)) {
        var y = a.interleaved;
        y === null ? (d.next = d, Nt(a)) : (d.next = y.next, y.next = d), a.interleaved = d;
      } else {
        var T = a.pending;
        T === null ? d.next = d : (d.next = T.next, T.next = d), a.pending = d;
      }
    }
    function g1(i, a, d) {
      if (Zc(d)) {
        var p = a.lanes;
        p = Ss(p, i.pendingLanes);
        var y = Wt(p, d);
        a.lanes = y, no(i, y);
      }
    }
    function y1(i, a, d) {
      ll(i, a);
    }
    var zm = {
      readContext: it,
      useCallback: cr,
      useContext: cr,
      useEffect: cr,
      useImperativeHandle: cr,
      useInsertionEffect: cr,
      useLayoutEffect: cr,
      useMemo: cr,
      useReducer: cr,
      useRef: cr,
      useState: cr,
      useDebugValue: cr,
      useDeferredValue: cr,
      useTransition: cr,
      useMutableSource: cr,
      useSyncExternalStore: cr,
      useId: cr,
      unstable_isNewReconciler: E
    }, _1 = null, x1 = null, S1 = null, M1 = null, Ds = null, rs = null, Om = null;
    {
      var e0 = function() {
        m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Ht = function() {
        m("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      _1 = {
        readContext: function(i) {
          return it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", _n(), vf(a), Zy(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", _n(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", _n(), vf(a), vh(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", _n(), vf(d), Xy(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", _n(), vf(a), jy(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", _n(), vf(a), Yy(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", _n(), vf(a);
          var d = vt.current;
          vt.current = Ds;
          try {
            return Jy(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", _n();
          var p = vt.current;
          vt.current = Ds;
          try {
            return ky(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", _n(), qy(i);
        },
        useState: function(i) {
          Ie = "useState", _n();
          var a = vt.current;
          vt.current = Ds;
          try {
            return hh(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", _n(), void 0;
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", _n(), Qy(i);
        },
        useTransition: function() {
          return Ie = "useTransition", _n(), Ky();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", _n(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", _n(), Wy(i, a, d);
        },
        useId: function() {
          return Ie = "useId", _n(), $y();
        },
        unstable_isNewReconciler: E
      }, x1 = {
        readContext: function(i) {
          return it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", st(), Zy(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", st(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", st(), vh(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", st(), Xy(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", st(), jy(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", st(), Yy(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", st();
          var d = vt.current;
          vt.current = Ds;
          try {
            return Jy(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", st();
          var p = vt.current;
          vt.current = Ds;
          try {
            return ky(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", st(), qy(i);
        },
        useState: function(i) {
          Ie = "useState", st();
          var a = vt.current;
          vt.current = Ds;
          try {
            return hh(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", st(), void 0;
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", st(), Qy(i);
        },
        useTransition: function() {
          return Ie = "useTransition", st(), Ky();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", st(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", st(), Wy(i, a, d);
        },
        useId: function() {
          return Ie = "useId", st(), $y();
        },
        unstable_isNewReconciler: E
      }, S1 = {
        readContext: function(i) {
          return it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", st(), Dm(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", st(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", st(), Cu(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", st(), Am(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", st(), Cm(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", st(), Rm(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", st();
          var d = vt.current;
          vt.current = rs;
          try {
            return Pm(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", st();
          var p = vt.current;
          vt.current = rs;
          try {
            return Vy(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", st(), Em();
        },
        useState: function(i) {
          Ie = "useState", st();
          var a = vt.current;
          vt.current = rs;
          try {
            return bm(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", st(), Lm();
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", st(), u1(i);
        },
        useTransition: function() {
          return Ie = "useTransition", st(), f1();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", st(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", st(), Mm(i, a);
        },
        useId: function() {
          return Ie = "useId", st(), Nm();
        },
        unstable_isNewReconciler: E
      }, M1 = {
        readContext: function(i) {
          return it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", st(), Dm(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", st(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", st(), Cu(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", st(), Am(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", st(), Cm(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", st(), Rm(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", st();
          var d = vt.current;
          vt.current = Om;
          try {
            return Pm(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", st();
          var p = vt.current;
          vt.current = Om;
          try {
            return Gy(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", st(), Em();
        },
        useState: function(i) {
          Ie = "useState", st();
          var a = vt.current;
          vt.current = Om;
          try {
            return wm(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", st(), Lm();
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", st(), c1(i);
        },
        useTransition: function() {
          return Ie = "useTransition", st(), d1();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", st(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", st(), Mm(i, a);
        },
        useId: function() {
          return Ie = "useId", st(), Nm();
        },
        unstable_isNewReconciler: E
      }, Ds = {
        readContext: function(i) {
          return e0(), it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", Ht(), _n(), Zy(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", Ht(), _n(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", Ht(), _n(), vh(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", Ht(), _n(), Xy(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", Ht(), _n(), jy(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", Ht(), _n(), Yy(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", Ht(), _n();
          var d = vt.current;
          vt.current = Ds;
          try {
            return Jy(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", Ht(), _n();
          var p = vt.current;
          vt.current = Ds;
          try {
            return ky(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", Ht(), _n(), qy(i);
        },
        useState: function(i) {
          Ie = "useState", Ht(), _n();
          var a = vt.current;
          vt.current = Ds;
          try {
            return hh(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", Ht(), _n(), void 0;
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", Ht(), _n(), Qy(i);
        },
        useTransition: function() {
          return Ie = "useTransition", Ht(), _n(), Ky();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", Ht(), _n(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", Ht(), _n(), Wy(i, a, d);
        },
        useId: function() {
          return Ie = "useId", Ht(), _n(), $y();
        },
        unstable_isNewReconciler: E
      }, rs = {
        readContext: function(i) {
          return e0(), it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", Ht(), st(), Dm(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", Ht(), st(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", Ht(), st(), Cu(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", Ht(), st(), Am(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", Ht(), st(), Cm(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", Ht(), st(), Rm(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", Ht(), st();
          var d = vt.current;
          vt.current = rs;
          try {
            return Pm(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", Ht(), st();
          var p = vt.current;
          vt.current = rs;
          try {
            return Vy(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", Ht(), st(), Em();
        },
        useState: function(i) {
          Ie = "useState", Ht(), st();
          var a = vt.current;
          vt.current = rs;
          try {
            return bm(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", Ht(), st(), Lm();
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", Ht(), st(), u1(i);
        },
        useTransition: function() {
          return Ie = "useTransition", Ht(), st(), f1();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", Ht(), st(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", Ht(), st(), Mm(i, a);
        },
        useId: function() {
          return Ie = "useId", Ht(), st(), Nm();
        },
        unstable_isNewReconciler: E
      }, Om = {
        readContext: function(i) {
          return e0(), it(i);
        },
        useCallback: function(i, a) {
          return Ie = "useCallback", Ht(), st(), Dm(i, a);
        },
        useContext: function(i) {
          return Ie = "useContext", Ht(), st(), it(i);
        },
        useEffect: function(i, a) {
          return Ie = "useEffect", Ht(), st(), Cu(i, a);
        },
        useImperativeHandle: function(i, a, d) {
          return Ie = "useImperativeHandle", Ht(), st(), Am(i, a, d);
        },
        useInsertionEffect: function(i, a) {
          return Ie = "useInsertionEffect", Ht(), st(), Cm(i, a);
        },
        useLayoutEffect: function(i, a) {
          return Ie = "useLayoutEffect", Ht(), st(), Rm(i, a);
        },
        useMemo: function(i, a) {
          Ie = "useMemo", Ht(), st();
          var d = vt.current;
          vt.current = rs;
          try {
            return Pm(i, a);
          } finally {
            vt.current = d;
          }
        },
        useReducer: function(i, a, d) {
          Ie = "useReducer", Ht(), st();
          var p = vt.current;
          vt.current = rs;
          try {
            return Gy(i, a, d);
          } finally {
            vt.current = p;
          }
        },
        useRef: function(i) {
          return Ie = "useRef", Ht(), st(), Em();
        },
        useState: function(i) {
          Ie = "useState", Ht(), st();
          var a = vt.current;
          vt.current = rs;
          try {
            return wm(i);
          } finally {
            vt.current = a;
          }
        },
        useDebugValue: function(i, a) {
          return Ie = "useDebugValue", Ht(), st(), Lm();
        },
        useDeferredValue: function(i) {
          return Ie = "useDeferredValue", Ht(), st(), c1(i);
        },
        useTransition: function() {
          return Ie = "useTransition", Ht(), st(), d1();
        },
        useMutableSource: function(i, a, d) {
          return Ie = "useMutableSource", Ht(), st(), void 0;
        },
        useSyncExternalStore: function(i, a, d) {
          return Ie = "useSyncExternalStore", Ht(), st(), Mm(i, a);
        },
        useId: function() {
          return Ie = "useId", Ht(), st(), Nm();
        },
        unstable_isNewReconciler: E
      };
    }
    var _l = r.unstable_now, b1 = 0, Im = -1, gh = -1, Um = -1, t0 = !1, Fm = !1;
    function w1() {
      return t0;
    }
    function _R() {
      Fm = !0;
    }
    function xR() {
      t0 = !1, Fm = !1;
    }
    function SR() {
      t0 = Fm, Fm = !1;
    }
    function E1() {
      return b1;
    }
    function T1() {
      b1 = _l();
    }
    function n0(i) {
      gh = _l(), i.actualStartTime < 0 && (i.actualStartTime = _l());
    }
    function C1(i) {
      gh = -1;
    }
    function Bm(i, a) {
      if (gh >= 0) {
        var d = _l() - gh;
        i.actualDuration += d, a && (i.selfBaseDuration = d), gh = -1;
      }
    }
    function Oa(i) {
      if (Im >= 0) {
        var a = _l() - Im;
        Im = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case G:
              var p = d.stateNode;
              p.effectDuration += a;
              return;
            case J:
              var y = d.stateNode;
              y.effectDuration += a;
              return;
          }
          d = d.return;
        }
      }
    }
    function i0(i) {
      if (Um >= 0) {
        var a = _l() - Um;
        Um = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case G:
              var p = d.stateNode;
              p !== null && (p.passiveEffectDuration += a);
              return;
            case J:
              var y = d.stateNode;
              y !== null && (y.passiveEffectDuration += a);
              return;
          }
          d = d.return;
        }
      }
    }
    function Ia() {
      Im = _l();
    }
    function r0() {
      Um = _l();
    }
    function a0(i) {
      for (var a = i.child; a; )
        i.actualDuration += a.actualDuration, a = a.sibling;
    }
    function Hm(i, a) {
      return {
        value: i,
        source: a,
        stack: um(a)
      };
    }
    function MR(i, a) {
      return !0;
    }
    function s0(i, a) {
      try {
        var d = MR(i, a);
        if (d === !1)
          return;
        var p = a.value, y = a.source, T = a.stack, L = T !== null ? T : "";
        if (p != null && p._suppressLogging) {
          if (i.tag === z)
            return;
          console.error(p);
        }
        var O = y ? Re(y) : null, F = O ? "The above error occurred in the <" + O + "> component:" : "The above error occurred in one of your React components:", K;
        if (i.tag === G)
          K = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var re = Re(i) || "Anonymous";
          K = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + re + ".");
        }
        var me = F + `
` + L + `

` + ("" + K);
        console.error(me);
      } catch (Ce) {
        setTimeout(function() {
          throw Ce;
        });
      }
    }
    var bR = typeof WeakMap == "function" ? WeakMap : Map;
    function R1(i, a, d) {
      var p = zt(Pn, d);
      p.tag = xe, p.payload = {
        element: null
      };
      var y = a.value;
      return p.callback = function() {
        A3(y), s0(i, a);
      }, p;
    }
    function o0(i, a, d) {
      var p = zt(Pn, d);
      p.tag = xe;
      var y = i.type.getDerivedStateFromError;
      if (typeof y == "function") {
        var T = a.value;
        p.payload = function() {
          return y(T);
        }, p.callback = function() {
          XM(i), s0(i, a);
        };
      }
      var L = i.stateNode;
      return L !== null && typeof L.componentDidCatch == "function" && (p.callback = function() {
        XM(i), s0(i, a), typeof y != "function" && C3(this);
        var F = a.value, K = a.stack;
        this.componentDidCatch(F, {
          componentStack: K !== null ? K : ""
        }), typeof y != "function" && (jn(i.lanes, $t) || m("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Re(i) || "Unknown"));
      }), p;
    }
    function A1(i, a, d) {
      var p = i.pingCache, y;
      if (p === null ? (p = i.pingCache = new bR(), y = /* @__PURE__ */ new Set(), p.set(a, y)) : (y = p.get(a), y === void 0 && (y = /* @__PURE__ */ new Set(), p.set(a, y))), !y.has(d)) {
        y.add(d);
        var T = L3.bind(null, i, a, d);
        rr && Nh(i, d), a.then(T, T);
      }
    }
    function wR(i, a, d, p) {
      var y = i.updateQueue;
      if (y === null) {
        var T = /* @__PURE__ */ new Set();
        T.add(d), i.updateQueue = T;
      } else
        y.add(d);
    }
    function ER(i, a) {
      var d = i.tag;
      if ((i.mode & Mn) === Ft && (d === W || d === V || d === le)) {
        var p = i.alternate;
        p ? (i.updateQueue = p.updateQueue, i.memoizedState = p.memoizedState, i.lanes = p.lanes) : (i.updateQueue = null, i.memoizedState = null);
      }
    }
    function L1(i) {
      var a = i;
      do {
        if (a.tag === Y && uR(a))
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function D1(i, a, d, p, y) {
      if ((i.mode & Mn) === Ft) {
        if (i === a)
          i.flags |= se;
        else {
          if (i.flags |= Bt, d.flags |= Ve, d.flags &= ~(ge | Q), Yl && b) {
            var T = i.alternate;
            if (T === null) {
              var L = i.child, O = L.child;
              if (O !== null) {
                var F = O.memoizedProps.children, K = Sd("hidden", F);
                O.pendingProps = K, O.memoizedProps = K;
              }
            }
          }
          if (d.tag === z) {
            var re = d.alternate;
            if (re === null)
              d.tag = We;
            else {
              var me = zt(Pn, $t);
              me.tag = Wi, Zt(d, me);
            }
          }
          d.lanes = Wt(d.lanes, $t);
        }
        return i;
      }
      return i.flags |= se, i.lanes = y, i;
    }
    function TR(i, a, d, p, y) {
      if (d.flags |= Q, rr && Nh(i, y), p !== null && typeof p == "object" && typeof p.then == "function") {
        var T = p;
        ER(d);
        var L = L1(a);
        if (L !== null) {
          L.flags &= ~Ln, D1(L, a, d, i, y), L.mode & Mn && A1(i, T, y), wR(L, i, T);
          return;
        } else {
          if (!Bd(y)) {
            A1(i, T, y), H0();
            return;
          }
          var O = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          p = O;
        }
      } else if (lr() && d.mode & Mn) {
        QC();
        var F = L1(a);
        if (F !== null) {
          (F.flags & se) === fe && (F.flags |= Ln), D1(F, a, d, i, y), wy(p);
          return;
        }
      }
      _3(p), p = Hm(p, d);
      var K = a;
      do {
        switch (K.tag) {
          case G: {
            var re = p;
            K.flags |= se;
            var me = $o(y);
            K.lanes = Wt(K.lanes, me);
            var Ce = R1(K, re, me);
            un(K, Ce);
            return;
          }
          case z:
            var ze = p, je = K.type, Je = K.stateNode;
            if ((K.flags & Bt) === fe && (typeof je.getDerivedStateFromError == "function" || Je !== null && typeof Je.componentDidCatch == "function" && !BM(Je))) {
              K.flags |= se;
              var Pt = $o(y);
              K.lanes = Wt(K.lanes, Pt);
              var jt = o0(K, ze, Pt);
              un(K, jt);
              return;
            }
            break;
        }
        K = K.return;
      } while (K !== null);
    }
    function CR() {
      return null;
    }
    function Ps(i) {
      i.flags |= tt;
    }
    function P1(i) {
      i.flags |= vr, i.flags |= mt;
    }
    function N1(i, a) {
      var d = i !== null && i.child === a.child;
      if (d)
        return !0;
      if ((a.flags & an) !== fe)
        return !1;
      for (var p = a.child; p !== null; ) {
        if ((p.flags & Dn) !== fe || (p.subtreeFlags & Dn) !== fe)
          return !1;
        p = p.sibling;
      }
      return !0;
    }
    var yh, _h, km, Vm;
    if (Qr)
      yh = function(i, a, d, p) {
        for (var y = a.child; y !== null; ) {
          if (y.tag === oe || y.tag === ne)
            Po(i, y.stateNode);
          else if (y.tag !== $) {
            if (y.child !== null) {
              y.child.return = y, y = y.child;
              continue;
            }
          }
          if (y === a)
            return;
          for (; y.sibling === null; ) {
            if (y.return === null || y.return === a)
              return;
            y = y.return;
          }
          y.sibling.return = y.return, y = y.sibling;
        }
      }, _h = function(i, a) {
      }, km = function(i, a, d, p, y) {
        var T = i.memoizedProps;
        if (T !== p) {
          var L = a.stateNode, O = uh(), F = Nr(L, d, T, p, y, O);
          a.updateQueue = F, F && Ps(a);
        }
      }, Vm = function(i, a, d, p) {
        d !== p && Ps(a);
      };
    else if (Yl) {
      yh = function(i, a, d, p) {
        for (var y = a.child; y !== null; ) {
          if (y.tag === oe) {
            var T = y.stateNode;
            if (d && p) {
              var L = y.memoizedProps, O = y.type;
              T = Md(T, O, L, y);
            }
            Po(i, T);
          } else if (y.tag === ne) {
            var F = y.stateNode;
            if (d && p) {
              var K = y.memoizedProps;
              F = bc(F, K, y);
            }
            Po(i, F);
          } else if (y.tag !== $) {
            if (y.tag === ot && y.memoizedState !== null) {
              var re = y.child;
              re !== null && (re.return = y), yh(i, y, !0, !0);
            } else if (y.child !== null) {
              y.child.return = y, y = y.child;
              continue;
            }
          }
          if (y = y, y === a)
            return;
          for (; y.sibling === null; ) {
            if (y.return === null || y.return === a)
              return;
            y = y.return;
          }
          y.sibling.return = y.return, y = y.sibling;
        }
      };
      var z1 = function(i, a, d, p) {
        for (var y = a.child; y !== null; ) {
          if (y.tag === oe) {
            var T = y.stateNode;
            if (d && p) {
              var L = y.memoizedProps, O = y.type;
              T = Md(T, O, L, y);
            }
            Jl(i, T);
          } else if (y.tag === ne) {
            var F = y.stateNode;
            if (d && p) {
              var K = y.memoizedProps;
              F = bc(F, K, y);
            }
            Jl(i, F);
          } else if (y.tag !== $) {
            if (y.tag === ot && y.memoizedState !== null) {
              var re = y.child;
              re !== null && (re.return = y), z1(i, y, !0, !0);
            } else if (y.child !== null) {
              y.child.return = y, y = y.child;
              continue;
            }
          }
          if (y = y, y === a)
            return;
          for (; y.sibling === null; ) {
            if (y.return === null || y.return === a)
              return;
            y = y.return;
          }
          y.sibling.return = y.return, y = y.sibling;
        }
      };
      _h = function(i, a) {
        var d = a.stateNode, p = N1(i, a);
        if (!p) {
          var y = d.containerInfo, T = Zl(y);
          z1(T, a, !1, !1), d.pendingChildren = T, Ps(a), zo(y, T);
        }
      }, km = function(i, a, d, p, y) {
        var T = i.stateNode, L = i.memoizedProps, O = N1(i, a);
        if (O && L === p) {
          a.stateNode = T;
          return;
        }
        var F = a.stateNode, K = uh(), re = null;
        if (L !== p && (re = Nr(F, d, L, p, y, K)), O && re === null) {
          a.stateNode = T;
          return;
        }
        var me = Kr(T, re, d, L, p, a, O, F);
        hd(me, d, p, y, K) && Ps(a), a.stateNode = me, O ? Ps(a) : yh(me, a, !1, !1);
      }, Vm = function(i, a, d, p) {
        if (d !== p) {
          var y = Ly(), T = uh();
          a.stateNode = Up(p, y, T, a), Ps(a);
        } else
          a.stateNode = i.stateNode;
      };
    } else
      _h = function(i, a) {
      }, km = function(i, a, d, p, y) {
      }, Vm = function(i, a, d, p) {
      };
    function xh(i, a) {
      if (!lr())
        switch (i.tailMode) {
          case "hidden": {
            for (var d = i.tail, p = null; d !== null; )
              d.alternate !== null && (p = d), d = d.sibling;
            p === null ? i.tail = null : p.sibling = null;
            break;
          }
          case "collapsed": {
            for (var y = i.tail, T = null; y !== null; )
              y.alternate !== null && (T = y), y = y.sibling;
            T === null ? !a && i.tail !== null ? i.tail.sibling = null : i.tail = null : T.sibling = null;
            break;
          }
        }
    }
    function Yi(i) {
      var a = i.alternate !== null && i.alternate.child === i.child, d = Ge, p = fe;
      if (a) {
        if ((i.mode & cn) !== Ft) {
          for (var F = i.selfBaseDuration, K = i.child; K !== null; )
            d = Wt(d, Wt(K.lanes, K.childLanes)), p |= K.subtreeFlags & fn, p |= K.flags & fn, F += K.treeBaseDuration, K = K.sibling;
          i.treeBaseDuration = F;
        } else
          for (var re = i.child; re !== null; )
            d = Wt(d, Wt(re.lanes, re.childLanes)), p |= re.subtreeFlags & fn, p |= re.flags & fn, re.return = i, re = re.sibling;
        i.subtreeFlags |= p;
      } else {
        if ((i.mode & cn) !== Ft) {
          for (var y = i.actualDuration, T = i.selfBaseDuration, L = i.child; L !== null; )
            d = Wt(d, Wt(L.lanes, L.childLanes)), p |= L.subtreeFlags, p |= L.flags, y += L.actualDuration, T += L.treeBaseDuration, L = L.sibling;
          i.actualDuration = y, i.treeBaseDuration = T;
        } else
          for (var O = i.child; O !== null; )
            d = Wt(d, Wt(O.lanes, O.childLanes)), p |= O.subtreeFlags, p |= O.flags, O.return = i, O = O.sibling;
        i.subtreeFlags |= p;
      }
      return i.childLanes = d, a;
    }
    function O1(i, a, d) {
      var p = a.pendingProps;
      switch (_y(a), a.tag) {
        case k:
        case Pe:
        case le:
        case W:
        case V:
        case ee:
        case ye:
        case J:
        case Me:
        case de:
          return Yi(a), null;
        case z: {
          var y = a.type;
          return Fr(y) && Wo(a), Yi(a), null;
        }
        case G: {
          var T = a.stateNode;
          if (ff(a), ru(a), Iy(), T.pendingContext && (T.context = T.pendingContext, T.pendingContext = null), i === null || i.child === null) {
            var L = ah(a);
            if (L)
              Ps(a);
            else if (i !== null) {
              var O = i.memoizedState;
              // Check if this is a client root
              (!O.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (a.flags & Ln) !== fe) && (a.flags |= $i, jS());
            }
          }
          return _h(i, a), Yi(a), null;
        }
        case oe: {
          Py(a);
          var F = Ly(), K = a.type;
          if (i !== null && a.stateNode != null)
            km(i, a, K, p, F), i.ref !== a.ref && P1(a);
          else {
            if (!p) {
              if (a.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Yi(a), null;
            }
            var re = uh(), me = ah(a);
            if (me)
              eR(a, F, re) && Ps(a);
            else {
              var Ce = Ip(K, p, F, re, a);
              yh(Ce, a, !1, !1), a.stateNode = Ce, hd(Ce, K, p, F, re) && Ps(a);
            }
            a.ref !== null && P1(a);
          }
          return Yi(a), null;
        }
        case ne: {
          var ze = p;
          if (i && a.stateNode != null) {
            var je = i.memoizedProps;
            Vm(i, a, je, ze);
          } else {
            if (typeof ze != "string" && a.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Je = Ly(), Pt = uh(), jt = ah(a);
            jt ? tR(a) && Ps(a) : a.stateNode = Up(ze, Je, Pt, a);
          }
          return Yi(a), null;
        }
        case Y: {
          hf(a);
          var Ot = a.memoizedState;
          {
            if (rR() && (a.mode & Mn) !== Ft && (a.flags & Bt) === fe)
              return qS(a), uf(), a.flags |= Ln | Q | se, a;
            if (Ot !== null && Ot.dehydrated !== null) {
              var kn = ah(a);
              if (i === null) {
                if (!kn)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (nR(a), Yi(a), (a.mode & cn) !== Ft) {
                  var Vn = Ot !== null;
                  if (Vn) {
                    var Se = a.child;
                    Se !== null && (a.treeBaseDuration -= Se.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (uf(), (a.flags & Bt) === fe && (a.memoizedState = null), a.flags |= tt, Yi(a), (a.mode & cn) !== Ft) {
                  var Oe = Ot !== null;
                  if (Oe) {
                    var _e = a.child;
                    _e !== null && (a.treeBaseDuration -= _e.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            jS();
          }
          if ((a.flags & Bt) !== fe)
            return a.lanes = d, (a.mode & cn) !== Ft && a0(a), a;
          var et = Ot !== null, Dt = !1;
          if (i === null)
            ah(a);
          else {
            var yt = i.memoizedState;
            Dt = yt !== null;
          }
          if (et && !Dt) {
            var rn = a.child;
            if (rn.flags |= Pr, (a.mode & Mn) !== Ft) {
              var bn = i === null && (a.memoizedProps.unstable_avoidThisFallback !== !0 || !A);
              bn || Ny(is.current, $S) ? y3() : H0();
            }
          }
          var In = a.updateQueue;
          if (In !== null && (a.flags |= tt), Yi(a), (a.mode & cn) !== Ft && et) {
            var wn = a.child;
            wn !== null && (a.treeBaseDuration -= wn.treeBaseDuration);
          }
          return null;
        }
        case $:
          return ff(a), _h(i, a), i === null && Xl(a.stateNode.containerInfo), Yi(a), null;
        case De:
          var $n = a.type._context;
          return D($n, a), Yi(a), null;
        case We: {
          var mn = a.type;
          return Fr(mn) && Wo(a), Yi(a), null;
        }
        case ve: {
          hf(a);
          var en = a.memoizedState;
          if (en === null)
            return Yi(a), null;
          var pi = (a.flags & Bt) !== fe, ei = en.rendering;
          if (ei === null)
            if (pi)
              xh(en, !1);
            else {
              var Ba = x3() && (i === null || (i.flags & Bt) === fe);
              if (!Ba)
                for (var Ji = a.child; Ji !== null; ) {
                  var ua = xm(Ji);
                  if (ua !== null) {
                    pi = !0, a.flags |= Bt, xh(en, !1);
                    var ca = ua.updateQueue;
                    return ca !== null && (a.updateQueue = ca, a.flags |= tt), a.subtreeFlags = fe, sR(a, d), vl(a, zy(is.current, ch)), a.child;
                  }
                  Ji = Ji.sibling;
                }
              en.tail !== null && Yn() > AM() && (a.flags |= Bt, pi = !0, xh(en, !1), a.lanes = Jo);
            }
          else {
            if (!pi) {
              var Os = xm(ei);
              if (Os !== null) {
                a.flags |= Bt, pi = !0;
                var Ef = Os.updateQueue;
                if (Ef !== null && (a.updateQueue = Ef, a.flags |= tt), xh(en, !0), en.tail === null && en.tailMode === "hidden" && !ei.alternate && !lr())
                  return Yi(a), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Yn() * 2 - en.renderingStartTime > AM() && d !== Tn && (a.flags |= Bt, pi = !0, xh(en, !1), a.lanes = Jo);
            }
            if (en.isBackwards)
              ei.sibling = a.child, a.child = ei;
            else {
              var Tf = en.last;
              Tf !== null ? Tf.sibling = ei : a.child = ei, en.last = ei;
            }
          }
          if (en.tail !== null) {
            var fa = en.tail;
            en.rendering = fa, en.tail = fa.sibling, en.renderingStartTime = Yn(), fa.sibling = null;
            var zu = is.current;
            return pi ? zu = zy(zu, ch) : zu = df(zu), vl(a, zu), fa;
          }
          return Yi(a), null;
        }
        case gt:
          break;
        case ot:
        case _t: {
          B0(a);
          var r_ = a.memoizedState, Sb = r_ !== null;
          if (i !== null) {
            var y2 = i.memoizedState, _2 = y2 !== null;
            _2 !== Sb && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !R && (a.flags |= Pr);
          }
          return !Sb || (a.mode & Mn) === Ft ? Yi(a) : jn(Ns, Tn) && (Yi(a), Qr && a.subtreeFlags & (Be | tt) && (a.flags |= Pr)), null;
        }
        case Qe:
          return null;
        case At:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var Sh = s.ReactCurrentOwner, as = !1, l0, Mh, u0, c0, f0, Ru, d0, Gm;
    l0 = {}, Mh = {}, u0 = {}, c0 = {}, f0 = {}, Ru = !1, d0 = {}, Gm = {};
    function Cr(i, a, d, p) {
      i === null ? a.child = JS(a, null, d, p) : a.child = cf(a, i.child, d, p);
    }
    function RR(i, a, d, p) {
      a.child = cf(a, i.child, null, p), a.child = cf(a, null, d, p);
    }
    function I1(i, a, d, p, y) {
      if (a.type !== a.elementType) {
        var T = d.propTypes;
        T && Mr(
          T,
          p,
          // Resolved props
          "prop",
          Fe(d)
        );
      }
      var L = d.render, O = a.ref, F, K;
      Ze(a, y), Aa(a);
      {
        if (Sh.current = a, La(!0), F = gf(i, a, L, p, O, y), K = yf(), a.mode & qn) {
          ln(!0);
          try {
            F = gf(i, a, L, p, O, y), K = yf();
          } finally {
            ln(!1);
          }
        }
        La(!1);
      }
      return es(), i !== null && !as ? (e1(i, a, y), po(i, a, y)) : (lr() && K && yy(a), a.flags |= Ae, Cr(i, a, F, y), a.child);
    }
    function U1(i, a, d, p, y) {
      if (i === null) {
        var T = d.type;
        if (Y3(T) && d.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        d.defaultProps === void 0) {
          var L = T;
          return L = wf(T), a.tag = le, a.type = L, m0(a, T), F1(i, a, L, p, y);
        }
        {
          var O = T.propTypes;
          O && Mr(
            O,
            p,
            // Resolved props
            "prop",
            Fe(T)
          );
        }
        var F = J0(d.type, null, p, a, a.mode, y);
        return F.ref = a.ref, F.return = a, a.child = F, F;
      }
      {
        var K = d.type, re = K.propTypes;
        re && Mr(
          re,
          p,
          // Resolved props
          "prop",
          Fe(K)
        );
      }
      var me = i.child, Ce = _0(i, y);
      if (!Ce) {
        var ze = me.memoizedProps, je = d.compare;
        if (je = je !== null ? je : ao, je(ze, p) && i.ref === a.ref)
          return po(i, a, y);
      }
      a.flags |= Ae;
      var Je = Nu(me, p);
      return Je.ref = a.ref, Je.return = a, a.child = Je, Je;
    }
    function F1(i, a, d, p, y) {
      if (a.type !== a.elementType) {
        var T = a.elementType;
        if (T.$$typeof === H) {
          var L = T, O = L._payload, F = L._init;
          try {
            T = F(O);
          } catch {
            T = null;
          }
          var K = T && T.propTypes;
          K && Mr(
            K,
            p,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Fe(T)
          );
        }
      }
      if (i !== null) {
        var re = i.memoizedProps;
        if (ao(re, p) && i.ref === a.ref && // Prevent bailout if the implementation changed due to hot reload.
        a.type === i.type)
          if (as = !1, _0(i, y))
            (i.flags & Ve) !== fe && (as = !0);
          else
            return a.lanes = i.lanes, po(i, a, y);
      }
      return h0(i, a, d, p, y);
    }
    function B1(i, a, d) {
      var p = a.pendingProps, y = p.children, T = i !== null ? i.memoizedState : null;
      if (p.mode === "hidden" || R)
        if ((a.mode & Mn) === Ft) {
          var L = {
            baseLanes: Ge,
            cachePool: null
          };
          a.memoizedState = L, mv(a, d);
        } else if (jn(d, Tn)) {
          var me = {
            baseLanes: Ge,
            cachePool: null
          };
          a.memoizedState = me;
          var Ce = T !== null ? T.baseLanes : d;
          mv(a, Ce);
        } else {
          var O = null, F;
          if (T !== null) {
            var K = T.baseLanes;
            F = Wt(K, d);
          } else
            F = d;
          a.lanes = a.childLanes = Tn;
          var re = {
            baseLanes: F,
            cachePool: O
          };
          return a.memoizedState = re, a.updateQueue = null, mv(a, F), null;
        }
      else {
        var ze;
        T !== null ? (ze = Wt(T.baseLanes, d), a.memoizedState = null) : ze = d, mv(a, ze);
      }
      return Cr(i, a, y, d), a.child;
    }
    function AR(i, a, d) {
      var p = a.pendingProps;
      return Cr(i, a, p, d), a.child;
    }
    function LR(i, a, d) {
      var p = a.pendingProps.children;
      return Cr(i, a, p, d), a.child;
    }
    function DR(i, a, d) {
      {
        a.flags |= tt;
        {
          var p = a.stateNode;
          p.effectDuration = 0, p.passiveEffectDuration = 0;
        }
      }
      var y = a.pendingProps, T = y.children;
      return Cr(i, a, T, d), a.child;
    }
    function H1(i, a) {
      var d = a.ref;
      (i === null && d !== null || i !== null && i.ref !== d) && (a.flags |= vr, a.flags |= mt);
    }
    function h0(i, a, d, p, y) {
      if (a.type !== a.elementType) {
        var T = d.propTypes;
        T && Mr(
          T,
          p,
          // Resolved props
          "prop",
          Fe(d)
        );
      }
      var L;
      {
        var O = ba(a, d, !0);
        L = Go(a, O);
      }
      var F, K;
      Ze(a, y), Aa(a);
      {
        if (Sh.current = a, La(!0), F = gf(i, a, d, p, L, y), K = yf(), a.mode & qn) {
          ln(!0);
          try {
            F = gf(i, a, d, p, L, y), K = yf();
          } finally {
            ln(!1);
          }
        }
        La(!1);
      }
      return es(), i !== null && !as ? (e1(i, a, y), po(i, a, y)) : (lr() && K && yy(a), a.flags |= Ae, Cr(i, a, F, y), a.child);
    }
    function k1(i, a, d, p, y) {
      {
        switch (ib(a)) {
          case !1: {
            var T = a.stateNode, L = a.type, O = new L(a.memoizedProps, T.context), F = O.state;
            T.updater.enqueueSetState(T, F, null);
            break;
          }
          case !0: {
            a.flags |= Bt, a.flags |= se;
            var K = new Error("Simulated error coming from DevTools"), re = $o(y);
            a.lanes = Wt(a.lanes, re);
            var me = o0(a, Hm(K, a), re);
            un(a, me);
            break;
          }
        }
        if (a.type !== a.elementType) {
          var Ce = d.propTypes;
          Ce && Mr(
            Ce,
            p,
            // Resolved props
            "prop",
            Fe(d)
          );
        }
      }
      var ze;
      Fr(d) ? (ze = !0, Ea(a)) : ze = !1, Ze(a, y);
      var je = a.stateNode, Je;
      je === null ? (i !== null && (i.alternate = null, a.alternate = null, a.flags |= Be), US(a, d, p), gy(a, d, p, y), Je = !0) : i === null ? Je = VC(a, d, p, y) : Je = GC(i, a, d, p, y);
      var Pt = p0(i, a, d, Je, ze, y);
      {
        var jt = a.stateNode;
        Je && jt.props !== p && (Ru || m("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Re(a) || "a component"), Ru = !0);
      }
      return Pt;
    }
    function p0(i, a, d, p, y, T) {
      H1(i, a);
      var L = (a.flags & Bt) !== fe;
      if (!p && !L)
        return y && au(a, d, !1), po(i, a, T);
      var O = a.stateNode;
      Sh.current = a;
      var F;
      if (L && typeof d.getDerivedStateFromError != "function")
        F = null, C1();
      else {
        Aa(a);
        {
          if (La(!0), F = O.render(), a.mode & qn) {
            ln(!0);
            try {
              O.render();
            } finally {
              ln(!1);
            }
          }
          La(!1);
        }
        es();
      }
      return a.flags |= Ae, i !== null && L ? RR(i, a, F, T) : Cr(i, a, F, T), a.memoizedState = O.state, y && au(a, d, !0), a.child;
    }
    function V1(i) {
      var a = i.stateNode;
      a.pendingContext ? wa(i, a.pendingContext, a.pendingContext !== a.context) : a.context && wa(i, a.context, !1), Dy(i, a.containerInfo);
    }
    function PR(i, a, d) {
      if (V1(a), i === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var p = a.pendingProps, y = a.memoizedState, T = y.element;
      qt(i, a), sf(a, p, null, d);
      var L = a.memoizedState;
      a.stateNode;
      var O = L.element;
      if (Gi && y.isDehydrated) {
        var F = {
          element: O,
          isDehydrated: !1,
          cache: L.cache,
          transitions: L.transitions
        }, K = a.updateQueue;
        if (K.baseState = F, a.memoizedState = F, a.flags & Ln) {
          var re = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return G1(i, a, O, d, re);
        } else if (O !== T) {
          var me = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return G1(i, a, O, d, me);
        } else {
          KC(a);
          var Ce = JS(a, null, O, d);
          a.child = Ce;
          for (var ze = Ce; ze; )
            ze.flags = ze.flags & ~Be | wi, ze = ze.sibling;
        }
      } else {
        if (uf(), O === T)
          return po(i, a, d);
        Cr(i, a, O, d);
      }
      return a.child;
    }
    function G1(i, a, d, p, y) {
      return uf(), wy(y), a.flags |= Ln, Cr(i, a, d, p), a.child;
    }
    function NR(i, a, d) {
      QS(a), i === null && by(a);
      var p = a.type, y = a.pendingProps, T = i !== null ? i.memoizedProps : null, L = y.children, O = pd(p, y);
      return O ? L = null : T !== null && pd(p, T) && (a.flags |= bi), H1(i, a), Cr(i, a, L, d), a.child;
    }
    function zR(i, a) {
      return i === null && by(a), null;
    }
    function OR(i, a, d, p) {
      i !== null && (i.alternate = null, a.alternate = null, a.flags |= Be);
      var y = a.pendingProps, T = d, L = T._payload, O = T._init, F = O(L);
      a.type = F;
      var K = a.tag = X3(F), re = Wr(F, y), me;
      switch (K) {
        case W:
          return m0(a, F), a.type = F = wf(F), me = h0(null, a, F, re, p), me;
        case z:
          return a.type = F = W0(F), me = k1(null, a, F, re, p), me;
        case V:
          return a.type = F = q0(F), me = I1(null, a, F, re, p), me;
        case de: {
          if (a.type !== a.elementType) {
            var Ce = F.propTypes;
            Ce && Mr(
              Ce,
              re,
              // Resolved for outer only
              "prop",
              Fe(F)
            );
          }
          return me = U1(
            null,
            a,
            F,
            Wr(F.type, re),
            // The inner type can have defaults too
            p
          ), me;
        }
      }
      var ze = "";
      throw F !== null && typeof F == "object" && F.$$typeof === H && (ze = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + F + ". " + ("Lazy element type must resolve to a class or function." + ze));
    }
    function IR(i, a, d, p, y) {
      i !== null && (i.alternate = null, a.alternate = null, a.flags |= Be), a.tag = z;
      var T;
      return Fr(d) ? (T = !0, Ea(a)) : T = !1, Ze(a, y), US(a, d, p), gy(a, d, p, y), p0(null, a, d, !0, T, y);
    }
    function UR(i, a, d, p) {
      i !== null && (i.alternate = null, a.alternate = null, a.flags |= Be);
      var y = a.pendingProps, T;
      {
        var L = ba(a, d, !1);
        T = Go(a, L);
      }
      Ze(a, p);
      var O, F;
      Aa(a);
      {
        if (d.prototype && typeof d.prototype.render == "function") {
          var K = Fe(d) || "Unknown";
          l0[K] || (m("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", K, K), l0[K] = !0);
        }
        a.mode & qn && Gr.recordLegacyContextWarning(a, null), La(!0), Sh.current = a, O = gf(null, a, d, y, T, p), F = yf(), La(!1);
      }
      if (es(), a.flags |= Ae, typeof O == "object" && O !== null && typeof O.render == "function" && O.$$typeof === void 0) {
        var re = Fe(d) || "Unknown";
        Mh[re] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", re, re, re), Mh[re] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof O == "object" && O !== null && typeof O.render == "function" && O.$$typeof === void 0
      ) {
        {
          var me = Fe(d) || "Unknown";
          Mh[me] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", me, me, me), Mh[me] = !0);
        }
        a.tag = z, a.memoizedState = null, a.updateQueue = null;
        var Ce = !1;
        return Fr(d) ? (Ce = !0, Ea(a)) : Ce = !1, a.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null, bt(a), IS(a, O), gy(a, d, y, p), p0(null, a, d, !0, Ce, p);
      } else {
        if (a.tag = W, a.mode & qn) {
          ln(!0);
          try {
            O = gf(null, a, d, y, T, p), F = yf();
          } finally {
            ln(!1);
          }
        }
        return lr() && F && yy(a), Cr(null, a, O, p), m0(a, d), a.child;
      }
    }
    function m0(i, a) {
      {
        if (a && a.childContextTypes && m("%s(...): childContextTypes cannot be defined on a function component.", a.displayName || a.name || "Component"), i.ref !== null) {
          var d = "", p = iy();
          p && (d += `

Check the render method of \`` + p + "`.");
          var y = p || "", T = i._debugSource;
          T && (y = T.fileName + ":" + T.lineNumber), f0[y] || (f0[y] = !0, m("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", d));
        }
        if (typeof a.getDerivedStateFromProps == "function") {
          var L = Fe(a) || "Unknown";
          c0[L] || (m("%s: Function components do not support getDerivedStateFromProps.", L), c0[L] = !0);
        }
        if (typeof a.contextType == "object" && a.contextType !== null) {
          var O = Fe(a) || "Unknown";
          u0[O] || (m("%s: Function components do not support contextType.", O), u0[O] = !0);
        }
      }
    }
    var Wm = {
      dehydrated: null,
      treeContext: null,
      retryLane: ci
    };
    function qm(i) {
      return {
        baseLanes: i,
        cachePool: CR()
      };
    }
    function W1(i, a) {
      var d = null;
      return {
        baseLanes: Wt(i.baseLanes, a),
        cachePool: d
      };
    }
    function FR(i, a, d, p) {
      if (a !== null) {
        var y = a.memoizedState;
        if (y === null)
          return !1;
      }
      return Ny(i, ch);
    }
    function q1(i, a) {
      return $s(i.childLanes, a);
    }
    function j1(i, a, d) {
      var p = a.pendingProps;
      ab(a) && (a.flags |= Bt);
      var y = is.current, T = !1, L = (a.flags & Bt) !== fe;
      if (L || FR(y, i) ? (T = !0, a.flags &= ~Bt) : (i === null || i.memoizedState !== null) && (y = lR(y, $S)), y = df(y), vl(a, y), i === null) {
        by(a);
        {
          var O = a.memoizedState;
          if (O !== null) {
            var F = O.dehydrated;
            if (F !== null)
              return kR(a, F);
          }
        }
        var K = p.children, re = p.fallback;
        if (T) {
          var me = BR(a, K, re, d), Ce = a.child;
          return Ce.memoizedState = qm(d), a.memoizedState = Wm, me;
        } else
          return v0(a, K);
      } else {
        var ze = i.memoizedState;
        if (ze !== null) {
          {
            var je = ze.dehydrated;
            if (je !== null)
              if (L) {
                if (a.flags & Ln)
                  return a.flags &= ~Ln, jm(i, a, d, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (a.memoizedState !== null)
                  return a.child = i.child, a.flags |= Bt, null;
                var Je = p.children, Pt = p.fallback, jt = HR(i, a, Je, Pt, d), Ot = a.child;
                return Ot.memoizedState = qm(d), a.memoizedState = Wm, jt;
              } else
                return VR(i, a, je, ze, d);
          }
          if (T) {
            var kn = p.fallback, Vn = p.children, Se = Z1(i, a, Vn, kn, d), Oe = a.child, _e = i.child.memoizedState;
            return Oe.memoizedState = _e === null ? qm(d) : W1(_e, d), Oe.childLanes = q1(i, d), a.memoizedState = Wm, Se;
          } else {
            var et = p.children, Dt = X1(i, a, et, d);
            return a.memoizedState = null, Dt;
          }
        } else if (T) {
          var yt = p.fallback, rn = p.children, bn = Z1(i, a, rn, yt, d), In = a.child, wn = i.child.memoizedState;
          return In.memoizedState = wn === null ? qm(d) : W1(wn, d), In.childLanes = q1(i, d), a.memoizedState = Wm, bn;
        } else {
          var $n = p.children, mn = X1(i, a, $n, d);
          return a.memoizedState = null, mn;
        }
      }
    }
    function v0(i, a, d) {
      var p = i.mode, y = {
        mode: "visible",
        children: a
      }, T = g0(y, p);
      return T.return = i, i.child = T, T;
    }
    function BR(i, a, d, p) {
      var y = i.mode, T = i.child, L = {
        mode: "hidden",
        children: a
      }, O, F;
      return (y & Mn) === Ft && T !== null ? (O = T, O.childLanes = Ge, O.pendingProps = L, i.mode & cn && (O.actualDuration = 0, O.actualStartTime = -1, O.selfBaseDuration = 0, O.treeBaseDuration = 0), F = bl(d, y, p, null)) : (O = g0(L, y), F = bl(d, y, p, null)), O.return = i, F.return = i, O.sibling = F, i.child = O, F;
    }
    function g0(i, a, d) {
      return JM(i, a, Ge, null);
    }
    function Y1(i, a) {
      return Nu(i, a);
    }
    function X1(i, a, d, p) {
      var y = i.child, T = y.sibling, L = Y1(y, {
        mode: "visible",
        children: d
      });
      if ((a.mode & Mn) === Ft && (L.lanes = p), L.return = a, L.sibling = null, T !== null) {
        var O = a.deletions;
        O === null ? (a.deletions = [T], a.flags |= an) : O.push(T);
      }
      return a.child = L, L;
    }
    function Z1(i, a, d, p, y) {
      var T = a.mode, L = i.child, O = L.sibling, F = {
        mode: "hidden",
        children: d
      }, K;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (T & Mn) === Ft && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        a.child !== L
      ) {
        var re = a.child;
        K = re, K.childLanes = Ge, K.pendingProps = F, a.mode & cn && (K.actualDuration = 0, K.actualStartTime = -1, K.selfBaseDuration = L.selfBaseDuration, K.treeBaseDuration = L.treeBaseDuration), a.deletions = null;
      } else
        K = Y1(L, F), K.subtreeFlags = L.subtreeFlags & fn;
      var me;
      return O !== null ? me = Nu(O, p) : (me = bl(p, T, y, null), me.flags |= Be), me.return = a, K.return = a, K.sibling = me, a.child = K, me;
    }
    function jm(i, a, d, p) {
      p !== null && wy(p), cf(a, i.child, null, d);
      var y = a.pendingProps, T = y.children, L = v0(a, T);
      return L.flags |= Be, a.memoizedState = null, L;
    }
    function HR(i, a, d, p, y) {
      var T = a.mode, L = {
        mode: "visible",
        children: d
      }, O = g0(L, T), F = bl(p, T, y, null);
      return F.flags |= Be, O.return = a, F.return = a, O.sibling = F, a.child = O, (a.mode & Mn) !== Ft && cf(a, i.child, null, y), F;
    }
    function kR(i, a, d) {
      return (i.mode & Mn) === Ft ? (m("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), i.lanes = $t) : Sa(a) ? i.lanes = Qa : i.lanes = Tn, null;
    }
    function VR(i, a, d, p, y) {
      if (JC(), (a.mode & Mn) === Ft)
        return jm(
          i,
          a,
          y,
          // TODO: When we delete legacy mode, we should make this error argument
          // required  every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (Sa(d))
        return jm(
          i,
          a,
          y,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var T = jn(y, i.childLanes);
      if (as || T) {
        var L = dv();
        if (L !== null) {
          var O = kd(L, y);
          if (O !== ci && O !== p.retryLane) {
            p.retryLane = O;
            var F = Pn;
            Pi(i, O, F);
          }
        }
        return H0(), jm(i, a, y, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if ($r(d)) {
        a.flags |= Bt, a.child = i.child;
        var K = D3.bind(null, i);
        return wd(d, K), null;
      } else {
        $C(a, d, p.treeContext);
        var re = a.pendingProps, me = re.children, Ce = v0(a, me);
        return Ce.flags |= wi, Ce;
      }
    }
    function J1(i, a, d) {
      i.lanes = Wt(i.lanes, a);
      var p = i.alternate;
      p !== null && (p.lanes = Wt(p.lanes, a)), Z(i.return, a, d);
    }
    function GR(i, a, d) {
      for (var p = a; p !== null; ) {
        if (p.tag === Y) {
          var y = p.memoizedState;
          y !== null && J1(p, d, i);
        } else if (p.tag === ve)
          J1(p, d, i);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === i)
          return;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === i)
            return;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    function WR(i) {
      for (var a = i, d = null; a !== null; ) {
        var p = a.alternate;
        p !== null && xm(p) === null && (d = a), a = a.sibling;
      }
      return d;
    }
    function qR(i) {
      if (i !== void 0 && i !== "forwards" && i !== "backwards" && i !== "together" && !d0[i])
        if (d0[i] = !0, typeof i == "string")
          switch (i.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', i, i.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', i, i.toLowerCase());
              break;
            }
            default:
              m('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
              break;
          }
        else
          m('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
    }
    function jR(i, a) {
      i !== void 0 && !Gm[i] && (i !== "collapsed" && i !== "hidden" ? (Gm[i] = !0, m('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', i)) : a !== "forwards" && a !== "backwards" && (Gm[i] = !0, m('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', i)));
    }
    function Q1(i, a) {
      {
        var d = yn(i), p = !d && typeof pe(i) == "function";
        if (d || p) {
          var y = d ? "array" : "iterable";
          return m("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", y, a, y), !1;
        }
      }
      return !0;
    }
    function YR(i, a) {
      if ((a === "forwards" || a === "backwards") && i !== void 0 && i !== null && i !== !1)
        if (yn(i)) {
          for (var d = 0; d < i.length; d++)
            if (!Q1(i[d], d))
              return;
        } else {
          var p = pe(i);
          if (typeof p == "function") {
            var y = p.call(i);
            if (y)
              for (var T = y.next(), L = 0; !T.done; T = y.next()) {
                if (!Q1(T.value, L))
                  return;
                L++;
              }
          } else
            m('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', a);
        }
    }
    function y0(i, a, d, p, y) {
      var T = i.memoizedState;
      T === null ? i.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: p,
        tail: d,
        tailMode: y
      } : (T.isBackwards = a, T.rendering = null, T.renderingStartTime = 0, T.last = p, T.tail = d, T.tailMode = y);
    }
    function K1(i, a, d) {
      var p = a.pendingProps, y = p.revealOrder, T = p.tail, L = p.children;
      qR(y), jR(T, y), YR(L, y), Cr(i, a, L, d);
      var O = is.current, F = Ny(O, ch);
      if (F)
        O = zy(O, ch), a.flags |= Bt;
      else {
        var K = i !== null && (i.flags & Bt) !== fe;
        K && GR(a, a.child, d), O = df(O);
      }
      if (vl(a, O), (a.mode & Mn) === Ft)
        a.memoizedState = null;
      else
        switch (y) {
          case "forwards": {
            var re = WR(a.child), me;
            re === null ? (me = a.child, a.child = null) : (me = re.sibling, re.sibling = null), y0(
              a,
              !1,
              // isBackwards
              me,
              re,
              T
            );
            break;
          }
          case "backwards": {
            var Ce = null, ze = a.child;
            for (a.child = null; ze !== null; ) {
              var je = ze.alternate;
              if (je !== null && xm(je) === null) {
                a.child = ze;
                break;
              }
              var Je = ze.sibling;
              ze.sibling = Ce, Ce = ze, ze = Je;
            }
            y0(
              a,
              !0,
              // isBackwards
              Ce,
              null,
              // last
              T
            );
            break;
          }
          case "together": {
            y0(
              a,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            a.memoizedState = null;
        }
      return a.child;
    }
    function XR(i, a, d) {
      Dy(a, a.stateNode.containerInfo);
      var p = a.pendingProps;
      return i === null ? a.child = cf(a, null, p, d) : Cr(i, a, p, d), a.child;
    }
    var $1 = !1;
    function ZR(i, a, d) {
      var p = a.type, y = p._context, T = a.pendingProps, L = a.memoizedProps, O = T.value;
      {
        "value" in T || $1 || ($1 = !0, m("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var F = a.type.propTypes;
        F && Mr(F, T, "prop", "Context.Provider");
      }
      if (C(a, y, O), L !== null) {
        var K = L.value;
        if (Er(K, O)) {
          if (L.children === T.children && !ui())
            return po(i, a, d);
        } else
          ue(a, y, d);
      }
      var re = T.children;
      return Cr(i, a, re, d), a.child;
    }
    var eM = !1;
    function JR(i, a, d) {
      var p = a.type;
      p._context === void 0 ? p !== p.Consumer && (eM || (eM = !0, m("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : p = p._context;
      var y = a.pendingProps, T = y.children;
      typeof T != "function" && m("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Ze(a, d);
      var L = it(p);
      Aa(a);
      var O;
      return Sh.current = a, La(!0), O = T(L), La(!1), es(), a.flags |= Ae, Cr(i, a, O, d), a.child;
    }
    function Ym() {
      as = !0;
    }
    function po(i, a, d) {
      return i !== null && (a.dependencies = i.dependencies), C1(), vv(a.lanes), jn(d, a.childLanes) ? (aR(i, a), a.child) : null;
    }
    function QR(i, a, d) {
      {
        var p = a.return;
        if (p === null)
          throw new Error("Cannot swap the root fiber.");
        if (i.alternate = null, a.alternate = null, d.index = a.index, d.sibling = a.sibling, d.return = a.return, d.ref = a.ref, a === p.child)
          p.child = d;
        else {
          var y = p.child;
          if (y === null)
            throw new Error("Expected parent to have a child.");
          for (; y.sibling !== a; )
            if (y = y.sibling, y === null)
              throw new Error("Expected to find the previous sibling.");
          y.sibling = d;
        }
        var T = p.deletions;
        return T === null ? (p.deletions = [i], p.flags |= an) : T.push(i), d.flags |= Be, d;
      }
    }
    function _0(i, a) {
      var d = i.lanes;
      return !!jn(d, a);
    }
    function KR(i, a, d) {
      switch (a.tag) {
        case G:
          V1(a), a.stateNode, uf();
          break;
        case oe:
          QS(a);
          break;
        case z: {
          var p = a.type;
          Fr(p) && Ea(a);
          break;
        }
        case $:
          Dy(a, a.stateNode.containerInfo);
          break;
        case De: {
          var y = a.memoizedProps.value, T = a.type._context;
          C(a, T, y);
          break;
        }
        case J:
          {
            var L = jn(d, a.childLanes);
            L && (a.flags |= tt);
            {
              var O = a.stateNode;
              O.effectDuration = 0, O.passiveEffectDuration = 0;
            }
          }
          break;
        case Y: {
          var F = a.memoizedState;
          if (F !== null) {
            if (F.dehydrated !== null)
              return vl(a, df(is.current)), a.flags |= Bt, null;
            var K = a.child, re = K.childLanes;
            if (jn(d, re))
              return j1(i, a, d);
            vl(a, df(is.current));
            var me = po(i, a, d);
            return me !== null ? me.sibling : null;
          } else
            vl(a, df(is.current));
          break;
        }
        case ve: {
          var Ce = (i.flags & Bt) !== fe, ze = jn(d, a.childLanes);
          if (Ce) {
            if (ze)
              return K1(i, a, d);
            a.flags |= Bt;
          }
          var je = a.memoizedState;
          if (je !== null && (je.rendering = null, je.tail = null, je.lastEffect = null), vl(a, is.current), ze)
            break;
          return null;
        }
        case ot:
        case _t:
          return a.lanes = Ge, B1(i, a, d);
      }
      return po(i, a, d);
    }
    function tM(i, a, d) {
      if (a._debugNeedsRemount && i !== null)
        return QR(i, a, J0(a.type, a.key, a.pendingProps, a._debugOwner || null, a.mode, a.lanes));
      if (i !== null) {
        var p = i.memoizedProps, y = a.pendingProps;
        if (p !== y || ui() || // Force a re-render if the implementation changed due to hot reload:
        a.type !== i.type)
          as = !0;
        else {
          var T = _0(i, d);
          if (!T && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (a.flags & Bt) === fe)
            return as = !1, KR(i, a, d);
          (i.flags & Ve) !== fe ? as = !0 : as = !1;
        }
      } else if (as = !1, lr() && WC(a)) {
        var L = a.index, O = qC();
        BS(a, O, L);
      }
      switch (a.lanes = Ge, a.tag) {
        case k:
          return UR(i, a, a.type, d);
        case Pe: {
          var F = a.elementType;
          return OR(i, a, F, d);
        }
        case W: {
          var K = a.type, re = a.pendingProps, me = a.elementType === K ? re : Wr(K, re);
          return h0(i, a, K, me, d);
        }
        case z: {
          var Ce = a.type, ze = a.pendingProps, je = a.elementType === Ce ? ze : Wr(Ce, ze);
          return k1(i, a, Ce, je, d);
        }
        case G:
          return PR(i, a, d);
        case oe:
          return NR(i, a, d);
        case ne:
          return zR(i, a);
        case Y:
          return j1(i, a, d);
        case $:
          return XR(i, a, d);
        case V: {
          var Je = a.type, Pt = a.pendingProps, jt = a.elementType === Je ? Pt : Wr(Je, Pt);
          return I1(i, a, Je, jt, d);
        }
        case ee:
          return AR(i, a, d);
        case ye:
          return LR(i, a, d);
        case J:
          return DR(i, a, d);
        case De:
          return ZR(i, a, d);
        case Me:
          return JR(i, a, d);
        case de: {
          var Ot = a.type, kn = a.pendingProps, Vn = Wr(Ot, kn);
          if (a.type !== a.elementType) {
            var Se = Ot.propTypes;
            Se && Mr(
              Se,
              Vn,
              // Resolved for outer only
              "prop",
              Fe(Ot)
            );
          }
          return Vn = Wr(Ot.type, Vn), U1(i, a, Ot, Vn, d);
        }
        case le:
          return F1(i, a, a.type, a.pendingProps, d);
        case We: {
          var Oe = a.type, _e = a.pendingProps, et = a.elementType === Oe ? _e : Wr(Oe, _e);
          return IR(i, a, Oe, et, d);
        }
        case ve:
          return K1(i, a, d);
        case gt:
          break;
        case ot:
          return B1(i, a, d);
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function $R(i, a, d) {
      switch (_y(a), a.tag) {
        case z: {
          var p = a.type;
          Fr(p) && Wo(a);
          var y = a.flags;
          return y & se ? (a.flags = y & ~se | Bt, (a.mode & cn) !== Ft && a0(a), a) : null;
        }
        case G: {
          ff(a), ru(a), Iy();
          var T = a.flags;
          return (T & se) !== fe && (T & Bt) === fe ? (a.flags = T & ~se | Bt, a) : null;
        }
        case oe:
          return Py(a), null;
        case Y: {
          hf(a);
          {
            var L = a.memoizedState;
            if (L !== null && L.dehydrated !== null) {
              if (a.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              uf();
            }
          }
          var O = a.flags;
          return O & se ? (a.flags = O & ~se | Bt, (a.mode & cn) !== Ft && a0(a), a) : null;
        }
        case ve:
          return hf(a), null;
        case $:
          return ff(a), null;
        case De:
          var F = a.type._context;
          return D(F, a), null;
        case ot:
        case _t:
          return B0(a), null;
        case Qe:
          return null;
        default:
          return null;
      }
    }
    function nM(i, a, d) {
      switch (_y(a), a.tag) {
        case z: {
          var p = a.type.childContextTypes;
          p != null && Wo(a);
          break;
        }
        case G: {
          ff(a), ru(a), Iy();
          break;
        }
        case oe: {
          Py(a);
          break;
        }
        case $:
          ff(a);
          break;
        case Y:
          hf(a);
          break;
        case ve:
          hf(a);
          break;
        case De:
          var y = a.type._context;
          D(y, a);
          break;
        case ot:
        case _t:
          B0(a);
          break;
      }
    }
    function iM(i, a, d, p, y, T, L, O, F) {
      var K = Array.prototype.slice.call(arguments, 3);
      try {
        a.apply(d, K);
      } catch (re) {
        this.onError(re);
      }
    }
    var rM = iM;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var x0 = document.createElement("react");
      rM = function(a, d, p, y, T, L, O, F, K) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var re = document.createEvent("Event"), me = !1, Ce = !0, ze = window.event, je = Object.getOwnPropertyDescriptor(window, "event");
        function Je() {
          x0.removeEventListener(Oe, jt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = ze);
        }
        var Pt = Array.prototype.slice.call(arguments, 3);
        function jt() {
          me = !0, Je(), d.apply(p, Pt), Ce = !1;
        }
        var Ot, kn = !1, Vn = !1;
        function Se(_e) {
          if (Ot = _e.error, kn = !0, Ot === null && _e.colno === 0 && _e.lineno === 0 && (Vn = !0), _e.defaultPrevented && Ot != null && typeof Ot == "object")
            try {
              Ot._suppressLogging = !0;
            } catch {
            }
        }
        var Oe = "react-" + (a || "invokeguardedcallback");
        if (window.addEventListener("error", Se), x0.addEventListener(Oe, jt, !1), re.initEvent(Oe, !1, !1), x0.dispatchEvent(re), je && Object.defineProperty(window, "event", je), me && Ce && (kn ? Vn && (Ot = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Ot = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Ot)), window.removeEventListener("error", Se), !me)
          return Je(), iM.apply(this, arguments);
      };
    }
    var eA = rM, bh = !1, Xm = null, tA = {
      onError: function(i) {
        bh = !0, Xm = i;
      }
    };
    function aM(i, a, d, p, y, T, L, O, F) {
      bh = !1, Xm = null, eA.apply(tA, arguments);
    }
    function nA() {
      return bh;
    }
    function sM() {
      if (bh) {
        var i = Xm;
        return bh = !1, Xm = null, i;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var oM = null;
    oM = /* @__PURE__ */ new Set();
    var Zm = !1, xl = !1, iA = typeof WeakSet == "function" ? WeakSet : Set, dt = null, _f = null, xf = null;
    function Xi(i) {
      aM(null, function() {
        throw i;
      }), sM();
    }
    var rA = function(i, a) {
      if (a.props = i.memoizedProps, a.state = i.memoizedState, i.mode & cn)
        try {
          Ia(), a.componentWillUnmount();
        } finally {
          Oa(i);
        }
      else
        a.componentWillUnmount();
    };
    function lM(i, a) {
      try {
        mo(hi, i);
      } catch (d) {
        Xi(d), Zi(i, a, d);
      }
    }
    function S0(i, a, d) {
      try {
        rA(i, d);
      } catch (p) {
        Xi(p), Zi(i, a, p);
      }
    }
    function aA(i, a, d) {
      try {
        d.componentDidMount();
      } catch (p) {
        Xi(p), Zi(i, a, p);
      }
    }
    function uM(i, a) {
      try {
        fM(i);
      } catch (d) {
        Xi(d), Zi(i, a, d);
      }
    }
    function Jm(i, a) {
      var d = i.ref;
      if (d !== null)
        if (typeof d == "function") {
          var p;
          try {
            if (I && B && i.mode & cn)
              try {
                Ia(), p = d(null);
              } finally {
                Oa(i);
              }
            else
              p = d(null);
          } catch (y) {
            Xi(y), Zi(i, a, y);
          }
          typeof p == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Re(i));
        } else
          d.current = null;
    }
    function Qm(i, a, d) {
      try {
        d();
      } catch (p) {
        Xi(p), Zi(i, a, p);
      }
    }
    var cM = !1;
    function sA(i, a) {
      vc(i.containerInfo), dt = a, oA();
      var d = cM;
      return cM = !1, d;
    }
    function oA() {
      for (; dt !== null; ) {
        var i = dt, a = i.child;
        (i.subtreeFlags & Ut) !== fe && a !== null ? (Ua(a, i), dt = a) : lA();
      }
    }
    function lA() {
      for (; dt !== null; ) {
        var i = dt;
        pn(i);
        try {
          uA(i);
        } catch (d) {
          Xi(d), Zi(i, i.return, d);
        }
        Ci();
        var a = i.sibling;
        if (a !== null) {
          Ua(a, i.return), dt = a;
          return;
        }
        dt = i.return;
      }
    }
    function uA(i) {
      var a = i.alternate, d = i.flags;
      if ((d & $i) !== fe) {
        switch (pn(i), i.tag) {
          case W:
          case V:
          case le:
            break;
          case z: {
            if (a !== null) {
              var p = a.memoizedProps, y = a.memoizedState, T = i.stateNode;
              i.type === i.elementType && !Ru && (T.props !== i.memoizedProps && m("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Re(i) || "instance"), T.state !== i.memoizedState && m("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Re(i) || "instance"));
              var L = T.getSnapshotBeforeUpdate(i.elementType === i.type ? p : Wr(i.type, p), y);
              {
                var O = oM;
                L === void 0 && !O.has(i.type) && (O.add(i.type), m("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Re(i)));
              }
              T.__reactInternalSnapshotBeforeUpdate = L;
            }
            break;
          }
          case G: {
            if (Qr) {
              var F = i.stateNode;
              $g(F.containerInfo);
            }
            break;
          }
          case oe:
          case ne:
          case $:
          case We:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ci();
      }
    }
    function jr(i, a, d) {
      var p = a.updateQueue, y = p !== null ? p.lastEffect : null;
      if (y !== null) {
        var T = y.next, L = T;
        do {
          if ((L.tag & i) === i) {
            var O = L.destroy;
            L.destroy = void 0, O !== void 0 && ((i & ji) !== As ? ar(a) : (i & hi) !== As && pu(a), Qm(a, d, O), (i & ji) !== As ? Qd() : (i & hi) !== As && ef());
          }
          L = L.next;
        } while (L !== T);
      }
    }
    function mo(i, a) {
      var d = a.updateQueue, p = d !== null ? d.lastEffect : null;
      if (p !== null) {
        var y = p.next, T = y;
        do {
          if ((T.tag & i) === i) {
            (i & ji) !== As ? Jd(a) : (i & hi) !== As && Kd(a);
            var L = T.create;
            T.destroy = L(), (i & ji) !== As ? hu() : (i & hi) !== As && ol();
            {
              var O = T.destroy;
              if (O !== void 0 && typeof O != "function") {
                var F = void 0;
                (T.tag & hi) !== fe ? F = "useLayoutEffect" : (T.tag & gl) !== fe ? F = "useInsertionEffect" : F = "useEffect";
                var K = void 0;
                O === null ? K = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof O.then == "function" ? K = `

It looks like you wrote ` + F + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + F + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : K = " You returned: " + O, m("%s must not return anything besides a function, which is used for clean-up.%s", F, K);
              }
            }
          }
          T = T.next;
        } while (T !== y);
      }
    }
    function cA(i, a) {
      if ((a.flags & tt) !== fe)
        switch (a.tag) {
          case J: {
            var d = a.stateNode.passiveEffectDuration, p = a.memoizedProps, y = p.id, T = p.onPostCommit, L = E1(), O = a.alternate === null ? "mount" : "update";
            w1() && (O = "nested-update"), typeof T == "function" && T(y, O, d, L);
            var F = a.return;
            e:
              for (; F !== null; ) {
                switch (F.tag) {
                  case G:
                    var K = F.stateNode;
                    K.passiveEffectDuration += d;
                    break e;
                  case J:
                    var re = F.stateNode;
                    re.passiveEffectDuration += d;
                    break e;
                }
                F = F.return;
              }
            break;
          }
        }
    }
    function fA(i, a, d, p) {
      if ((d.flags & oi) !== fe)
        switch (d.tag) {
          case W:
          case V:
          case le: {
            if (!xl)
              if (d.mode & cn)
                try {
                  Ia(), mo(hi | Jn, d);
                } finally {
                  Oa(d);
                }
              else
                mo(hi | Jn, d);
            break;
          }
          case z: {
            var y = d.stateNode;
            if (d.flags & tt && !xl)
              if (a === null)
                if (d.type === d.elementType && !Ru && (y.props !== d.memoizedProps && m("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Re(d) || "instance"), y.state !== d.memoizedState && m("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Re(d) || "instance")), d.mode & cn)
                  try {
                    Ia(), y.componentDidMount();
                  } finally {
                    Oa(d);
                  }
                else
                  y.componentDidMount();
              else {
                var T = d.elementType === d.type ? a.memoizedProps : Wr(d.type, a.memoizedProps), L = a.memoizedState;
                if (d.type === d.elementType && !Ru && (y.props !== d.memoizedProps && m("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Re(d) || "instance"), y.state !== d.memoizedState && m("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Re(d) || "instance")), d.mode & cn)
                  try {
                    Ia(), y.componentDidUpdate(T, L, y.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Oa(d);
                  }
                else
                  y.componentDidUpdate(T, L, y.__reactInternalSnapshotBeforeUpdate);
              }
            var O = d.updateQueue;
            O !== null && (d.type === d.elementType && !Ru && (y.props !== d.memoizedProps && m("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Re(d) || "instance"), y.state !== d.memoizedState && m("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Re(d) || "instance")), DS(d, O, y));
            break;
          }
          case G: {
            var F = d.updateQueue;
            if (F !== null) {
              var K = null;
              if (d.child !== null)
                switch (d.child.tag) {
                  case oe:
                    K = Jr(d.child.stateNode);
                    break;
                  case z:
                    K = d.child.stateNode;
                    break;
                }
              DS(d, F, K);
            }
            break;
          }
          case oe: {
            var re = d.stateNode;
            if (a === null && d.flags & tt) {
              var me = d.type, Ce = d.memoizedProps;
              Zg(re, me, Ce, d);
            }
            break;
          }
          case ne:
            break;
          case $:
            break;
          case J: {
            {
              var ze = d.memoizedProps, je = ze.onCommit, Je = ze.onRender, Pt = d.stateNode.effectDuration, jt = E1(), Ot = a === null ? "mount" : "update";
              w1() && (Ot = "nested-update"), typeof Je == "function" && Je(d.memoizedProps.id, Ot, d.actualDuration, d.treeBaseDuration, d.actualStartTime, jt);
              {
                typeof je == "function" && je(d.memoizedProps.id, Ot, Pt, jt), E3(d);
                var kn = d.return;
                e:
                  for (; kn !== null; ) {
                    switch (kn.tag) {
                      case G:
                        var Vn = kn.stateNode;
                        Vn.effectDuration += Pt;
                        break e;
                      case J:
                        var Se = kn.stateNode;
                        Se.effectDuration += Pt;
                        break e;
                    }
                    kn = kn.return;
                  }
              }
            }
            break;
          }
          case Y: {
            xA(i, d);
            break;
          }
          case ve:
          case We:
          case gt:
          case ot:
          case _t:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      xl || d.flags & vr && fM(d);
    }
    function dA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          if (i.mode & cn)
            try {
              Ia(), lM(i, i.return);
            } finally {
              Oa(i);
            }
          else
            lM(i, i.return);
          break;
        }
        case z: {
          var a = i.stateNode;
          typeof a.componentDidMount == "function" && aA(i, i.return, a), uM(i, i.return);
          break;
        }
        case oe: {
          uM(i, i.return);
          break;
        }
      }
    }
    function hA(i, a) {
      var d = null;
      if (Qr)
        for (var p = i; ; ) {
          if (p.tag === oe) {
            if (d === null) {
              d = p;
              var y = p.stateNode;
              a ? Qg(y) : Kg(p.stateNode, p.memoizedProps);
            }
          } else if (p.tag === ne) {
            if (d === null) {
              var T = p.stateNode;
              a ? xa(T) : Sc(T, p.memoizedProps);
            }
          } else if (!((p.tag === ot || p.tag === _t) && p.memoizedState !== null && p !== i)) {
            if (p.child !== null) {
              p.child.return = p, p = p.child;
              continue;
            }
          }
          if (p === i)
            return;
          for (; p.sibling === null; ) {
            if (p.return === null || p.return === i)
              return;
            d === p && (d = null), p = p.return;
          }
          d === p && (d = null), p.sibling.return = p.return, p = p.sibling;
        }
    }
    function fM(i) {
      var a = i.ref;
      if (a !== null) {
        var d = i.stateNode, p;
        switch (i.tag) {
          case oe:
            p = Jr(d);
            break;
          default:
            p = d;
        }
        if (typeof a == "function") {
          var y;
          if (i.mode & cn)
            try {
              Ia(), y = a(p);
            } finally {
              Oa(i);
            }
          else
            y = a(p);
          typeof y == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Re(i));
        } else
          a.hasOwnProperty("current") || m("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Re(i)), a.current = p;
      }
    }
    function pA(i) {
      var a = i.ref;
      if (a !== null)
        if (typeof a == "function")
          if (i.mode & cn)
            try {
              Ia(), a(null);
            } finally {
              Oa(i);
            }
          else
            a(null);
        else
          a.current = null;
    }
    function dM(i, a, d) {
      switch (ri(a), a.tag) {
        case W:
        case V:
        case de:
        case le: {
          var p = a.updateQueue;
          if (p !== null) {
            var y = p.lastEffect;
            if (y !== null) {
              var T = y.next, L = T;
              do {
                var O = L, F = O.destroy, K = O.tag;
                F !== void 0 && ((K & gl) !== As ? Qm(a, d, F) : (K & hi) !== As && (pu(a), a.mode & cn ? (Ia(), Qm(a, d, F), Oa(a)) : Qm(a, d, F), ef())), L = L.next;
              } while (L !== T);
            }
          }
          return;
        }
        case z: {
          Jm(a, d);
          var re = a.stateNode;
          typeof re.componentWillUnmount == "function" && S0(a, d, re);
          return;
        }
        case oe: {
          Jm(a, d);
          return;
        }
        case $: {
          Qr ? yM(i, a, d) : Yl && vA(a);
          return;
        }
        case $e:
          return;
        case gt:
          return;
      }
    }
    function hM(i, a, d) {
      for (var p = a; ; ) {
        if (dM(i, p, d), p.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!Qr || p.tag !== $)) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === a)
          return;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === a)
            return;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    function mA(i) {
      var a = i.alternate;
      a !== null && (a.return = null), i.return = null;
    }
    function pM(i) {
      var a = i.alternate;
      a !== null && (i.alternate = null, pM(a));
      {
        if (i.child = null, i.deletions = null, i.sibling = null, i.tag === oe) {
          var d = i.stateNode;
          d !== null && vd(d);
        }
        i.stateNode = null, i._debugOwner = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
      }
    }
    function vA(i) {
      if (Yl) {
        var a = i.stateNode, d = a.containerInfo, p = Zl(d);
        Mc(d, p);
      }
    }
    function gA(i) {
      if (Yl) {
        switch (i.tag) {
          case z:
          case oe:
          case ne:
            return;
          case G:
          case $: {
            var a = i.stateNode, d = a.containerInfo, p = a.pendingChildren;
            Mc(d, p);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function yA(i) {
      for (var a = i.return; a !== null; ) {
        if (mM(a))
          return a;
        a = a.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function mM(i) {
      return i.tag === oe || i.tag === G || i.tag === $;
    }
    function vM(i) {
      var a = i;
      e:
        for (; ; ) {
          for (; a.sibling === null; ) {
            if (a.return === null || mM(a.return))
              return null;
            a = a.return;
          }
          for (a.sibling.return = a.return, a = a.sibling; a.tag !== oe && a.tag !== ne && a.tag !== $e; ) {
            if (a.flags & Be || a.child === null || a.tag === $)
              continue e;
            a.child.return = a, a = a.child;
          }
          if (!(a.flags & Be))
            return a.stateNode;
        }
    }
    function gM(i) {
      if (Qr) {
        var a = yA(i);
        switch (a.tag) {
          case oe: {
            var d = a.stateNode;
            a.flags & bi && (xd(d), a.flags &= ~bi);
            var p = vM(i);
            b0(i, p, d);
            break;
          }
          case G:
          case $: {
            var y = a.stateNode.containerInfo, T = vM(i);
            M0(i, T, y);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function M0(i, a, d) {
      var p = i.tag, y = p === oe || p === ne;
      if (y) {
        var T = i.stateNode;
        a ? ja(d, T, a) : _c(d, T);
      } else if (p !== $) {
        var L = i.child;
        if (L !== null) {
          M0(L, a, d);
          for (var O = L.sibling; O !== null; )
            M0(O, a, d), O = O.sibling;
        }
      }
    }
    function b0(i, a, d) {
      var p = i.tag, y = p === oe || p === ne;
      if (y) {
        var T = i.stateNode;
        a ? _a(d, T, a) : Xg(d, T);
      } else if (p !== $) {
        var L = i.child;
        if (L !== null) {
          b0(L, a, d);
          for (var O = L.sibling; O !== null; )
            b0(O, a, d), O = O.sibling;
        }
      }
    }
    function yM(i, a, d) {
      for (var p = a, y = !1, T, L; ; ) {
        if (!y) {
          var O = p.return;
          e:
            for (; ; ) {
              if (O === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var F = O.stateNode;
              switch (O.tag) {
                case oe:
                  T = F, L = !1;
                  break e;
                case G:
                  T = F.containerInfo, L = !0;
                  break e;
                case $:
                  T = F.containerInfo, L = !0;
                  break e;
              }
              O = O.return;
            }
          y = !0;
        }
        if (p.tag === oe || p.tag === ne)
          hM(i, p, d), L ? _d(T, p.stateNode) : xc(T, p.stateNode);
        else if (p.tag === $e)
          L ? qp(T, p.stateNode) : Wp(T, p.stateNode);
        else if (p.tag === $) {
          if (p.child !== null) {
            T = p.stateNode.containerInfo, L = !0, p.child.return = p, p = p.child;
            continue;
          }
        } else if (dM(i, p, d), p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === a)
          return;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === a)
            return;
          p = p.return, p.tag === $ && (y = !1);
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    function _A(i, a, d) {
      Qr ? yM(i, a, d) : hM(i, a, d), mA(a);
    }
    function w0(i, a) {
      if (!Qr) {
        switch (a.tag) {
          case W:
          case V:
          case de:
          case le: {
            if (jr(gl | Jn, a, a.return), mo(gl | Jn, a), a.mode & cn)
              try {
                Ia(), jr(hi | Jn, a, a.return);
              } finally {
                Oa(a);
              }
            else
              jr(hi | Jn, a, a.return);
            return;
          }
          case J:
            return;
          case Y: {
            _M(a), Km(a);
            return;
          }
          case ve: {
            Km(a);
            return;
          }
          case G: {
            if (Gi && i !== null) {
              var d = i.memoizedState;
              if (d.isDehydrated) {
                var p = a.stateNode;
                Tc(p.containerInfo);
              }
            }
            break;
          }
          case ot:
          case _t:
            return;
        }
        gA(a);
        return;
      }
      switch (a.tag) {
        case W:
        case V:
        case de:
        case le: {
          if (jr(gl | Jn, a, a.return), mo(gl | Jn, a), a.mode & cn)
            try {
              Ia(), jr(hi | Jn, a, a.return);
            } finally {
              Oa(a);
            }
          else
            jr(hi | Jn, a, a.return);
          return;
        }
        case z:
          return;
        case oe: {
          var y = a.stateNode;
          if (y != null) {
            var T = a.memoizedProps, L = i !== null ? i.memoizedProps : T, O = a.type, F = a.updateQueue;
            a.updateQueue = null, F !== null && Jg(y, F, O, L, T, a);
          }
          return;
        }
        case ne: {
          if (a.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var K = a.stateNode, re = a.memoizedProps, me = i !== null ? i.memoizedProps : re;
          ya(K, me, re);
          return;
        }
        case G: {
          if (Gi && i !== null) {
            var Ce = i.memoizedState;
            if (Ce.isDehydrated) {
              var ze = a.stateNode;
              Tc(ze.containerInfo);
            }
          }
          return;
        }
        case J:
          return;
        case Y: {
          _M(a), Km(a);
          return;
        }
        case ve: {
          Km(a);
          return;
        }
        case We:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function _M(i) {
      i.memoizedState;
    }
    function xA(i, a) {
      if (Gi) {
        var d = a.memoizedState;
        if (d === null) {
          var p = a.alternate;
          if (p !== null) {
            var y = p.memoizedState;
            if (y !== null) {
              var T = y.dehydrated;
              T !== null && Cc(T);
            }
          }
        }
      }
    }
    function Km(i) {
      var a = i.updateQueue;
      if (a !== null) {
        i.updateQueue = null;
        var d = i.stateNode;
        d === null && (d = i.stateNode = new iA()), a.forEach(function(p) {
          var y = P3.bind(null, i, p);
          if (!d.has(p)) {
            if (d.add(p), rr)
              if (_f !== null && xf !== null)
                Nh(xf, _f);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            p.then(y, y);
          }
        });
      }
    }
    function SA(i) {
      Qr && xd(i.stateNode);
    }
    function MA(i, a, d) {
      _f = d, xf = i, dt = a, bA(i, d), _f = null, xf = null;
    }
    function bA(i, a) {
      for (; dt !== null; ) {
        var d = dt, p = d.deletions;
        if (p !== null)
          for (var y = 0; y < p.length; y++) {
            var T = p[y];
            try {
              _A(i, T, d);
            } catch (O) {
              Xi(O), Zi(T, d, O);
            }
          }
        var L = d.child;
        (d.subtreeFlags & Dn) !== fe && L !== null ? (Ua(L, d), dt = L) : wA(i, a);
      }
    }
    function wA(i, a) {
      for (; dt !== null; ) {
        var d = dt;
        pn(d);
        try {
          EA(d, i, a);
        } catch (y) {
          Xi(y), Zi(d, d.return, y);
        }
        Ci();
        var p = d.sibling;
        if (p !== null) {
          Ua(p, d.return), dt = p;
          return;
        }
        dt = d.return;
      }
    }
    function EA(i, a, d) {
      var p = i.flags;
      if (p & bi && SA(i), p & vr) {
        var y = i.alternate;
        y !== null && pA(y);
      }
      if (p & Pr)
        switch (i.tag) {
          case Y: {
            var T = i.memoizedState, L = T !== null;
            if (L) {
              var O = i.alternate, F = O !== null && O.memoizedState !== null;
              F || g3();
            }
            break;
          }
          case ot: {
            var K = i.memoizedState, re = K !== null, me = i.alternate, Ce = me !== null && me.memoizedState !== null, ze = i;
            Qr && hA(ze, re);
            {
              if (re && !Ce && (ze.mode & Mn) !== Ft) {
                dt = ze;
                for (var je = ze.child; je !== null; )
                  dt = je, CA(je), je = je.sibling;
              }
              break;
            }
          }
        }
      var Je = p & (Be | tt | wi);
      switch (Je) {
        case Be: {
          gM(i), i.flags &= ~Be;
          break;
        }
        case hn: {
          gM(i), i.flags &= ~Be;
          var Pt = i.alternate;
          w0(Pt, i);
          break;
        }
        case wi: {
          i.flags &= ~wi;
          break;
        }
        case Do: {
          i.flags &= ~wi;
          var jt = i.alternate;
          w0(jt, i);
          break;
        }
        case tt: {
          var Ot = i.alternate;
          w0(Ot, i);
          break;
        }
      }
    }
    function TA(i, a, d) {
      _f = d, xf = a, dt = i, xM(i, a, d), _f = null, xf = null;
    }
    function xM(i, a, d) {
      for (var p = (i.mode & Mn) !== Ft; dt !== null; ) {
        var y = dt, T = y.child;
        if (y.tag === ot && p) {
          var L = y.memoizedState !== null, O = L || Zm;
          if (O) {
            E0(i, a, d);
            continue;
          } else {
            var F = y.alternate, K = F !== null && F.memoizedState !== null, re = K || xl, me = Zm, Ce = xl;
            Zm = O, xl = re, xl && !Ce && (dt = y, RA(y));
            for (var ze = T; ze !== null; )
              dt = ze, xM(
                ze,
                // New root; bubble back up to here and stop.
                a,
                d
              ), ze = ze.sibling;
            dt = y, Zm = me, xl = Ce, E0(i, a, d);
            continue;
          }
        }
        (y.subtreeFlags & oi) !== fe && T !== null ? (Ua(T, y), dt = T) : E0(i, a, d);
      }
    }
    function E0(i, a, d) {
      for (; dt !== null; ) {
        var p = dt;
        if ((p.flags & oi) !== fe) {
          var y = p.alternate;
          pn(p);
          try {
            fA(a, y, p, d);
          } catch (L) {
            Xi(L), Zi(p, p.return, L);
          }
          Ci();
        }
        if (p === i) {
          dt = null;
          return;
        }
        var T = p.sibling;
        if (T !== null) {
          Ua(T, p.return), dt = T;
          return;
        }
        dt = p.return;
      }
    }
    function CA(i) {
      for (; dt !== null; ) {
        var a = dt, d = a.child;
        switch (a.tag) {
          case W:
          case V:
          case de:
          case le: {
            if (a.mode & cn)
              try {
                Ia(), jr(hi, a, a.return);
              } finally {
                Oa(a);
              }
            else
              jr(hi, a, a.return);
            break;
          }
          case z: {
            Jm(a, a.return);
            var p = a.stateNode;
            typeof p.componentWillUnmount == "function" && S0(a, a.return, p);
            break;
          }
          case oe: {
            Jm(a, a.return);
            break;
          }
          case ot: {
            var y = a.memoizedState !== null;
            if (y) {
              SM(i);
              continue;
            }
            break;
          }
        }
        d !== null ? (d.return = a, dt = d) : SM(i);
      }
    }
    function SM(i) {
      for (; dt !== null; ) {
        var a = dt;
        if (a === i) {
          dt = null;
          return;
        }
        var d = a.sibling;
        if (d !== null) {
          d.return = a.return, dt = d;
          return;
        }
        dt = a.return;
      }
    }
    function RA(i) {
      for (; dt !== null; ) {
        var a = dt, d = a.child;
        if (a.tag === ot) {
          var p = a.memoizedState !== null;
          if (p) {
            MM(i);
            continue;
          }
        }
        d !== null ? (d.return = a, dt = d) : MM(i);
      }
    }
    function MM(i) {
      for (; dt !== null; ) {
        var a = dt;
        pn(a);
        try {
          dA(a);
        } catch (p) {
          Xi(p), Zi(a, a.return, p);
        }
        if (Ci(), a === i) {
          dt = null;
          return;
        }
        var d = a.sibling;
        if (d !== null) {
          d.return = a.return, dt = d;
          return;
        }
        dt = a.return;
      }
    }
    function AA(i, a) {
      dt = a, LA(a, i);
    }
    function LA(i, a) {
      for (; dt !== null; ) {
        var d = dt, p = d.child;
        (d.subtreeFlags & Ui) !== fe && p !== null ? (Ua(p, d), dt = p) : DA(i, a);
      }
    }
    function DA(i, a) {
      for (; dt !== null; ) {
        var d = dt;
        if ((d.flags & Ii) !== fe) {
          pn(d);
          try {
            PA(a, d);
          } catch (y) {
            Xi(y), Zi(d, d.return, y);
          }
          Ci();
        }
        if (d === i) {
          dt = null;
          return;
        }
        var p = d.sibling;
        if (p !== null) {
          Ua(p, d.return), dt = p;
          return;
        }
        dt = d.return;
      }
    }
    function PA(i, a) {
      switch (a.tag) {
        case W:
        case V:
        case le: {
          if (a.mode & cn) {
            r0();
            try {
              mo(ji | Jn, a);
            } finally {
              i0(a);
            }
          } else
            mo(ji | Jn, a);
          break;
        }
      }
    }
    function NA(i) {
      dt = i, zA();
    }
    function zA() {
      for (; dt !== null; ) {
        var i = dt, a = i.child;
        if ((dt.flags & an) !== fe) {
          var d = i.deletions;
          if (d !== null) {
            for (var p = 0; p < d.length; p++) {
              var y = d[p];
              dt = y, UA(y, i);
            }
            {
              var T = i.alternate;
              if (T !== null) {
                var L = T.child;
                if (L !== null) {
                  T.child = null;
                  do {
                    var O = L.sibling;
                    L.sibling = null, L = O;
                  } while (L !== null);
                }
              }
            }
            dt = i;
          }
        }
        (i.subtreeFlags & Ui) !== fe && a !== null ? (Ua(a, i), dt = a) : OA();
      }
    }
    function OA() {
      for (; dt !== null; ) {
        var i = dt;
        (i.flags & Ii) !== fe && (pn(i), IA(i), Ci());
        var a = i.sibling;
        if (a !== null) {
          Ua(a, i.return), dt = a;
          return;
        }
        dt = i.return;
      }
    }
    function IA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          i.mode & cn ? (r0(), jr(ji | Jn, i, i.return), i0(i)) : jr(ji | Jn, i, i.return);
          break;
        }
      }
    }
    function UA(i, a) {
      for (; dt !== null; ) {
        var d = dt;
        pn(d), BA(d, a), Ci();
        var p = d.child;
        p !== null ? (Ua(p, d), dt = p) : FA(i);
      }
    }
    function FA(i) {
      for (; dt !== null; ) {
        var a = dt, d = a.sibling, p = a.return;
        if (pM(a), a === i) {
          dt = null;
          return;
        }
        if (d !== null) {
          Ua(d, p), dt = d;
          return;
        }
        dt = p;
      }
    }
    function BA(i, a) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          i.mode & cn ? (r0(), jr(ji, i, a), i0(i)) : jr(ji, i, a);
          break;
        }
      }
    }
    var bM = !1;
    function Ua(i, a) {
      !bM && i.return !== a && (bM = !0, m("Internal React error: Return pointer is inconsistent with parent.")), i.return = a;
    }
    function HA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          try {
            mo(hi | Jn, i);
          } catch (d) {
            Xi(d), Zi(i, i.return, d);
          }
          break;
        }
        case z: {
          var a = i.stateNode;
          try {
            a.componentDidMount();
          } catch (d) {
            Xi(d), Zi(i, i.return, d);
          }
          break;
        }
      }
    }
    function kA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          try {
            mo(ji | Jn, i);
          } catch (a) {
            Xi(a), Zi(i, i.return, a);
          }
          break;
        }
      }
    }
    function VA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le: {
          try {
            jr(hi | Jn, i, i.return);
          } catch (d) {
            Xi(d), Zi(i, i.return, d);
          }
          break;
        }
        case z: {
          var a = i.stateNode;
          typeof a.componentWillUnmount == "function" && S0(i, i.return, a);
          break;
        }
      }
    }
    function GA(i) {
      switch (i.tag) {
        case W:
        case V:
        case le:
          try {
            jr(ji | Jn, i, i.return);
          } catch (a) {
            Xi(a), Zi(i, i.return, a);
          }
      }
    }
    var $m = 0, ev = 1, tv = 2, nv = 3, iv = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var wh = Symbol.for;
      $m = wh("selector.component"), ev = wh("selector.has_pseudo_class"), tv = wh("selector.role"), nv = wh("selector.test_id"), iv = wh("selector.text");
    }
    function WA(i) {
      return {
        $$typeof: $m,
        value: i
      };
    }
    function qA(i) {
      return {
        $$typeof: ev,
        value: i
      };
    }
    function jA(i) {
      return {
        $$typeof: tv,
        value: i
      };
    }
    function YA(i) {
      return {
        $$typeof: iv,
        value: i
      };
    }
    function XA(i) {
      return {
        $$typeof: nv,
        value: i
      };
    }
    function T0(i) {
      var a = md(i);
      if (a != null) {
        if (typeof a.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return a;
      } else {
        var d = Hp(i);
        if (d === null)
          throw new Error("Could not find React container within specified host subtree.");
        return d.stateNode.current;
      }
    }
    function C0(i, a) {
      switch (a.$$typeof) {
        case $m:
          if (i.type === a.value)
            return !0;
          break;
        case ev:
          return ZA(i, a.value);
        case tv:
          if (i.tag === oe) {
            var d = i.stateNode;
            if (gd(d, a.value))
              return !0;
          }
          break;
        case iv:
          if (i.tag === oe || i.tag === ne) {
            var p = jg(i);
            if (p !== null && p.indexOf(a.value) >= 0)
              return !0;
          }
          break;
        case nv:
          if (i.tag === oe) {
            var y = i.memoizedProps["data-testname"];
            if (typeof y == "string" && y.toLowerCase() === a.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function R0(i) {
      switch (i.$$typeof) {
        case $m:
          var a = Fe(i.value) || "Unknown";
          return "<" + a + ">";
        case ev:
          return ":has(" + (R0(i) || "") + ")";
        case tv:
          return '[role="' + i.value + '"]';
        case iv:
          return '"' + i.value + '"';
        case nv:
          return '[data-testname="' + i.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function wM(i, a) {
      for (var d = [], p = [i, 0], y = 0; y < p.length; ) {
        var T = p[y++], L = p[y++], O = a[L];
        if (!(T.tag === oe && Gn(T))) {
          for (; O != null && C0(T, O); )
            L++, O = a[L];
          if (L === a.length)
            d.push(T);
          else
            for (var F = T.child; F !== null; )
              p.push(F, L), F = F.sibling;
        }
      }
      return d;
    }
    function ZA(i, a) {
      for (var d = [i, 0], p = 0; p < d.length; ) {
        var y = d[p++], T = d[p++], L = a[T];
        if (!(y.tag === oe && Gn(y))) {
          for (; L != null && C0(y, L); )
            T++, L = a[T];
          if (T === a.length)
            return !0;
          for (var O = y.child; O !== null; )
            d.push(O, T), O = O.sibling;
        }
      }
      return !1;
    }
    function rv(i, a) {
      if (!vs)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var d = T0(i), p = wM(d, a), y = [], T = Array.from(p), L = 0; L < T.length; ) {
        var O = T[L++];
        if (O.tag === oe) {
          if (Gn(O))
            continue;
          y.push(O.stateNode);
        } else
          for (var F = O.child; F !== null; )
            T.push(F), F = F.sibling;
      }
      return y;
    }
    function JA(i, a) {
      if (!vs)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var d = T0(i), p = 0, y = [], T = [d, 0], L = 0; L < T.length; ) {
        var O = T[L++], F = T[L++], K = a[F];
        if (!(O.tag === oe && Gn(O)) && (C0(O, K) && (y.push(R0(K)), F++, F > p && (p = F)), F < a.length))
          for (var re = O.child; re !== null; )
            T.push(re, F), re = re.sibling;
      }
      if (p < a.length) {
        for (var me = [], Ce = p; Ce < a.length; Ce++)
          me.push(R0(a[Ce]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + y.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + me.join(" > "));
      }
      return null;
    }
    function QA(i, a) {
      if (!vs)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var d = rv(i, a), p = [], y = 0; y < d.length; y++)
        p.push(qg(d[y]));
      for (var T = p.length - 1; T > 0; T--)
        for (var L = p[T], O = L.x, F = O + L.width, K = L.y, re = K + L.height, me = T - 1; me >= 0; me--)
          if (T !== me) {
            var Ce = p[me], ze = Ce.x, je = ze + Ce.width, Je = Ce.y, Pt = Je + Ce.height;
            if (O >= ze && K >= Je && F <= je && re <= Pt) {
              p.splice(T, 1);
              break;
            } else if (O === ze && L.width === Ce.width && !(Pt < K) && !(Je > re)) {
              Je > K && (Ce.height += Je - K, Ce.y = K), Pt < re && (Ce.height = re - Je), p.splice(T, 1);
              break;
            } else if (K === Je && L.height === Ce.height && !(je < O) && !(ze > F)) {
              ze > O && (Ce.width += ze - O, Ce.x = O), je < F && (Ce.width = F - ze), p.splice(T, 1);
              break;
            }
          }
      return p;
    }
    function KA(i, a) {
      if (!vs)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var d = T0(i), p = wM(d, a), y = Array.from(p), T = 0; T < y.length; ) {
        var L = y[T++];
        if (!Gn(L)) {
          if (L.tag === oe) {
            var O = L.stateNode;
            if (Yg(O))
              return !0;
          }
          for (var F = L.child; F !== null; )
            y.push(F), F = F.sibling;
        }
      }
      return !1;
    }
    var av = [];
    function $A() {
      vs && av.forEach(function(i) {
        return i();
      });
    }
    function e3(i, a, d, p) {
      if (!vs)
        throw new Error("Test selector API is not supported by this renderer.");
      var y = rv(i, a), T = yd(y, d, p), L = T.disconnect, O = T.observe, F = T.unobserve, K = function() {
        var re = rv(i, a);
        y.forEach(function(me) {
          re.indexOf(me) < 0 && F(me);
        }), re.forEach(function(me) {
          y.indexOf(me) < 0 && O(me);
        });
      };
      return av.push(K), {
        disconnect: function() {
          var re = av.indexOf(K);
          re >= 0 && av.splice(re, 1), L();
        }
      };
    }
    var t3 = s.ReactCurrentActQueue;
    function n3(i) {
      {
        var a = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), d = typeof jest < "u";
        return yc && d && a !== !1;
      }
    }
    function EM() {
      {
        var i = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !i && t3.current !== null && m("The current testing environment is not configured to support act(...)"), i;
      }
    }
    var i3 = Math.ceil, A0 = s.ReactCurrentDispatcher, L0 = s.ReactCurrentOwner, Qn = s.ReactCurrentBatchConfig, ss = s.ReactCurrentActQueue, _i = (
      /*             */
      0
    ), D0 = (
      /*               */
      1
    ), fr = (
      /*                */
      2
    ), os = (
      /*                */
      4
    ), vo = 0, Eh = 1, Au = 2, sv = 3, Th = 4, TM = 5, P0 = 6, Jt = _i, dr = null, Kn = null, Li = Ge, Ns = Ge, N0 = Ma(Ge), Di = vo, Ch = null, ov = Ge, Rh = Ge, lv = Ge, Ah = null, Yr = null, z0 = 0, CM = 500, RM = 1 / 0, r3 = 500;
    function Sf() {
      RM = Yn() + r3;
    }
    function AM() {
      return RM;
    }
    var uv = !1, O0 = null, Mf = null, Lu = !1, go = null, Lh = Ge, I0 = [], a3 = 50, Dh = 0, U0 = null, s3 = 50, cv = 0, Ph = Pn, fv = Ge;
    function dv() {
      return dr;
    }
    function Rr() {
      return (Jt & (fr | os)) !== _i ? Yn() : (Ph !== Pn || (Ph = Yn()), Ph);
    }
    function Sl(i) {
      var a = i.mode;
      if ((a & Mn) === Ft)
        return $t;
      if ((Jt & fr) !== _i && Li !== Ge)
        return $o(Li);
      var d = nh() !== lm;
      if (d) {
        if (Qn.transition !== null) {
          var p = Qn.transition;
          p._updatedFibers || (p._updatedFibers = /* @__PURE__ */ new Set()), p._updatedFibers.add(i);
        }
        return fv === ci && (fv = $p()), fv;
      }
      var y = br();
      if (y !== ci)
        return y;
      var T = Wg();
      return T;
    }
    function o3(i) {
      var a = i.mode;
      return (a & Mn) === Ft ? $t : em();
    }
    function Pi(i, a, d) {
      z3();
      var p = hv(i, a);
      return p === null ? null : (eo(p, a, d), (Jt & fr) !== Ge && p === dr ? U3(i) : (rr && Vd(p, i, a), F3(i), p === dr && ((Jt & fr) === _i && (Rh = Wt(Rh, a)), Di === Th && Ml(p, Li)), Xr(p, d), a === $t && Jt === _i && (i.mode & Mn) === Ft && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ss.isBatchingLegacy && (Sf(), th())), p);
    }
    function l3(i, a, d) {
      var p = i.current;
      p.lanes = a, eo(i, a, d), Xr(i, d);
    }
    function hv(i, a) {
      i.lanes = Wt(i.lanes, a);
      var d = i.alternate;
      d !== null && (d.lanes = Wt(d.lanes, a)), d === null && (i.flags & (Be | wi)) !== fe && GM(i);
      for (var p = i, y = i.return; y !== null; )
        y.childLanes = Wt(y.childLanes, a), d = y.alternate, d !== null ? d.childLanes = Wt(d.childLanes, a) : (y.flags & (Be | wi)) !== fe && GM(i), p = y, y = y.return;
      if (p.tag === G) {
        var T = p.stateNode;
        return T;
      } else
        return null;
    }
    function LM(i, a) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        dr !== null && (i.mode & Mn) !== Ft && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (Jt & fr) === _i
      );
    }
    function Xr(i, a) {
      var d = i.callbackNode;
      Qp(i, a);
      var p = fu(i, i === dr ? Li : Ge);
      if (p === Ge) {
        d !== null && qM(d), i.callbackNode = null, i.callbackPriority = ci;
        return;
      }
      var y = Ca(p), T = i.callbackPriority;
      if (T === y && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ss.current !== null && d !== G0)) {
        d == null && T !== $t && m("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      d != null && qM(d);
      var L;
      if (y === $t)
        i.tag === Xs ? (ss.isBatchingLegacy !== null && (ss.didScheduleLegacyUpdate = !0), sm(NM.bind(null, i))) : ts(NM.bind(null, i)), dn ? ss.current !== null ? ss.current.push(Vr) : Bp(function() {
          Jt === _i && Vr();
        }) : xv(ro, Vr), L = null;
      else {
        var O;
        switch (qd(p)) {
          case aa:
            O = ro;
            break;
          case nl:
            O = du;
            break;
          case il:
            O = $a;
            break;
          case Qc:
            O = rl;
            break;
          default:
            O = $a;
            break;
        }
        L = xv(O, DM.bind(null, i));
      }
      i.callbackPriority = y, i.callbackNode = L;
    }
    function DM(i, a) {
      if (xR(), Ph = Pn, fv = Ge, (Jt & (fr | os)) !== _i)
        throw new Error("Should not already be working.");
      var d = i.callbackNode, p = zs();
      if (p && i.callbackNode !== d)
        return null;
      var y = fu(i, i === dr ? Li : Ge);
      if (y === Ge)
        return null;
      var T = !Ks(i, y) && !Kp(i, y) && !a, L = T ? M3(i, y) : gv(i, y);
      if (L !== vo) {
        if (L === Au) {
          var O = jc(i);
          O !== Ge && (y = O, L = F0(i, O));
        }
        if (L === Eh) {
          var F = Ch;
          throw Du(i, Ge), Ml(i, y), Xr(i, Yn()), F;
        }
        if (L === P0)
          Ml(i, y);
        else {
          var K = !Ks(i, y), re = i.current.alternate;
          if (K && !c3(re)) {
            if (L = gv(i, y), L === Au) {
              var me = jc(i);
              me !== Ge && (y = me, L = F0(i, me));
            }
            if (L === Eh) {
              var Ce = Ch;
              throw Du(i, Ge), Ml(i, y), Xr(i, Yn()), Ce;
            }
          }
          i.finishedWork = re, i.finishedLanes = y, u3(i, L, y);
        }
      }
      return Xr(i, Yn()), i.callbackNode === d ? DM.bind(null, i) : null;
    }
    function F0(i, a) {
      var d = Ah;
      if (Ts(i)) {
        var p = Du(i, a);
        p.flags |= Ln, Sr(i.containerInfo);
      }
      var y = gv(i, a);
      if (y !== Au) {
        var T = Yr;
        Yr = d, T !== null && PM(T);
      }
      return y;
    }
    function PM(i) {
      Yr === null ? Yr = i : Yr.push.apply(Yr, i);
    }
    function u3(i, a, d) {
      switch (a) {
        case vo:
        case Eh:
          throw new Error("Root did not complete. This is a bug in React.");
        case Au: {
          Pu(i, Yr);
          break;
        }
        case sv: {
          if (Ml(i, d), Hd(d) && // do not delay if we're inside an act() scope
          !jM()) {
            var p = z0 + CM - Yn();
            if (p > 10) {
              var y = fu(i, Ge);
              if (y !== Ge)
                break;
              var T = i.suspendedLanes;
              if (!el(T, d)) {
                Rr(), nm(i, T);
                break;
              }
              i.timeoutHandle = Fp(Pu.bind(null, i, Yr), p);
              break;
            }
          }
          Pu(i, Yr);
          break;
        }
        case Th: {
          if (Ml(i, d), Xc(d))
            break;
          if (!jM()) {
            var L = Zp(i, d), O = L, F = Yn() - O, K = N3(F) - F;
            if (K > 10) {
              i.timeoutHandle = Fp(Pu.bind(null, i, Yr), K);
              break;
            }
          }
          Pu(i, Yr);
          break;
        }
        case TM: {
          Pu(i, Yr);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function c3(i) {
      for (var a = i; ; ) {
        if (a.flags & j) {
          var d = a.updateQueue;
          if (d !== null) {
            var p = d.stores;
            if (p !== null)
              for (var y = 0; y < p.length; y++) {
                var T = p[y], L = T.getSnapshot, O = T.value;
                try {
                  if (!Er(L(), O))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var F = a.child;
        if (a.subtreeFlags & j && F !== null) {
          F.return = a, a = F;
          continue;
        }
        if (a === i)
          return !0;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === i)
            return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !0;
    }
    function Ml(i, a) {
      a = $s(a, lv), a = $s(a, Rh), tm(i, a);
    }
    function NM(i) {
      if (SR(), (Jt & (fr | os)) !== _i)
        throw new Error("Should not already be working.");
      zs();
      var a = fu(i, Ge);
      if (!jn(a, $t))
        return Xr(i, Yn()), null;
      var d = gv(i, a);
      if (i.tag !== Xs && d === Au) {
        var p = jc(i);
        p !== Ge && (a = p, d = F0(i, p));
      }
      if (d === Eh) {
        var y = Ch;
        throw Du(i, Ge), Ml(i, a), Xr(i, Yn()), y;
      }
      if (d === P0)
        throw new Error("Root did not complete. This is a bug in React.");
      var T = i.current.alternate;
      return i.finishedWork = T, i.finishedLanes = a, Pu(i, Yr), Xr(i, Yn()), null;
    }
    function f3(i, a) {
      a !== Ge && (no(i, Wt(a, $t)), Xr(i, Yn()), (Jt & (fr | os)) === _i && (Sf(), Vr()));
    }
    function d3(i) {
      var a = br(), d = Qn.transition;
      try {
        return Qn.transition = null, fi(il), i();
      } finally {
        fi(a), Qn.transition = d;
      }
    }
    function h3(i, a) {
      var d = Jt;
      Jt |= D0;
      try {
        return i(a);
      } finally {
        Jt = d, Jt === _i && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ss.isBatchingLegacy && (Sf(), th());
      }
    }
    function p3(i, a, d, p, y) {
      var T = br(), L = Qn.transition;
      try {
        return Qn.transition = null, fi(aa), i(a, d, p, y);
      } finally {
        fi(T), Qn.transition = L, Jt === _i && Sf();
      }
    }
    function pv(i) {
      go !== null && go.tag === Xs && (Jt & (fr | os)) === _i && zs();
      var a = Jt;
      Jt |= D0;
      var d = Qn.transition, p = br();
      try {
        return Qn.transition = null, fi(aa), i ? i() : void 0;
      } finally {
        fi(p), Qn.transition = d, Jt = a, (Jt & (fr | os)) === _i && Vr();
      }
    }
    function m3() {
      return (Jt & (fr | os)) !== _i;
    }
    function v3(i) {
      var a = Jt;
      Jt |= D0;
      var d = Qn.transition, p = br();
      try {
        Qn.transition = null, fi(aa), i();
      } finally {
        fi(p), Qn.transition = d, Jt = a, Jt === _i && (Sf(), Vr());
      }
    }
    function mv(i, a) {
      En(N0, Ns, i), Ns = Wt(Ns, a);
    }
    function B0(i) {
      Ns = N0.current, li(N0, i);
    }
    function Du(i, a) {
      i.finishedWork = null, i.finishedLanes = Ge;
      var d = i.timeoutHandle;
      if (d !== No && (i.timeoutHandle = No, gc(d)), Kn !== null)
        for (var p = Kn.return; p !== null; ) {
          var y = p.alternate;
          nM(y, p), p = p.return;
        }
      dr = i;
      var T = Nu(i.current, null);
      return Kn = T, Li = Ns = a, Di = vo, Ch = null, ov = Ge, Rh = Ge, lv = Ge, Ah = null, Yr = null, Rn(), Gr.discardPendingWarnings(), T;
    }
    function zM(i, a) {
      do {
        var d = Kn;
        try {
          if (l(), t1(), Ci(), L0.current = null, d === null || d.return === null) {
            Di = Eh, Ch = a, Kn = null;
            return;
          }
          if (I && d.mode & cn && Bm(d, !0), N)
            if (es(), a !== null && typeof a == "object" && typeof a.then == "function") {
              var p = a;
              tf(d, p, Li);
            } else
              bs(d, a, Li);
          TR(i, d.return, d, a, Li), FM(d);
        } catch (y) {
          a = y, Kn === d && d !== null ? (d = d.return, Kn = d) : d = Kn;
          continue;
        }
        return;
      } while (!0);
    }
    function OM() {
      var i = A0.current;
      return A0.current = zm, i === null ? zm : i;
    }
    function IM(i) {
      A0.current = i;
    }
    function g3() {
      z0 = Yn();
    }
    function vv(i) {
      ov = Wt(i, ov);
    }
    function y3() {
      Di === vo && (Di = sv);
    }
    function H0() {
      (Di === vo || Di === sv || Di === Au) && (Di = Th), dr !== null && (Yc(ov) || Yc(Rh)) && Ml(dr, Li);
    }
    function _3(i) {
      Di !== Th && (Di = Au), Ah === null ? Ah = [i] : Ah.push(i);
    }
    function x3() {
      return Di === vo;
    }
    function gv(i, a) {
      var d = Jt;
      Jt |= fr;
      var p = OM();
      if (dr !== i || Li !== a) {
        if (rr) {
          var y = i.memoizedUpdaters;
          y.size > 0 && (Nh(i, Li), y.clear()), Gd(i, a);
        }
        Du(i, a);
      }
      vu(a);
      do
        try {
          S3();
          break;
        } catch (T) {
          zM(i, T);
        }
      while (!0);
      if (l(), Jt = d, IM(p), Kn !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Bi(), dr = null, Li = Ge, Di;
    }
    function S3() {
      for (; Kn !== null; )
        UM(Kn);
    }
    function M3(i, a) {
      var d = Jt;
      Jt |= fr;
      var p = OM();
      if (dr !== i || Li !== a) {
        if (rr) {
          var y = i.memoizedUpdaters;
          y.size > 0 && (Nh(i, Li), y.clear()), Gd(i, a);
        }
        Sf(), Du(i, a);
      }
      vu(a);
      do
        try {
          b3();
          break;
        } catch (T) {
          zM(i, T);
        }
      while (!0);
      return l(), IM(p), Jt = d, Kn !== null ? (rf(), vo) : (Bi(), dr = null, Li = Ge, Di);
    }
    function b3() {
      for (; Kn !== null && !am(); )
        UM(Kn);
    }
    function UM(i) {
      var a = i.alternate;
      pn(i);
      var d;
      (i.mode & cn) !== Ft ? (n0(i), d = k0(a, i, Ns), Bm(i, !0)) : d = k0(a, i, Ns), Ci(), i.memoizedProps = i.pendingProps, d === null ? FM(i) : Kn = d, L0.current = null;
    }
    function FM(i) {
      var a = i;
      do {
        var d = a.alternate, p = a.return;
        if ((a.flags & Q) === fe) {
          pn(a);
          var y = void 0;
          if ((a.mode & cn) === Ft ? y = O1(d, a, Ns) : (n0(a), y = O1(d, a, Ns), Bm(a, !1)), Ci(), y !== null) {
            Kn = y;
            return;
          }
        } else {
          var T = $R(d, a);
          if (T !== null) {
            T.flags &= U, Kn = T;
            return;
          }
          if ((a.mode & cn) !== Ft) {
            Bm(a, !1);
            for (var L = a.actualDuration, O = a.child; O !== null; )
              L += O.actualDuration, O = O.sibling;
            a.actualDuration = L;
          }
          if (p !== null)
            p.flags |= Q, p.subtreeFlags = fe, p.deletions = null;
          else {
            Di = P0, Kn = null;
            return;
          }
        }
        var F = a.sibling;
        if (F !== null) {
          Kn = F;
          return;
        }
        a = p, Kn = a;
      } while (a !== null);
      Di === vo && (Di = TM);
    }
    function Pu(i, a) {
      var d = br(), p = Qn.transition;
      try {
        Qn.transition = null, fi(aa), w3(i, a, d);
      } finally {
        Qn.transition = p, fi(d);
      }
      return null;
    }
    function w3(i, a, d) {
      do
        zs();
      while (go !== null);
      if (O3(), (Jt & (fr | os)) !== _i)
        throw new Error("Should not already be working.");
      var p = i.finishedWork, y = i.finishedLanes;
      if (di(y), p === null)
        return sl(), null;
      if (y === Ge && m("root.finishedLanes should not be empty during a commit. This is a bug in React."), i.finishedWork = null, i.finishedLanes = Ge, p === i.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      i.callbackNode = null, i.callbackPriority = ci;
      var T = Wt(p.lanes, p.childLanes);
      to(i, T), i === dr && (dr = null, Kn = null, Li = Ge), ((p.subtreeFlags & Ui) !== fe || (p.flags & Ui) !== fe) && (Lu || (Lu = !0, xv($a, function() {
        return zs(), null;
      })));
      var L = (p.subtreeFlags & (Ut | Dn | oi | Ui)) !== fe, O = (p.flags & (Ut | Dn | oi | Ui)) !== fe;
      if (L || O) {
        var F = Qn.transition;
        Qn.transition = null;
        var K = br();
        fi(aa);
        var re = Jt;
        Jt |= os, L0.current = null, sA(i, p), T1(), MA(i, p, y), Op(i.containerInfo), i.current = p, ws(y), TA(p, i, y), nf(), $c(), Jt = re, fi(K), Qn.transition = F;
      } else
        i.current = p, T1();
      var me = Lu;
      if (Lu && (Lu = !1, go = i, Lh = y), T = i.pendingLanes, T === Ge && (Mf = null), me || VM(i.current, !1), Xt(p.stateNode, d), rr && i.memoizedUpdaters.clear(), $A(), Xr(i, Yn()), a !== null)
        for (var Ce = i.onRecoverableError, ze = 0; ze < a.length; ze++) {
          var je = a[ze];
          Ce(je);
        }
      if (uv) {
        uv = !1;
        var Je = O0;
        throw O0 = null, Je;
      }
      return jn(Lh, $t) && i.tag !== Xs && zs(), T = i.pendingLanes, jn(T, $t) ? (_R(), i === U0 ? Dh++ : (Dh = 0, U0 = i)) : Dh = 0, Vr(), sl(), null;
    }
    function zs() {
      if (go !== null) {
        var i = qd(Lh), a = ty(il, i), d = Qn.transition, p = br();
        try {
          return Qn.transition = null, fi(a), T3();
        } finally {
          fi(p), Qn.transition = d;
        }
      }
      return !1;
    }
    function E3(i) {
      I0.push(i), Lu || (Lu = !0, xv($a, function() {
        return zs(), null;
      }));
    }
    function T3() {
      if (go === null)
        return !1;
      var i = go, a = Lh;
      if (go = null, Lh = Ge, (Jt & (fr | os)) !== _i)
        throw new Error("Cannot flush passive effects while already rendering.");
      mu(a);
      var d = Jt;
      Jt |= os, NA(i.current), AA(i, i.current);
      {
        var p = I0;
        I0 = [];
        for (var y = 0; y < p.length; y++) {
          var T = p[y];
          cA(i, T);
        }
      }
      $d(), VM(i.current, !0), Jt = d, Vr(), cv = go === null ? 0 : cv + 1, ii(i);
      {
        var L = i.current.stateNode;
        L.effectDuration = 0, L.passiveEffectDuration = 0;
      }
      return !0;
    }
    function BM(i) {
      return Mf !== null && Mf.has(i);
    }
    function C3(i) {
      Mf === null ? Mf = /* @__PURE__ */ new Set([i]) : Mf.add(i);
    }
    function R3(i) {
      uv || (uv = !0, O0 = i);
    }
    var A3 = R3;
    function HM(i, a, d) {
      var p = Hm(d, a), y = R1(i, p, $t);
      Zt(i, y);
      var T = Rr(), L = hv(i, $t);
      L !== null && (eo(L, $t, T), Xr(L, T));
    }
    function Zi(i, a, d) {
      if (i.tag === G) {
        HM(i, i, d);
        return;
      }
      var p = null;
      for (p = a; p !== null; ) {
        if (p.tag === G) {
          HM(p, i, d);
          return;
        } else if (p.tag === z) {
          var y = p.type, T = p.stateNode;
          if (typeof y.getDerivedStateFromError == "function" || typeof T.componentDidCatch == "function" && !BM(T)) {
            var L = Hm(d, i), O = o0(p, L, $t);
            Zt(p, O);
            var F = Rr(), K = hv(p, $t);
            K !== null && (eo(K, $t, F), Xr(K, F));
            return;
          }
        }
        p = p.return;
      }
      m(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, d);
    }
    function L3(i, a, d) {
      var p = i.pingCache;
      p !== null && p.delete(a);
      var y = Rr();
      nm(i, d), B3(i), dr === i && el(Li, d) && (Di === Th || Di === sv && Hd(Li) && Yn() - z0 < CM ? Du(i, Ge) : lv = Wt(lv, d)), Xr(i, y);
    }
    function kM(i, a) {
      a === ci && (a = o3(i));
      var d = Rr(), p = hv(i, a);
      p !== null && (eo(p, a, d), Xr(p, d));
    }
    function D3(i) {
      var a = i.memoizedState, d = ci;
      a !== null && (d = a.retryLane), kM(i, d);
    }
    function P3(i, a) {
      var d = ci, p;
      switch (i.tag) {
        case Y:
          p = i.stateNode;
          var y = i.memoizedState;
          y !== null && (d = y.retryLane);
          break;
        case ve:
          p = i.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      p !== null && p.delete(a), kM(i, d);
    }
    function N3(i) {
      return i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : i3(i / 1960) * 1960;
    }
    function z3() {
      if (Dh > a3)
        throw Dh = 0, U0 = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      cv > s3 && (cv = 0, m("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function O3() {
      Gr.flushLegacyContextWarning(), Gr.flushPendingUnsafeLifecycleWarnings();
    }
    function VM(i, a) {
      pn(i), yv(i, Ct, VA), a && yv(i, Mt, GA), yv(i, Ct, HA), a && yv(i, Mt, kA), Ci();
    }
    function yv(i, a, d) {
      for (var p = i, y = null; p !== null; ) {
        var T = p.subtreeFlags & a;
        p !== y && p.child !== null && T !== fe ? p = p.child : ((p.flags & a) !== fe && d(p), p.sibling !== null ? p = p.sibling : p = y = p.return);
      }
    }
    var _v = null;
    function GM(i) {
      {
        if ((Jt & fr) !== _i || !(i.mode & Mn))
          return;
        var a = i.tag;
        if (a !== k && a !== G && a !== z && a !== W && a !== V && a !== de && a !== le)
          return;
        var d = Re(i) || "ReactComponent";
        if (_v !== null) {
          if (_v.has(d))
            return;
          _v.add(d);
        } else
          _v = /* @__PURE__ */ new Set([d]);
        var p = Tr;
        try {
          pn(i), m("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          p ? pn(i) : Ci();
        }
      }
    }
    var k0;
    {
      var I3 = null;
      k0 = function(i, a, d) {
        var p = QM(I3, a);
        try {
          return tM(i, a, d);
        } catch (T) {
          if (T !== null && typeof T == "object" && typeof T.then == "function")
            throw T;
          if (l(), t1(), nM(i, a), QM(a, p), a.mode & cn && n0(a), aM(null, tM, null, i, a, d), nA()) {
            var y = sM();
            typeof y == "object" && y !== null && y._suppressLogging && typeof T == "object" && T !== null && !T._suppressLogging && (T._suppressLogging = !0);
          }
          throw T;
        }
      };
    }
    var WM = !1, V0;
    V0 = /* @__PURE__ */ new Set();
    function U3(i) {
      if (oa && !vR())
        switch (i.tag) {
          case W:
          case V:
          case le: {
            var a = Kn && Re(Kn) || "Unknown", d = a;
            if (!V0.has(d)) {
              V0.add(d);
              var p = Re(i) || "Unknown";
              m("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", p, a, a);
            }
            break;
          }
          case z: {
            WM || (m("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), WM = !0);
            break;
          }
        }
    }
    function Nh(i, a) {
      if (rr) {
        var d = i.memoizedUpdaters;
        d.forEach(function(p) {
          Vd(i, p, a);
        });
      }
    }
    var G0 = {};
    function xv(i, a) {
      {
        var d = ss.current;
        return d !== null ? (d.push(a), G0) : jd(i, a);
      }
    }
    function qM(i) {
      if (i !== G0)
        return rm(i);
    }
    function jM() {
      return ss.current !== null;
    }
    function F3(i) {
      {
        if (i.mode & Mn) {
          if (!EM())
            return;
        } else if (!n3() || Jt !== _i || i.tag !== W && i.tag !== V && i.tag !== le)
          return;
        if (ss.current === null) {
          var a = Tr;
          try {
            pn(i), m(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Re(i));
          } finally {
            a ? pn(i) : Ci();
          }
        }
      }
    }
    function B3(i) {
      i.tag !== Xs && EM() && ss.current === null && m(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Fa = null, bf = null, H3 = function(i) {
      Fa = i;
    };
    function wf(i) {
      {
        if (Fa === null)
          return i;
        var a = Fa(i);
        return a === void 0 ? i : a.current;
      }
    }
    function W0(i) {
      return wf(i);
    }
    function q0(i) {
      {
        if (Fa === null)
          return i;
        var a = Fa(i);
        if (a === void 0) {
          if (i != null && typeof i.render == "function") {
            var d = wf(i.render);
            if (i.render !== d) {
              var p = {
                $$typeof: pt,
                render: d
              };
              return i.displayName !== void 0 && (p.displayName = i.displayName), p;
            }
          }
          return i;
        }
        return a.current;
      }
    }
    function YM(i, a) {
      {
        if (Fa === null)
          return !1;
        var d = i.elementType, p = a.type, y = !1, T = typeof p == "object" && p !== null ? p.$$typeof : null;
        switch (i.tag) {
          case z: {
            typeof p == "function" && (y = !0);
            break;
          }
          case W: {
            (typeof p == "function" || T === H) && (y = !0);
            break;
          }
          case V: {
            (T === pt || T === H) && (y = !0);
            break;
          }
          case de:
          case le: {
            (T === X || T === H) && (y = !0);
            break;
          }
          default:
            return !1;
        }
        if (y) {
          var L = Fa(d);
          if (L !== void 0 && L === Fa(p))
            return !0;
        }
        return !1;
      }
    }
    function XM(i) {
      {
        if (Fa === null || typeof WeakSet != "function")
          return;
        bf === null && (bf = /* @__PURE__ */ new WeakSet()), bf.add(i);
      }
    }
    var k3 = function(i, a) {
      {
        if (Fa === null)
          return;
        var d = a.staleFamilies, p = a.updatedFamilies;
        zs(), pv(function() {
          j0(i.current, p, d);
        });
      }
    }, V3 = function(i, a) {
      {
        if (i.context !== on)
          return;
        zs(), pv(function() {
          eb(a, i, null, null);
        });
      }
    };
    function j0(i, a, d) {
      {
        var p = i.alternate, y = i.child, T = i.sibling, L = i.tag, O = i.type, F = null;
        switch (L) {
          case W:
          case le:
          case z:
            F = O;
            break;
          case V:
            F = O.render;
            break;
        }
        if (Fa === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var K = !1, re = !1;
        if (F !== null) {
          var me = Fa(F);
          me !== void 0 && (d.has(me) ? re = !0 : a.has(me) && (L === z ? re = !0 : K = !0));
        }
        bf !== null && (bf.has(i) || p !== null && bf.has(p)) && (re = !0), re && (i._debugNeedsRemount = !0), (re || K) && Pi(i, $t, Pn), y !== null && !re && j0(y, a, d), T !== null && j0(T, a, d);
      }
    }
    var G3 = function(i, a) {
      {
        var d = /* @__PURE__ */ new Set(), p = new Set(a.map(function(y) {
          return y.current;
        }));
        return Y0(i.current, p, d), d;
      }
    };
    function Y0(i, a, d) {
      {
        var p = i.child, y = i.sibling, T = i.tag, L = i.type, O = null;
        switch (T) {
          case W:
          case le:
          case z:
            O = L;
            break;
          case V:
            O = L.render;
            break;
        }
        var F = !1;
        O !== null && a.has(O) && (F = !0), F ? W3(i, d) : p !== null && Y0(p, a, d), y !== null && Y0(y, a, d);
      }
    }
    function W3(i, a) {
      {
        var d = q3(i, a);
        if (d)
          return;
        for (var p = i; ; ) {
          switch (p.tag) {
            case oe:
              a.add(p.stateNode);
              return;
            case $:
              a.add(p.stateNode.containerInfo);
              return;
            case G:
              a.add(p.stateNode.containerInfo);
              return;
          }
          if (p.return === null)
            throw new Error("Expected to reach root first.");
          p = p.return;
        }
      }
    }
    function q3(i, a) {
      for (var d = i, p = !1; ; ) {
        if (d.tag === oe)
          p = !0, a.add(d.stateNode);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === i)
          return p;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === i)
            return p;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !1;
    }
    var X0;
    {
      X0 = !1;
      try {
        var ZM = Object.preventExtensions({});
      } catch {
        X0 = !0;
      }
    }
    function j3(i, a, d, p) {
      this.tag = i, this.key = d, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = a, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = p, this.flags = fe, this.subtreeFlags = fe, this.deletions = null, this.lanes = Ge, this.childLanes = Ge, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !X0 && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var la = function(i, a, d, p) {
      return new j3(i, a, d, p);
    };
    function Z0(i) {
      var a = i.prototype;
      return !!(a && a.isReactComponent);
    }
    function Y3(i) {
      return typeof i == "function" && !Z0(i) && i.defaultProps === void 0;
    }
    function X3(i) {
      if (typeof i == "function")
        return Z0(i) ? z : W;
      if (i != null) {
        var a = i.$$typeof;
        if (a === pt)
          return V;
        if (a === X)
          return de;
      }
      return k;
    }
    function Nu(i, a) {
      var d = i.alternate;
      d === null ? (d = la(i.tag, a, i.key, i.mode), d.elementType = i.elementType, d.type = i.type, d.stateNode = i.stateNode, d._debugSource = i._debugSource, d._debugOwner = i._debugOwner, d._debugHookTypes = i._debugHookTypes, d.alternate = i, i.alternate = d) : (d.pendingProps = a, d.type = i.type, d.flags = fe, d.subtreeFlags = fe, d.deletions = null, d.actualDuration = 0, d.actualStartTime = -1), d.flags = i.flags & fn, d.childLanes = i.childLanes, d.lanes = i.lanes, d.child = i.child, d.memoizedProps = i.memoizedProps, d.memoizedState = i.memoizedState, d.updateQueue = i.updateQueue;
      var p = i.dependencies;
      switch (d.dependencies = p === null ? null : {
        lanes: p.lanes,
        firstContext: p.firstContext
      }, d.sibling = i.sibling, d.index = i.index, d.ref = i.ref, d.selfBaseDuration = i.selfBaseDuration, d.treeBaseDuration = i.treeBaseDuration, d._debugNeedsRemount = i._debugNeedsRemount, d.tag) {
        case k:
        case W:
        case le:
          d.type = wf(i.type);
          break;
        case z:
          d.type = W0(i.type);
          break;
        case V:
          d.type = q0(i.type);
          break;
      }
      return d;
    }
    function Z3(i, a) {
      i.flags &= fn | Be;
      var d = i.alternate;
      if (d === null)
        i.childLanes = Ge, i.lanes = a, i.child = null, i.subtreeFlags = fe, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null, i.selfBaseDuration = 0, i.treeBaseDuration = 0;
      else {
        i.childLanes = d.childLanes, i.lanes = d.lanes, i.child = d.child, i.subtreeFlags = fe, i.deletions = null, i.memoizedProps = d.memoizedProps, i.memoizedState = d.memoizedState, i.updateQueue = d.updateQueue, i.type = d.type;
        var p = d.dependencies;
        i.dependencies = p === null ? null : {
          lanes: p.lanes,
          firstContext: p.firstContext
        }, i.selfBaseDuration = d.selfBaseDuration, i.treeBaseDuration = d.treeBaseDuration;
      }
      return i;
    }
    function J3(i, a, d) {
      var p;
      return i === Dd ? (p = Mn, a === !0 && (p |= qn, p |= Br)) : p = Ft, rr && (p |= cn), la(G, null, null, p);
    }
    function J0(i, a, d, p, y, T) {
      var L = k, O = i;
      if (typeof i == "function")
        Z0(i) ? (L = z, O = W0(O)) : O = wf(O);
      else if (typeof i == "string")
        L = oe;
      else
        e:
          switch (i) {
            case ke:
              return bl(d.children, y, T, a);
            case rt:
              L = ye, y |= qn, (y & Mn) !== Ft && (y |= Br);
              break;
            case Xe:
              return Q3(d, y, T, a);
            case kt:
              return K3(d, y, T, a);
            case Gt:
              return $3(d, y, T, a);
            case Ye:
              return JM(d, y, T, a);
            case Ke:
            case be:
            case Et:
            case te:
            case qe:
            default: {
              if (typeof i == "object" && i !== null)
                switch (i.$$typeof) {
                  case wt:
                    L = De;
                    break e;
                  case St:
                    L = Me;
                    break e;
                  case pt:
                    L = V, O = q0(O);
                    break e;
                  case X:
                    L = de;
                    break e;
                  case H:
                    L = Pe, O = null;
                    break e;
                }
              var F = "";
              {
                (i === void 0 || typeof i == "object" && i !== null && Object.keys(i).length === 0) && (F += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var K = p ? Re(p) : null;
                K && (F += `

Check the render method of \`` + K + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (i == null ? i : typeof i) + "." + F));
            }
          }
      var re = la(L, d, a, y);
      return re.elementType = i, re.type = O, re.lanes = T, re._debugOwner = p, re;
    }
    function Q0(i, a, d) {
      var p = null;
      p = i._owner;
      var y = i.type, T = i.key, L = i.props, O = J0(y, T, L, p, a, d);
      return O._debugSource = i._source, O._debugOwner = i._owner, O;
    }
    function bl(i, a, d, p) {
      var y = la(ee, i, p, a);
      return y.lanes = d, y;
    }
    function Q3(i, a, d, p) {
      typeof i.id != "string" && m('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof i.id);
      var y = la(J, i, p, a | cn);
      return y.elementType = Xe, y.lanes = d, y.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, y;
    }
    function K3(i, a, d, p) {
      var y = la(Y, i, p, a);
      return y.elementType = kt, y.lanes = d, y;
    }
    function $3(i, a, d, p) {
      var y = la(ve, i, p, a);
      return y.elementType = Gt, y.lanes = d, y;
    }
    function JM(i, a, d, p) {
      var y = la(ot, i, p, a);
      y.elementType = Ye, y.lanes = d;
      var T = {};
      return y.stateNode = T, y;
    }
    function K0(i, a, d) {
      var p = la(ne, i, null, a);
      return p.lanes = d, p;
    }
    function e2() {
      var i = la(oe, null, null, Ft);
      return i.elementType = "DELETED", i;
    }
    function t2(i) {
      var a = la($e, null, null, Ft);
      return a.stateNode = i, a;
    }
    function $0(i, a, d) {
      var p = i.children !== null ? i.children : [], y = la($, p, i.key, a);
      return y.lanes = d, y.stateNode = {
        containerInfo: i.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: i.implementation
      }, y;
    }
    function QM(i, a) {
      return i === null && (i = la(k, null, null, Ft)), i.tag = a.tag, i.key = a.key, i.elementType = a.elementType, i.type = a.type, i.stateNode = a.stateNode, i.return = a.return, i.child = a.child, i.sibling = a.sibling, i.index = a.index, i.ref = a.ref, i.pendingProps = a.pendingProps, i.memoizedProps = a.memoizedProps, i.updateQueue = a.updateQueue, i.memoizedState = a.memoizedState, i.dependencies = a.dependencies, i.mode = a.mode, i.flags = a.flags, i.subtreeFlags = a.subtreeFlags, i.deletions = a.deletions, i.lanes = a.lanes, i.childLanes = a.childLanes, i.alternate = a.alternate, i.actualDuration = a.actualDuration, i.actualStartTime = a.actualStartTime, i.selfBaseDuration = a.selfBaseDuration, i.treeBaseDuration = a.treeBaseDuration, i._debugSource = a._debugSource, i._debugOwner = a._debugOwner, i._debugNeedsRemount = a._debugNeedsRemount, i._debugHookTypes = a._debugHookTypes, i;
    }
    function n2(i, a, d, p, y) {
      this.tag = a, this.containerInfo = i, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = No, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = ci, this.eventTimes = tl(Ge), this.expirationTimes = tl(Pn), this.pendingLanes = Ge, this.suspendedLanes = Ge, this.pingedLanes = Ge, this.expiredLanes = Ge, this.mutableReadLanes = Ge, this.finishedLanes = Ge, this.entangledLanes = Ge, this.entanglements = tl(Ge), this.identifierPrefix = p, this.onRecoverableError = y, Gi && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var T = this.pendingUpdatersLaneMap = [], L = 0; L < su; L++)
          T.push(/* @__PURE__ */ new Set());
      }
      switch (a) {
        case Dd:
          this._debugRootType = d ? "hydrateRoot()" : "createRoot()";
          break;
        case Xs:
          this._debugRootType = d ? "hydrate()" : "render()";
          break;
      }
    }
    function KM(i, a, d, p, y, T, L, O, F, K) {
      var re = new n2(i, a, d, O, F), me = J3(a, T);
      re.current = me, me.stateNode = re;
      {
        var Ce = {
          element: p,
          isDehydrated: d,
          cache: null,
          // not enabled yet
          transitions: null
        };
        me.memoizedState = Ce;
      }
      return bt(me), re;
    }
    var i2 = "18.0.0-fc46dba67-20220329";
    function r2(i, a, d) {
      var p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return ay(p), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: we,
        key: p == null ? null : "" + p,
        children: i,
        containerInfo: a,
        implementation: d
      };
    }
    var e_, t_;
    e_ = !1, t_ = {};
    function $M(i) {
      if (!i)
        return on;
      var a = x(i), d = Oc(a);
      if (a.tag === z) {
        var p = a.type;
        if (Fr(p))
          return ia(a, p, d);
      }
      return d;
    }
    function a2(i) {
      var a = x(i);
      if (a === void 0) {
        if (typeof i.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var d = Object.keys(i).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + d);
      }
      var p = tr(a);
      return p === null ? null : p.stateNode;
    }
    function s2(i, a) {
      {
        var d = x(i);
        if (d === void 0) {
          if (typeof i.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var p = Object.keys(i).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + p);
        }
        var y = tr(d);
        if (y === null)
          return null;
        if (y.mode & qn) {
          var T = Re(d) || "Component";
          if (!t_[T]) {
            t_[T] = !0;
            var L = Tr;
            try {
              pn(y), d.mode & qn ? m("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, T) : m("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, T);
            } finally {
              L ? pn(L) : Ci();
            }
          }
        }
        return y.stateNode;
      }
    }
    function o2(i, a, d, p, y, T, L, O) {
      var F = !1, K = null;
      return KM(i, a, F, K, d, p, y, T, L);
    }
    function l2(i, a, d, p, y, T, L, O, F, K) {
      var re = !0, me = KM(d, p, re, i, y, T, L, O, F);
      me.context = $M(null);
      var Ce = me.current, ze = Rr(), je = Sl(Ce), Je = zt(ze, je);
      return Je.callback = a ?? null, Zt(Ce, Je), l3(me, je, ze), me;
    }
    function eb(i, a, d, p) {
      Xn(a, i);
      var y = a.current, T = Rr(), L = Sl(y);
      Es(L);
      var O = $M(d);
      a.context === null ? a.context = O : a.pendingContext = O, oa && Tr !== null && !e_ && (e_ = !0, m(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Re(Tr) || "Unknown"));
      var F = zt(T, L);
      F.payload = {
        element: i
      }, p = p === void 0 ? null : p, p !== null && (typeof p != "function" && m("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", p), F.callback = p), Zt(y, F);
      var K = Pi(y, L, T);
      return K !== null && Zn(K, y, L), L;
    }
    function u2(i) {
      var a = i.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case oe:
          return Jr(a.child.stateNode);
        default:
          return a.child.stateNode;
      }
    }
    function c2(i) {
      switch (i.tag) {
        case G:
          var a = i.stateNode;
          if (Ts(a)) {
            var d = Fd(a);
            f3(a, d);
          }
          break;
        case Y:
          var p = Rr();
          pv(function() {
            return Pi(i, $t, p);
          });
          var y = $t;
          n_(i, y);
          break;
      }
    }
    function tb(i, a) {
      var d = i.memoizedState;
      d !== null && d.dehydrated !== null && (d.retryLane = ft(d.retryLane, a));
    }
    function n_(i, a) {
      tb(i, a);
      var d = i.alternate;
      d && tb(d, a);
    }
    function f2(i) {
      if (i.tag === Y) {
        var a = Rr(), d = xs;
        Pi(i, d, a), n_(i, d);
      }
    }
    function d2(i) {
      if (i.tag === Y) {
        var a = Rr(), d = Sl(i);
        Pi(i, d, a), n_(i, d);
      }
    }
    function h2(i) {
      var a = sn(i);
      return a === null ? null : a.stateNode;
    }
    var nb = function(i) {
      return null;
    };
    function ib(i) {
      return nb(i);
    }
    var rb = function(i) {
      return !1;
    };
    function ab(i) {
      return rb(i);
    }
    var sb = null, ob = null, lb = null, ub = null, cb = null, fb = null, db = null, hb = null, pb = null;
    {
      var mb = function(i, a, d) {
        var p = a[d], y = yn(i) ? i.slice() : _({}, i);
        return d + 1 === a.length ? (yn(y) ? y.splice(p, 1) : delete y[p], y) : (y[p] = mb(i[p], a, d + 1), y);
      }, vb = function(i, a) {
        return mb(i, a, 0);
      }, gb = function(i, a, d, p) {
        var y = a[p], T = yn(i) ? i.slice() : _({}, i);
        if (p + 1 === a.length) {
          var L = d[p];
          T[L] = T[y], yn(T) ? T.splice(y, 1) : delete T[y];
        } else
          T[y] = gb(
            // $FlowFixMe number or string is fine here
            i[y],
            a,
            d,
            p + 1
          );
        return T;
      }, yb = function(i, a, d) {
        if (a.length !== d.length) {
          h("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var p = 0; p < d.length - 1; p++)
            if (a[p] !== d[p]) {
              h("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return gb(i, a, d, 0);
      }, _b = function(i, a, d, p) {
        if (d >= a.length)
          return p;
        var y = a[d], T = yn(i) ? i.slice() : _({}, i);
        return T[y] = _b(i[y], a, d + 1, p), T;
      }, xb = function(i, a, d) {
        return _b(i, a, 0, d);
      }, i_ = function(i, a) {
        for (var d = i.memoizedState; d !== null && a > 0; )
          d = d.next, a--;
        return d;
      };
      sb = function(i, a, d, p) {
        var y = i_(i, a);
        if (y !== null) {
          var T = xb(y.memoizedState, d, p);
          y.memoizedState = T, y.baseState = T, i.memoizedProps = _({}, i.memoizedProps), Pi(i, $t, Pn);
        }
      }, ob = function(i, a, d) {
        var p = i_(i, a);
        if (p !== null) {
          var y = vb(p.memoizedState, d);
          p.memoizedState = y, p.baseState = y, i.memoizedProps = _({}, i.memoizedProps), Pi(i, $t, Pn);
        }
      }, lb = function(i, a, d, p) {
        var y = i_(i, a);
        if (y !== null) {
          var T = yb(y.memoizedState, d, p);
          y.memoizedState = T, y.baseState = T, i.memoizedProps = _({}, i.memoizedProps), Pi(i, $t, Pn);
        }
      }, ub = function(i, a, d) {
        i.pendingProps = xb(i.memoizedProps, a, d), i.alternate && (i.alternate.pendingProps = i.pendingProps), Pi(i, $t, Pn);
      }, cb = function(i, a) {
        i.pendingProps = vb(i.memoizedProps, a), i.alternate && (i.alternate.pendingProps = i.pendingProps), Pi(i, $t, Pn);
      }, fb = function(i, a, d) {
        i.pendingProps = yb(i.memoizedProps, a, d), i.alternate && (i.alternate.pendingProps = i.pendingProps), Pi(i, $t, Pn);
      }, db = function(i) {
        Pi(i, $t, Pn);
      }, hb = function(i) {
        nb = i;
      }, pb = function(i) {
        rb = i;
      };
    }
    function p2(i) {
      var a = tr(i);
      return a === null ? null : a.stateNode;
    }
    function m2(i) {
      return null;
    }
    function v2() {
      return Tr;
    }
    function g2(i) {
      var a = i.findFiberByHostInstance, d = s.ReactCurrentDispatcher;
      return Zd({
        bundleType: i.bundleType,
        version: i.version,
        rendererPackageName: i.rendererPackageName,
        rendererConfig: i.rendererConfig,
        overrideHookState: sb,
        overrideHookStateDeletePath: ob,
        overrideHookStateRenamePath: lb,
        overrideProps: ub,
        overridePropsDeletePath: cb,
        overridePropsRenamePath: fb,
        setErrorHandler: hb,
        setSuspenseHandler: pb,
        scheduleUpdate: db,
        currentDispatcherRef: d,
        findHostInstanceByFiber: p2,
        findFiberByHostInstance: a || m2,
        // React Refresh
        findHostInstancesForRefresh: G3,
        scheduleRefresh: k3,
        scheduleRoot: V3,
        setRefreshHandler: H3,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: v2,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: i2
      });
    }
    return t.attemptContinuousHydration = f2, t.attemptHydrationAtCurrentPriority = d2, t.attemptSynchronousHydration = c2, t.batchedUpdates = h3, t.createComponentSelector = WA, t.createContainer = o2, t.createHasPseudoClassSelector = qA, t.createHydrationContainer = l2, t.createPortal = r2, t.createRoleSelector = jA, t.createTestNameSelector = XA, t.createTextSelector = YA, t.deferredUpdates = d3, t.discreteUpdates = p3, t.findAllNodes = rv, t.findBoundingRects = QA, t.findHostInstance = a2, t.findHostInstanceWithNoPortals = h2, t.findHostInstanceWithWarning = s2, t.flushControlled = v3, t.flushPassiveEffects = zs, t.flushSync = pv, t.focusWithin = KA, t.getCurrentUpdatePriority = br, t.getFindAllNodesFailureDescription = JA, t.getPublicRootInstance = u2, t.injectIntoDevTools = g2, t.isAlreadyRendering = m3, t.observeVisibleRects = e3, t.registerMutableSourceForHydration = cR, t.runWithPriority = Wd, t.shouldError = ib, t.shouldSuspend = ab, t.updateContainer = eb, t;
  })), G_.exports;
}
process.env.NODE_ENV === "production" ? kx.exports = IU() : kx.exports = UU();
var FU = kx.exports;
const BU = /* @__PURE__ */ yE(FU);
var Vx = { exports: {} }, W_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $w;
function HU() {
  return $w || ($w = 1, function(u) {
    function e(V, J) {
      var Y = V.length;
      V.push(J);
      e:
        for (; 0 < Y; ) {
          var de = Y - 1 >>> 1, le = V[de];
          if (0 < r(le, J))
            V[de] = J, V[Y] = le, Y = de;
          else
            break e;
        }
    }
    function t(V) {
      return V.length === 0 ? null : V[0];
    }
    function n(V) {
      if (V.length === 0)
        return null;
      var J = V[0], Y = V.pop();
      if (Y !== J) {
        V[0] = Y;
        e:
          for (var de = 0, le = V.length, Pe = le >>> 1; de < Pe; ) {
            var We = 2 * (de + 1) - 1, $e = V[We], ve = We + 1, gt = V[ve];
            if (0 > r($e, Y))
              ve < le && 0 > r(gt, $e) ? (V[de] = gt, V[ve] = Y, de = ve) : (V[de] = $e, V[We] = Y, de = We);
            else if (ve < le && 0 > r(gt, Y))
              V[de] = gt, V[ve] = Y, de = ve;
            else
              break e;
          }
      }
      return J;
    }
    function r(V, J) {
      var Y = V.sortIndex - J.sortIndex;
      return Y !== 0 ? Y : V.id - J.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      u.unstable_now = function() {
        return s.now();
      };
    } else {
      var c = Date, f = c.now();
      u.unstable_now = function() {
        return c.now() - f;
      };
    }
    var h = [], m = [], g = 1, _ = null, x = 3, M = !1, b = !1, E = !1, w = typeof setTimeout == "function" ? setTimeout : null, R = typeof clearTimeout == "function" ? clearTimeout : null, A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function P(V) {
      for (var J = t(m); J !== null; ) {
        if (J.callback === null)
          n(m);
        else if (J.startTime <= V)
          n(m), J.sortIndex = J.expirationTime, e(h, J);
        else
          break;
        J = t(m);
      }
    }
    function N(V) {
      if (E = !1, P(V), !b)
        if (t(h) !== null)
          b = !0, Me(I);
        else {
          var J = t(m);
          J !== null && De(N, J.startTime - V);
        }
    }
    function I(V, J) {
      b = !1, E && (E = !1, R(z), z = -1), M = !0;
      var Y = x;
      try {
        for (P(J), _ = t(h); _ !== null && (!(_.expirationTime > J) || V && !$()); ) {
          var de = _.callback;
          if (typeof de == "function") {
            _.callback = null, x = _.priorityLevel;
            var le = de(_.expirationTime <= J);
            J = u.unstable_now(), typeof le == "function" ? _.callback = le : _ === t(h) && n(h), P(J);
          } else
            n(h);
          _ = t(h);
        }
        if (_ !== null)
          var Pe = !0;
        else {
          var We = t(m);
          We !== null && De(N, We.startTime - J), Pe = !1;
        }
        return Pe;
      } finally {
        _ = null, x = Y, M = !1;
      }
    }
    var B = !1, W = null, z = -1, k = 5, G = -1;
    function $() {
      return !(u.unstable_now() - G < k);
    }
    function oe() {
      if (W !== null) {
        var V = u.unstable_now();
        G = V;
        var J = !0;
        try {
          J = W(!0, V);
        } finally {
          J ? ne() : (B = !1, W = null);
        }
      } else
        B = !1;
    }
    var ne;
    if (typeof A == "function")
      ne = function() {
        A(oe);
      };
    else if (typeof MessageChannel < "u") {
      var ee = new MessageChannel(), ye = ee.port2;
      ee.port1.onmessage = oe, ne = function() {
        ye.postMessage(null);
      };
    } else
      ne = function() {
        w(oe, 0);
      };
    function Me(V) {
      W = V, B || (B = !0, ne());
    }
    function De(V, J) {
      z = w(function() {
        V(u.unstable_now());
      }, J);
    }
    u.unstable_IdlePriority = 5, u.unstable_ImmediatePriority = 1, u.unstable_LowPriority = 4, u.unstable_NormalPriority = 3, u.unstable_Profiling = null, u.unstable_UserBlockingPriority = 2, u.unstable_cancelCallback = function(V) {
      V.callback = null;
    }, u.unstable_continueExecution = function() {
      b || M || (b = !0, Me(I));
    }, u.unstable_forceFrameRate = function(V) {
      0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : k = 0 < V ? Math.floor(1e3 / V) : 5;
    }, u.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, u.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, u.unstable_next = function(V) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var J = 3;
          break;
        default:
          J = x;
      }
      var Y = x;
      x = J;
      try {
        return V();
      } finally {
        x = Y;
      }
    }, u.unstable_pauseExecution = function() {
    }, u.unstable_requestPaint = function() {
    }, u.unstable_runWithPriority = function(V, J) {
      switch (V) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          V = 3;
      }
      var Y = x;
      x = V;
      try {
        return J();
      } finally {
        x = Y;
      }
    }, u.unstable_scheduleCallback = function(V, J, Y) {
      var de = u.unstable_now();
      switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? de + Y : de) : Y = de, V) {
        case 1:
          var le = -1;
          break;
        case 2:
          le = 250;
          break;
        case 5:
          le = 1073741823;
          break;
        case 4:
          le = 1e4;
          break;
        default:
          le = 5e3;
      }
      return le = Y + le, V = { id: g++, callback: J, priorityLevel: V, startTime: Y, expirationTime: le, sortIndex: -1 }, Y > de ? (V.sortIndex = Y, e(m, V), t(h) === null && V === t(m) && (E ? (R(z), z = -1) : E = !0, De(N, Y - de))) : (V.sortIndex = le, e(h, V), b || M || (b = !0, Me(I))), V;
    }, u.unstable_shouldYield = $, u.unstable_wrapCallback = function(V) {
      var J = x;
      return function() {
        var Y = x;
        x = J;
        try {
          return V.apply(this, arguments);
        } finally {
          x = Y;
        }
      };
    };
  }(W_)), W_;
}
var q_ = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eE;
function kU() {
  return eE || (eE = 1, function(u) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, n = 5;
      function r(ae, pe) {
        var Ee = ae.length;
        ae.push(pe), f(ae, pe, Ee);
      }
      function s(ae) {
        return ae.length === 0 ? null : ae[0];
      }
      function c(ae) {
        if (ae.length === 0)
          return null;
        var pe = ae[0], Ee = ae.pop();
        return Ee !== pe && (ae[0] = Ee, h(ae, Ee, 0)), pe;
      }
      function f(ae, pe, Ee) {
        for (var He = Ee; He > 0; ) {
          var Fe = He - 1 >>> 1, Tt = ae[Fe];
          if (m(Tt, pe) > 0)
            ae[Fe] = pe, ae[He] = Tt, He = Fe;
          else
            return;
        }
      }
      function h(ae, pe, Ee) {
        for (var He = Ee, Fe = ae.length, Tt = Fe >>> 1; He < Tt; ) {
          var ie = (He + 1) * 2 - 1, Re = ae[ie], fe = ie + 1, Ae = ae[fe];
          if (m(Re, pe) < 0)
            fe < Fe && m(Ae, Re) < 0 ? (ae[He] = Ae, ae[fe] = pe, He = fe) : (ae[He] = Re, ae[ie] = pe, He = ie);
          else if (fe < Fe && m(Ae, pe) < 0)
            ae[He] = Ae, ae[fe] = pe, He = fe;
          else
            return;
        }
      }
      function m(ae, pe) {
        var Ee = ae.sortIndex - pe.sortIndex;
        return Ee !== 0 ? Ee : ae.id - pe.id;
      }
      var g = 1, _ = 2, x = 3, M = 4, b = 5;
      function E(ae, pe) {
      }
      var w = typeof performance == "object" && typeof performance.now == "function";
      if (w) {
        var R = performance;
        u.unstable_now = function() {
          return R.now();
        };
      } else {
        var A = Date, P = A.now();
        u.unstable_now = function() {
          return A.now() - P;
        };
      }
      var N = 1073741823, I = -1, B = 250, W = 5e3, z = 1e4, k = N, G = [], $ = [], oe = 1, ne = null, ee = x, ye = !1, Me = !1, De = !1, V = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, Y = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function de(ae) {
        for (var pe = s($); pe !== null; ) {
          if (pe.callback === null)
            c($);
          else if (pe.startTime <= ae)
            c($), pe.sortIndex = pe.expirationTime, r(G, pe);
          else
            return;
          pe = s($);
        }
      }
      function le(ae) {
        if (De = !1, de(ae), !Me)
          if (s(G) !== null)
            Me = !0, Ye(Pe);
          else {
            var pe = s($);
            pe !== null && Ke(le, pe.startTime - ae);
          }
      }
      function Pe(ae, pe) {
        Me = !1, De && (De = !1, Et()), ye = !0;
        var Ee = ee;
        try {
          var He;
          if (!t)
            return We(ae, pe);
        } finally {
          ne = null, ee = Ee, ye = !1;
        }
      }
      function We(ae, pe) {
        var Ee = pe;
        for (de(Ee), ne = s(G); ne !== null && !e && !(ne.expirationTime > Ee && (!ae || pt())); ) {
          var He = ne.callback;
          if (typeof He == "function") {
            ne.callback = null, ee = ne.priorityLevel;
            var Fe = ne.expirationTime <= Ee, Tt = He(Fe);
            Ee = u.unstable_now(), typeof Tt == "function" ? ne.callback = Tt : ne === s(G) && c(G), de(Ee);
          } else
            c(G);
          ne = s(G);
        }
        if (ne !== null)
          return !0;
        var ie = s($);
        return ie !== null && Ke(le, ie.startTime - Ee), !1;
      }
      function $e(ae, pe) {
        switch (ae) {
          case g:
          case _:
          case x:
          case M:
          case b:
            break;
          default:
            ae = x;
        }
        var Ee = ee;
        ee = ae;
        try {
          return pe();
        } finally {
          ee = Ee;
        }
      }
      function ve(ae) {
        var pe;
        switch (ee) {
          case g:
          case _:
          case x:
            pe = x;
            break;
          default:
            pe = ee;
            break;
        }
        var Ee = ee;
        ee = pe;
        try {
          return ae();
        } finally {
          ee = Ee;
        }
      }
      function gt(ae) {
        var pe = ee;
        return function() {
          var Ee = ee;
          ee = pe;
          try {
            return ae.apply(this, arguments);
          } finally {
            ee = Ee;
          }
        };
      }
      function ot(ae, pe, Ee) {
        var He = u.unstable_now(), Fe;
        if (typeof Ee == "object" && Ee !== null) {
          var Tt = Ee.delay;
          typeof Tt == "number" && Tt > 0 ? Fe = He + Tt : Fe = He;
        } else
          Fe = He;
        var ie;
        switch (ae) {
          case g:
            ie = I;
            break;
          case _:
            ie = B;
            break;
          case b:
            ie = k;
            break;
          case M:
            ie = z;
            break;
          case x:
          default:
            ie = W;
            break;
        }
        var Re = Fe + ie, fe = {
          id: oe++,
          callback: pe,
          priorityLevel: ae,
          startTime: Fe,
          expirationTime: Re,
          sortIndex: -1
        };
        return Fe > He ? (fe.sortIndex = Fe, r($, fe), s(G) === null && fe === s($) && (De ? Et() : De = !0, Ke(le, Fe - He))) : (fe.sortIndex = Re, r(G, fe), !Me && !ye && (Me = !0, Ye(Pe))), fe;
      }
      function _t() {
      }
      function Qe() {
        !Me && !ye && (Me = !0, Ye(Pe));
      }
      function At() {
        return s(G);
      }
      function Ne(ae) {
        ae.callback = null;
      }
      function we() {
        return ee;
      }
      var ke = !1, rt = null, Xe = -1, wt = n, St = -1;
      function pt() {
        var ae = u.unstable_now() - St;
        return !(ae < wt);
      }
      function kt() {
      }
      function Gt(ae) {
        if (ae < 0 || ae > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ae > 0 ? wt = Math.floor(1e3 / ae) : wt = n;
      }
      var X = function() {
        if (rt !== null) {
          var ae = u.unstable_now();
          St = ae;
          var pe = !0, Ee = !0;
          try {
            Ee = rt(pe, ae);
          } finally {
            Ee ? H() : (ke = !1, rt = null);
          }
        } else
          ke = !1;
      }, H;
      if (typeof Y == "function")
        H = function() {
          Y(X);
        };
      else if (typeof MessageChannel < "u") {
        var be = new MessageChannel(), qe = be.port2;
        be.port1.onmessage = X, H = function() {
          qe.postMessage(null);
        };
      } else
        H = function() {
          V(X, 0);
        };
      function Ye(ae) {
        rt = ae, ke || (ke = !0, H());
      }
      function Ke(ae, pe) {
        Xe = V(function() {
          ae(u.unstable_now());
        }, pe);
      }
      function Et() {
        J(Xe), Xe = -1;
      }
      var te = kt, he = null;
      u.unstable_IdlePriority = b, u.unstable_ImmediatePriority = g, u.unstable_LowPriority = M, u.unstable_NormalPriority = x, u.unstable_Profiling = he, u.unstable_UserBlockingPriority = _, u.unstable_cancelCallback = Ne, u.unstable_continueExecution = Qe, u.unstable_forceFrameRate = Gt, u.unstable_getCurrentPriorityLevel = we, u.unstable_getFirstCallbackNode = At, u.unstable_next = ve, u.unstable_pauseExecution = _t, u.unstable_requestPaint = te, u.unstable_runWithPriority = $e, u.unstable_scheduleCallback = ot, u.unstable_shouldYield = pt, u.unstable_wrapCallback = gt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(q_)), q_;
}
process.env.NODE_ENV === "production" ? Vx.exports = HU() : Vx.exports = kU();
var tE = Vx.exports;
const CS = {}, MC = (u) => void Object.assign(CS, u);
function VU(u, e) {
  function t(g, {
    args: _ = [],
    attach: x,
    ...M
  }, b) {
    let E = `${g[0].toUpperCase()}${g.slice(1)}`, w;
    if (g === "primitive") {
      if (M.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const R = M.object;
      w = Yf(R, {
        type: g,
        root: b,
        attach: x,
        primitive: !0
      });
    } else {
      const R = CS[E];
      if (!R)
        throw new Error(`R3F: ${E} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(_))
        throw new Error("R3F: The args prop must be an array!");
      w = Yf(new R(..._), {
        type: g,
        root: b,
        attach: x,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: _
        }
      });
    }
    return w.__r3f.attach === void 0 && (w instanceof Kt ? w.__r3f.attach = "geometry" : w instanceof Ki && (w.__r3f.attach = "material")), E !== "inject" && X_(w, M), w;
  }
  function n(g, _) {
    let x = !1;
    if (_) {
      var M, b;
      (M = _.__r3f) != null && M.attach ? Y_(g, _, _.__r3f.attach) : _.isObject3D && g.isObject3D && (g.add(_), x = !0), x || (b = g.__r3f) == null || b.objects.push(_), _.__r3f || Yf(_, {}), _.__r3f.parent = g, Wx(_), Xf(_);
    }
  }
  function r(g, _, x) {
    let M = !1;
    if (_) {
      var b, E;
      if ((b = _.__r3f) != null && b.attach)
        Y_(g, _, _.__r3f.attach);
      else if (_.isObject3D && g.isObject3D) {
        _.parent = g, _.dispatchEvent({
          type: "added"
        });
        const w = g.children.filter((A) => A !== _), R = w.indexOf(x);
        g.children = [...w.slice(0, R), _, ...w.slice(R)], M = !0;
      }
      M || (E = g.__r3f) == null || E.objects.push(_), _.__r3f || Yf(_, {}), _.__r3f.parent = g, Wx(_), Xf(_);
    }
  }
  function s(g, _, x = !1) {
    g && [...g].forEach((M) => c(_, M, x));
  }
  function c(g, _, x) {
    if (_) {
      var M, b, E;
      if (_.__r3f && (_.__r3f.parent = null), (M = g.__r3f) != null && M.objects && (g.__r3f.objects = g.__r3f.objects.filter((N) => N !== _)), (b = _.__r3f) != null && b.attach)
        sE(g, _, _.__r3f.attach);
      else if (_.isObject3D && g.isObject3D) {
        var w;
        g.remove(_), (w = _.__r3f) != null && w.root && JU(_.__r3f.root, _);
      }
      const A = (E = _.__r3f) == null ? void 0 : E.primitive, P = !A && (x === void 0 ? _.dispose !== null : x);
      if (!A) {
        var R;
        s((R = _.__r3f) == null ? void 0 : R.objects, _, P), s(_.children, _, P);
      }
      if (delete _.__r3f, P && _.dispose && _.type !== "Scene") {
        const N = () => {
          try {
            _.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? tE.unstable_scheduleCallback(tE.unstable_IdlePriority, N) : N();
      }
      Xf(g);
    }
  }
  function f(g, _, x, M) {
    var b;
    const E = (b = g.__r3f) == null ? void 0 : b.parent;
    if (!E)
      return;
    const w = t(_, x, g.__r3f.root);
    if (g.children) {
      for (const R of g.children)
        R.__r3f && n(w, R);
      g.children = g.children.filter((R) => !R.__r3f);
    }
    g.__r3f.objects.forEach((R) => n(w, R)), g.__r3f.objects = [], g.__r3f.autoRemovedBeforeAppend || c(E, g), w.parent && (w.__r3f.autoRemovedBeforeAppend = !0), n(E, w), w.raycast && w.__r3f.eventCount && w.__r3f.root.getState().internal.interaction.push(w), [M, M.alternate].forEach((R) => {
      R !== null && (R.stateNode = w, R.ref && (typeof R.ref == "function" ? R.ref(w) : R.ref.current = w));
    });
  }
  const h = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: BU({
      createInstance: t,
      removeChild: c,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (g, _) => {
        if (!_)
          return;
        const x = g.getState().scene;
        x.__r3f && (x.__r3f.root = g, n(x, _));
      },
      removeChildFromContainer: (g, _) => {
        _ && c(g.getState().scene, _);
      },
      insertInContainerBefore: (g, _, x) => {
        if (!_ || !x)
          return;
        const M = g.getState().scene;
        M.__r3f && r(M, _, x);
      },
      getRootHostContext: () => null,
      getChildHostContext: (g) => g,
      finalizeInitialChildren(g) {
        var _;
        return !!((_ = g == null ? void 0 : g.__r3f) != null ? _ : {}).handlers;
      },
      prepareUpdate(g, _, x, M) {
        var b;
        if (((b = g == null ? void 0 : g.__r3f) != null ? b : {}).primitive && M.object && M.object !== g)
          return [!0];
        {
          const {
            args: w = [],
            children: R,
            ...A
          } = M, {
            args: P = [],
            children: N,
            ...I
          } = x;
          if (!Array.isArray(w))
            throw new Error("R3F: the args prop must be an array!");
          if (w.some((W, z) => W !== P[z]))
            return [!0];
          const B = AC(g, A, I, !0);
          return B.changes.length ? [!1, B] : null;
        }
      },
      commitUpdate(g, [_, x], M, b, E, w) {
        _ ? f(g, M, E, w) : X_(g, x);
      },
      commitMount(g, _, x, M) {
        var b;
        const E = (b = g.__r3f) != null ? b : {};
        g.raycast && E.handlers && E.eventCount && g.__r3f.root.getState().internal.interaction.push(g);
      },
      getPublicInstance: (g) => g,
      prepareForCommit: () => null,
      preparePortalMount: (g) => Yf(g.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(g) {
        var _;
        const {
          attach: x,
          parent: M
        } = (_ = g.__r3f) != null ? _ : {};
        x && M && sE(M, g, x), g.isObject3D && (g.visible = !1), Xf(g);
      },
      unhideInstance(g, _) {
        var x;
        const {
          attach: M,
          parent: b
        } = (x = g.__r3f) != null ? x : {};
        M && b && Y_(b, g, M), (g.isObject3D && _.visible == null || _.visible) && (g.visible = !0), Xf(g);
      },
      createTextInstance: h,
      hideTextInstance: h,
      unhideTextInstance: h,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-ignore
      getCurrentEventPriority: () => e ? e() : $f.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Wn.fun(performance.now) ? performance.now : Wn.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: Wn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Wn.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: X_
  };
}
var nE, iE;
const j_ = (u) => "colorSpace" in u || "outputColorSpace" in u, bC = () => {
  var u;
  return (u = CS.ColorManagement) != null ? u : null;
}, wC = (u) => u && u.isOrthographicCamera, GU = (u) => u && u.hasOwnProperty("current"), zp = typeof window < "u" && ((nE = window.document) != null && nE.createElement || ((iE = window.navigator) == null ? void 0 : iE.product) === "ReactNative") ? Yt.useLayoutEffect : Yt.useEffect;
function EC(u) {
  const e = Yt.useRef(u);
  return zp(() => void (e.current = u), [u]), e;
}
function WU({
  set: u
}) {
  return zp(() => (u(new Promise(() => null)), () => u(!1)), [u]), null;
}
class TC extends Yt.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
TC.getDerivedStateFromError = () => ({
  error: !0
});
const CC = "__default", rE = /* @__PURE__ */ new Map(), qU = (u) => u && !!u.memoized && !!u.changes;
function RC(u) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(u) ? Math.min(Math.max(u[0], t), u[1]) : u;
}
const Wh = (u) => {
  var e;
  return (e = u.__r3f) == null ? void 0 : e.root.getState();
}, Wn = {
  obj: (u) => u === Object(u) && !Wn.arr(u) && typeof u != "function",
  fun: (u) => typeof u == "function",
  str: (u) => typeof u == "string",
  num: (u) => typeof u == "number",
  boo: (u) => typeof u == "boolean",
  und: (u) => u === void 0,
  arr: (u) => Array.isArray(u),
  equ(u, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: r = !0
  } = {}) {
    if (typeof u != typeof e || !!u != !!e)
      return !1;
    if (Wn.str(u) || Wn.num(u))
      return u === e;
    const s = Wn.obj(u);
    if (s && n === "reference")
      return u === e;
    const c = Wn.arr(u);
    if (c && t === "reference")
      return u === e;
    if ((c || s) && u === e)
      return !0;
    let f;
    for (f in u)
      if (!(f in e))
        return !1;
    if (s && t === "shallow" && n === "shallow") {
      for (f in r ? e : u)
        if (!Wn.equ(u[f], e[f], {
          strict: r,
          objects: "reference"
        }))
          return !1;
    } else
      for (f in r ? e : u)
        if (u[f] !== e[f])
          return !1;
    if (Wn.und(f)) {
      if (c && u.length === 0 && e.length === 0 || s && Object.keys(u).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (u !== e)
        return !1;
    }
    return !0;
  }
};
function jU(u) {
  u.dispose && u.type !== "Scene" && u.dispose();
  for (const e in u)
    e.dispose == null || e.dispose(), delete u[e];
}
function Yf(u, e) {
  const t = u;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, u;
}
function Gx(u, e) {
  let t = u;
  if (e.includes("-")) {
    const n = e.split("-"), r = n.pop();
    return t = n.reduce((s, c) => s[c], u), {
      target: t,
      key: r
    };
  } else
    return {
      target: t,
      key: e
    };
}
const aE = /-\d+$/;
function Y_(u, e, t) {
  if (Wn.str(t)) {
    if (aE.test(t)) {
      const s = t.replace(aE, ""), {
        target: c,
        key: f
      } = Gx(u, s);
      Array.isArray(c[f]) || (c[f] = []);
    }
    const {
      target: n,
      key: r
    } = Gx(u, t);
    e.__r3f.previousAttach = n[r], n[r] = e;
  } else
    e.__r3f.previousAttach = t(u, e);
}
function sE(u, e, t) {
  var n, r;
  if (Wn.str(t)) {
    const {
      target: s,
      key: c
    } = Gx(u, t), f = e.__r3f.previousAttach;
    f === void 0 ? delete s[c] : s[c] = f;
  } else
    (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(u, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function AC(u, {
  children: e,
  key: t,
  ref: n,
  ...r
}, {
  children: s,
  key: c,
  ref: f,
  ...h
} = {}, m = !1) {
  var g;
  const _ = (g = u == null ? void 0 : u.__r3f) != null ? g : {}, x = Object.entries(r), M = [];
  if (m) {
    const E = Object.keys(h);
    for (let w = 0; w < E.length; w++)
      r.hasOwnProperty(E[w]) || x.unshift([E[w], CC + "remove"]);
  }
  x.forEach(([E, w]) => {
    var R;
    if ((R = u.__r3f) != null && R.primitive && E === "object" || Wn.equ(w, h[E]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(E))
      return M.push([E, w, !0, []]);
    let A = [];
    E.includes("-") && (A = E.split("-")), M.push([E, w, !1, A]);
    for (const P in r) {
      const N = r[P];
      P.startsWith(`${E}-`) && M.push([P, N, !1, P.split("-")]);
    }
  });
  const b = {
    ...r
  };
  return _.memoizedProps && _.memoizedProps.args && (b.args = _.memoizedProps.args), _.memoizedProps && _.memoizedProps.attach && (b.attach = _.memoizedProps.attach), {
    memoized: b,
    changes: M
  };
}
const YU = typeof process < "u" && process.env.NODE_ENV !== "production";
function X_(u, e) {
  var t, n, r;
  const s = (t = u.__r3f) != null ? t : {}, c = s.root, f = (n = c == null || c.getState == null ? void 0 : c.getState()) != null ? n : {}, {
    memoized: h,
    changes: m
  } = qU(e) ? e : AC(u, e), g = s.eventCount;
  u.__r3f && (u.__r3f.memoizedProps = h);
  for (let x = 0; x < m.length; x++) {
    let [M, b, E, w] = m[x];
    if (j_(u)) {
      const N = "srgb", I = "srgb-linear";
      M === "encoding" ? (M = "colorSpace", b = b === 3001 ? N : I) : M === "outputEncoding" && (M = "outputColorSpace", b = b === 3001 ? N : I);
    }
    let R = u, A = R[M];
    if (w.length && (A = w.reduce((P, N) => P[N], u), !(A && A.set))) {
      const [P, ...N] = w.reverse();
      R = N.reverse().reduce((I, B) => I[B], u), M = P;
    }
    if (b === CC + "remove")
      if (R.constructor) {
        let P = rE.get(R.constructor);
        P || (P = new R.constructor(), rE.set(R.constructor, P)), b = P[M];
      } else
        b = 0;
    if (E)
      b ? s.handlers[M] = b : delete s.handlers[M], s.eventCount = Object.keys(s.handlers).length;
    else if (A && A.set && (A.copy || A instanceof rc)) {
      if (Array.isArray(b))
        A.fromArray ? A.fromArray(b) : A.set(...b);
      else if (A.copy && b && b.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (YU ? A.constructor.name === b.constructor.name : A.constructor === b.constructor))
        A.copy(b);
      else if (b !== void 0) {
        const P = A instanceof xt;
        !P && A.setScalar ? A.setScalar(b) : A instanceof rc && b instanceof rc ? A.mask = b.mask : A.set(b), !bC() && !f.linear && P && A.convertSRGBToLinear();
      }
    } else if (R[M] = b, R[M] instanceof Mi && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
    R[M].format === pa && R[M].type === Ro) {
      const P = R[M];
      j_(P) && j_(f.gl) ? P.colorSpace = f.gl.outputColorSpace : P.encoding = f.gl.outputEncoding;
    }
    Xf(u);
  }
  if (s.parent && f.internal && u.raycast && g !== s.eventCount) {
    const x = f.internal.interaction.indexOf(u);
    x > -1 && f.internal.interaction.splice(x, 1), s.eventCount && f.internal.interaction.push(u);
  }
  return !(m.length === 1 && m[0][0] === "onUpdate") && m.length && (r = u.__r3f) != null && r.parent && Wx(u), u;
}
function Xf(u) {
  var e, t;
  const n = (e = u.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function Wx(u) {
  u.onUpdate == null || u.onUpdate(u);
}
function XU(u, e) {
  u.manual || (wC(u) ? (u.left = e.width / -2, u.right = e.width / 2, u.top = e.height / 2, u.bottom = e.height / -2) : u.aspect = e.width / e.height, u.updateProjectionMatrix(), u.updateMatrixWorld());
}
function ug(u) {
  return (u.eventObject || u.object).uuid + "/" + u.index + u.instanceId;
}
function ZU() {
  var u;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e)
    return $f.DefaultEventPriority;
  switch ((u = e.event) == null ? void 0 : u.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return $f.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return $f.ContinuousEventPriority;
    default:
      return $f.DefaultEventPriority;
  }
}
function LC(u, e, t, n) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (u.delete(n), r.target.releasePointerCapture(n)));
}
function JU(u, e) {
  const {
    internal: t
  } = u.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, r) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((n, r) => {
    LC(t.capturedMap, e, n, r);
  });
}
function QU(u) {
  function e(h) {
    const {
      internal: m
    } = u.getState(), g = h.offsetX - m.initialClick[0], _ = h.offsetY - m.initialClick[1];
    return Math.round(Math.sqrt(g * g + _ * _));
  }
  function t(h) {
    return h.filter((m) => ["Move", "Over", "Enter", "Out", "Leave"].some((g) => {
      var _;
      return (_ = m.__r3f) == null ? void 0 : _.handlers["onPointer" + g];
    }));
  }
  function n(h, m) {
    const g = u.getState(), _ = /* @__PURE__ */ new Set(), x = [], M = m ? m(g.internal.interaction) : g.internal.interaction;
    for (let R = 0; R < M.length; R++) {
      const A = Wh(M[R]);
      A && (A.raycaster.camera = void 0);
    }
    g.previousRoot || g.events.compute == null || g.events.compute(h, g);
    function b(R) {
      const A = Wh(R);
      if (!A || !A.events.enabled || A.raycaster.camera === null)
        return [];
      if (A.raycaster.camera === void 0) {
        var P;
        A.events.compute == null || A.events.compute(h, A, (P = A.previousRoot) == null ? void 0 : P.getState()), A.raycaster.camera === void 0 && (A.raycaster.camera = null);
      }
      return A.raycaster.camera ? A.raycaster.intersectObject(R, !0) : [];
    }
    let E = M.flatMap(b).sort((R, A) => {
      const P = Wh(R.object), N = Wh(A.object);
      return !P || !N ? R.distance - A.distance : N.events.priority - P.events.priority || R.distance - A.distance;
    }).filter((R) => {
      const A = ug(R);
      return _.has(A) ? !1 : (_.add(A), !0);
    });
    g.events.filter && (E = g.events.filter(E, g));
    for (const R of E) {
      let A = R.object;
      for (; A; ) {
        var w;
        (w = A.__r3f) != null && w.eventCount && x.push({
          ...R,
          eventObject: A
        }), A = A.parent;
      }
    }
    if ("pointerId" in h && g.internal.capturedMap.has(h.pointerId))
      for (let R of g.internal.capturedMap.get(h.pointerId).values())
        _.has(ug(R.intersection)) || x.push(R.intersection);
    return x;
  }
  function r(h, m, g, _) {
    const x = u.getState();
    if (h.length) {
      const M = {
        stopped: !1
      };
      for (const b of h) {
        const E = Wh(b.object) || x, {
          raycaster: w,
          pointer: R,
          camera: A,
          internal: P
        } = E, N = new q(R.x, R.y, 0).unproject(A), I = (G) => {
          var $, oe;
          return ($ = (oe = P.capturedMap.get(G)) == null ? void 0 : oe.has(b.eventObject)) != null ? $ : !1;
        }, B = (G) => {
          const $ = {
            intersection: b,
            target: m.target
          };
          P.capturedMap.has(G) ? P.capturedMap.get(G).set(b.eventObject, $) : P.capturedMap.set(G, /* @__PURE__ */ new Map([[b.eventObject, $]])), m.target.setPointerCapture(G);
        }, W = (G) => {
          const $ = P.capturedMap.get(G);
          $ && LC(P.capturedMap, b.eventObject, $, G);
        };
        let z = {};
        for (let G in m) {
          let $ = m[G];
          typeof $ != "function" && (z[G] = $);
        }
        let k = {
          ...b,
          ...z,
          pointer: R,
          intersections: h,
          stopped: M.stopped,
          delta: g,
          unprojectedPoint: N,
          ray: w.ray,
          camera: A,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const G = "pointerId" in m && P.capturedMap.get(m.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!G || // ... or if the hit object is capturing the pointer
              G.has(b.eventObject)) && (k.stopped = M.stopped = !0, P.hovered.size && Array.from(P.hovered.values()).find(($) => $.eventObject === b.eventObject))
            ) {
              const $ = h.slice(0, h.indexOf(b));
              s([...$, b]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: I,
            setPointerCapture: B,
            releasePointerCapture: W
          },
          currentTarget: {
            hasPointerCapture: I,
            setPointerCapture: B,
            releasePointerCapture: W
          },
          nativeEvent: m
        };
        if (_(k), M.stopped === !0)
          break;
      }
    }
    return h;
  }
  function s(h) {
    const {
      internal: m
    } = u.getState();
    for (const g of m.hovered.values())
      if (!h.length || !h.find((_) => _.object === g.object && _.index === g.index && _.instanceId === g.instanceId)) {
        const x = g.eventObject.__r3f, M = x == null ? void 0 : x.handlers;
        if (m.hovered.delete(ug(g)), x != null && x.eventCount) {
          const b = {
            ...g,
            intersections: h
          };
          M.onPointerOut == null || M.onPointerOut(b), M.onPointerLeave == null || M.onPointerLeave(b);
        }
      }
  }
  function c(h, m) {
    for (let g = 0; g < m.length; g++) {
      const _ = m[g].__r3f;
      _ == null || _.handlers.onPointerMissed == null || _.handlers.onPointerMissed(h);
    }
  }
  function f(h) {
    switch (h) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (m) => {
          const {
            internal: g
          } = u.getState();
          "pointerId" in m && g.capturedMap.has(m.pointerId) && requestAnimationFrame(() => {
            g.capturedMap.has(m.pointerId) && (g.capturedMap.delete(m.pointerId), s([]));
          });
        };
    }
    return function(g) {
      const {
        onPointerMissed: _,
        internal: x
      } = u.getState();
      x.lastEvent.current = g;
      const M = h === "onPointerMove", b = h === "onClick" || h === "onContextMenu" || h === "onDoubleClick", w = n(g, M ? t : void 0), R = b ? e(g) : 0;
      h === "onPointerDown" && (x.initialClick = [g.offsetX, g.offsetY], x.initialHits = w.map((P) => P.eventObject)), b && !w.length && R <= 2 && (c(g, x.interaction), _ && _(g)), M && s(w);
      function A(P) {
        const N = P.eventObject, I = N.__r3f, B = I == null ? void 0 : I.handlers;
        if (I != null && I.eventCount)
          if (M) {
            if (B.onPointerOver || B.onPointerEnter || B.onPointerOut || B.onPointerLeave) {
              const W = ug(P), z = x.hovered.get(W);
              z ? z.stopped && P.stopPropagation() : (x.hovered.set(W, P), B.onPointerOver == null || B.onPointerOver(P), B.onPointerEnter == null || B.onPointerEnter(P));
            }
            B.onPointerMove == null || B.onPointerMove(P);
          } else {
            const W = B[h];
            W ? (!b || x.initialHits.includes(N)) && (c(g, x.interaction.filter((z) => !x.initialHits.includes(z))), W(P)) : b && x.initialHits.includes(N) && c(g, x.interaction.filter((z) => !x.initialHits.includes(z)));
          }
      }
      r(w, g, R, A);
    };
  }
  return {
    handlePointer: f
  };
}
const DC = (u) => !!(u != null && u.render), PC = /* @__PURE__ */ Yt.createContext(null), KU = (u, e) => {
  const t = NU((f, h) => {
    const m = new q(), g = new q(), _ = new q();
    function x(R = h().camera, A = g, P = h().size) {
      const {
        width: N,
        height: I,
        top: B,
        left: W
      } = P, z = N / I;
      A instanceof q ? _.copy(A) : _.set(...A);
      const k = R.getWorldPosition(m).distanceTo(_);
      if (wC(R))
        return {
          width: N / R.zoom,
          height: I / R.zoom,
          top: B,
          left: W,
          factor: 1,
          distance: k,
          aspect: z
        };
      {
        const G = R.fov * Math.PI / 180, $ = 2 * Math.tan(G / 2) * k, oe = $ * (N / I);
        return {
          width: oe,
          height: $,
          top: B,
          left: W,
          factor: N / oe,
          distance: k,
          aspect: z
        };
      }
    }
    let M;
    const b = (R) => f((A) => ({
      performance: {
        ...A.performance,
        current: R
      }
    })), E = new Ue();
    return {
      set: f,
      get: h,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (R = 1) => u(h(), R),
      advance: (R, A) => e(R, A, h()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new bS(),
      pointer: E,
      mouse: E,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const R = h();
          M && clearTimeout(M), R.performance.current !== R.performance.min && b(R.performance.min), M = setTimeout(() => b(h().performance.max), R.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: x
      },
      setEvents: (R) => f((A) => ({
        ...A,
        events: {
          ...A.events,
          ...R
        }
      })),
      setSize: (R, A, P, N, I) => {
        const B = h().camera, W = {
          width: R,
          height: A,
          top: N || 0,
          left: I || 0,
          updateStyle: P
        };
        f((z) => ({
          size: W,
          viewport: {
            ...z.viewport,
            ...x(B, g, W)
          }
        }));
      },
      setDpr: (R) => f((A) => {
        const P = RC(R);
        return {
          viewport: {
            ...A.viewport,
            dpr: P,
            initialDpr: A.viewport.initialDpr || P
          }
        };
      }),
      setFrameloop: (R = "always") => {
        const A = h().clock;
        A.stop(), A.elapsedTime = 0, R !== "never" && (A.start(), A.elapsedTime = 0), f(() => ({
          frameloop: R
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Yt.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (R, A, P) => {
          const N = h().internal;
          return N.priority = N.priority + (A > 0 ? 1 : 0), N.subscribers.push({
            ref: R,
            priority: A,
            store: P
          }), N.subscribers = N.subscribers.sort((I, B) => I.priority - B.priority), () => {
            const I = h().internal;
            I != null && I.subscribers && (I.priority = I.priority - (A > 0 ? 1 : 0), I.subscribers = I.subscribers.filter((B) => B.ref !== R));
          };
        }
      }
    };
  }), n = t.getState();
  let r = n.size, s = n.viewport.dpr, c = n.camera;
  return t.subscribe(() => {
    const {
      camera: f,
      size: h,
      viewport: m,
      gl: g,
      set: _
    } = t.getState();
    if (h.width !== r.width || h.height !== r.height || m.dpr !== s) {
      var x;
      r = h, s = m.dpr, XU(f, h), g.setPixelRatio(m.dpr);
      const M = (x = h.updateStyle) != null ? x : typeof HTMLCanvasElement < "u" && g.domElement instanceof HTMLCanvasElement;
      g.setSize(h.width, h.height, M);
    }
    f !== c && (c = f, _((M) => ({
      viewport: {
        ...M.viewport,
        ...M.viewport.getCurrentViewport(f)
      }
    })));
  }), t.subscribe((f) => u(f)), t;
};
let cg, $U = /* @__PURE__ */ new Set(), eF = /* @__PURE__ */ new Set(), tF = /* @__PURE__ */ new Set();
function Z_(u, e) {
  if (u.size)
    for (const {
      callback: t
    } of u.values())
      t(e);
}
function qh(u, e) {
  switch (u) {
    case "before":
      return Z_($U, e);
    case "after":
      return Z_(eF, e);
    case "tail":
      return Z_(tF, e);
  }
}
let J_, Q_;
function K_(u, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof u == "number" && (n = u - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = u), J_ = e.internal.subscribers, cg = 0; cg < J_.length; cg++)
    Q_ = J_[cg], Q_.ref.current(Q_.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function nF(u) {
  let e = !1, t, n, r;
  function s(h) {
    n = requestAnimationFrame(s), e = !0, t = 0, qh("before", h);
    for (const g of u.values()) {
      var m;
      r = g.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((m = r.gl.xr) != null && m.isPresenting) && (t += K_(h, r));
    }
    if (qh("after", h), t === 0)
      return qh("tail", h), e = !1, cancelAnimationFrame(n);
  }
  function c(h, m = 1) {
    var g;
    if (!h)
      return u.forEach((_) => c(_.store.getState()), m);
    (g = h.gl.xr) != null && g.isPresenting || !h.internal.active || h.frameloop === "never" || (h.internal.frames = Math.min(60, h.internal.frames + m), e || (e = !0, requestAnimationFrame(s)));
  }
  function f(h, m = !0, g, _) {
    if (m && qh("before", h), g)
      K_(h, g, _);
    else
      for (const x of u.values())
        K_(h, x.store.getState());
    m && qh("after", h);
  }
  return {
    loop: s,
    /**
     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate
     */
    invalidate: c,
    /**
     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop="never"`.
     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance
     */
    advance: f
  };
}
function NC() {
  const u = Yt.useContext(PC);
  if (!u)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return u;
}
function iF(u = (t) => t, e) {
  return NC()(u, e);
}
function rF(u, e = 0) {
  const t = NC(), n = t.getState().internal.subscribe, r = EC(u);
  return zp(() => n(r, e, t), [e, n, t]), null;
}
const rd = /* @__PURE__ */ new Map(), {
  invalidate: oE,
  advance: lE
} = nF(rd), {
  reconciler: Eg,
  applyProps: qf
} = VU(rd, ZU), jf = {
  objects: "shallow",
  strict: !1
}, aF = (u, e) => {
  const t = typeof u == "function" ? u(e) : u;
  return DC(t) ? t : new aS({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...u
  });
};
function sF(u, e) {
  const t = typeof HTMLCanvasElement < "u" && u instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: r,
      top: s,
      left: c,
      updateStyle: f = t
    } = e;
    return {
      width: n,
      height: r,
      top: s,
      left: c,
      updateStyle: f
    };
  } else if (typeof HTMLCanvasElement < "u" && u instanceof HTMLCanvasElement && u.parentElement) {
    const {
      width: n,
      height: r,
      top: s,
      left: c
    } = u.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: r,
      top: s,
      left: c,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && u instanceof OffscreenCanvas)
    return {
      width: u.width,
      height: u.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function oF(u) {
  const e = rd.get(u), t = e == null ? void 0 : e.fiber, n = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), s = n || KU(oE, lE), c = t || Eg.createContainer(s, $f.ConcurrentRoot, null, !1, null, "", r, null);
  e || rd.set(u, {
    fiber: c,
    store: s
  });
  let f, h = !1, m;
  return {
    configure(g = {}) {
      let {
        gl: _,
        size: x,
        scene: M,
        events: b,
        onCreated: E,
        shadows: w = !1,
        linear: R = !1,
        flat: A = !1,
        legacy: P = !1,
        orthographic: N = !1,
        frameloop: I = "always",
        dpr: B = [1, 2],
        performance: W,
        raycaster: z,
        camera: k,
        onPointerMissed: G
      } = g, $ = s.getState(), oe = $.gl;
      $.gl || $.set({
        gl: oe = aF(_, u)
      });
      let ne = $.raycaster;
      ne || $.set({
        raycaster: ne = new _C()
      });
      const {
        params: ee,
        ...ye
      } = z || {};
      if (Wn.equ(ye, ne, jf) || qf(ne, {
        ...ye
      }), Wn.equ(ee, ne.params, jf) || qf(ne, {
        params: {
          ...ne.params,
          ...ee
        }
      }), !$.camera || $.camera === m && !Wn.equ(m, k, jf)) {
        m = k;
        const le = k instanceof yp, Pe = le ? k : N ? new xp(0, 0, 0, 0, 0.1, 1e3) : new Vi(75, 0, 0.1, 1e3);
        le || (Pe.position.z = 5, k && qf(Pe, k), !$.camera && !(k != null && k.rotation) && Pe.lookAt(0, 0, 0)), $.set({
          camera: Pe
        }), ne.camera = Pe;
      }
      if (!$.scene) {
        let le;
        M instanceof wg ? le = M : (le = new wg(), M && qf(le, M)), $.set({
          scene: Yf(le)
        });
      }
      if (!$.xr) {
        var Me;
        const le = ($e, ve) => {
          const gt = s.getState();
          gt.frameloop !== "never" && lE($e, !0, gt, ve);
        }, Pe = () => {
          const $e = s.getState();
          $e.gl.xr.enabled = $e.gl.xr.isPresenting, $e.gl.xr.setAnimationLoop($e.gl.xr.isPresenting ? le : null), $e.gl.xr.isPresenting || oE($e);
        }, We = {
          connect() {
            const $e = s.getState().gl;
            $e.xr.addEventListener("sessionstart", Pe), $e.xr.addEventListener("sessionend", Pe);
          },
          disconnect() {
            const $e = s.getState().gl;
            $e.xr.removeEventListener("sessionstart", Pe), $e.xr.removeEventListener("sessionend", Pe);
          }
        };
        typeof ((Me = oe.xr) == null ? void 0 : Me.addEventListener) == "function" && We.connect(), $.set({
          xr: We
        });
      }
      if (oe.shadowMap) {
        const le = oe.shadowMap.enabled, Pe = oe.shadowMap.type;
        if (oe.shadowMap.enabled = !!w, Wn.boo(w))
          oe.shadowMap.type = Yh;
        else if (Wn.str(w)) {
          var De;
          const We = {
            basic: SE,
            percentage: Ag,
            soft: Yh,
            variance: Xu
          };
          oe.shadowMap.type = (De = We[w]) != null ? De : Yh;
        } else
          Wn.obj(w) && Object.assign(oe.shadowMap, w);
        (le !== oe.shadowMap.enabled || Pe !== oe.shadowMap.type) && (oe.shadowMap.needsUpdate = !0);
      }
      const V = bC();
      V && ("enabled" in V ? V.enabled = !P : "legacyMode" in V && (V.legacyMode = P)), qf(oe, {
        outputEncoding: R ? 3e3 : 3001,
        toneMapping: A ? ds : Xx
      }), $.legacy !== P && $.set(() => ({
        legacy: P
      })), $.linear !== R && $.set(() => ({
        linear: R
      })), $.flat !== A && $.set(() => ({
        flat: A
      })), _ && !Wn.fun(_) && !DC(_) && !Wn.equ(_, oe, jf) && qf(oe, _), b && !$.events.handlers && $.set({
        events: b(s)
      });
      const de = sF(u, x);
      return Wn.equ(de, $.size, jf) || $.setSize(de.width, de.height, de.updateStyle, de.top, de.left), B && $.viewport.dpr !== RC(B) && $.setDpr(B), $.frameloop !== I && $.setFrameloop(I), $.onPointerMissed || $.set({
        onPointerMissed: G
      }), W && !Wn.equ(W, $.performance, jf) && $.set((le) => ({
        performance: {
          ...le.performance,
          ...W
        }
      })), f = E, h = !0, this;
    },
    render(g) {
      return h || this.configure(), Eg.updateContainer(/* @__PURE__ */ Yt.createElement(lF, {
        store: s,
        children: g,
        onCreated: f,
        rootElement: u
      }), c, null, () => {
      }), s;
    },
    unmount() {
      zC(u);
    }
  };
}
function lF({
  store: u,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return zp(() => {
    const r = u.getState();
    r.set((s) => ({
      internal: {
        ...s.internal,
        active: !0
      }
    })), t && t(r), u.getState().events.connected || r.events.connect == null || r.events.connect(n);
  }, []), /* @__PURE__ */ Yt.createElement(PC.Provider, {
    value: u
  }, e);
}
function zC(u, e) {
  const t = rd.get(u), n = t == null ? void 0 : t.fiber;
  if (n) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1), Eg.updateContainer(null, n, null, () => {
      r && setTimeout(() => {
        try {
          var s, c, f, h;
          r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (c = s.renderLists) == null || c.dispose == null || c.dispose(), (f = r.gl) == null || f.forceContextLoss == null || f.forceContextLoss(), (h = r.gl) != null && h.xr && r.xr.disconnect(), jU(r), rd.delete(u), e && e(u);
        } catch {
        }
      }, 500);
    });
  }
}
Eg.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Yt.version
});
function Tg() {
  return Tg = Object.assign ? Object.assign.bind() : function(u) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (u[n] = t[n]);
    }
    return u;
  }, Tg.apply(this, arguments);
}
function qx(u, e, t) {
  var n, r, s, c, f;
  e == null && (e = 100);
  function h() {
    var g = Date.now() - c;
    g < e && g >= 0 ? n = setTimeout(h, e - g) : (n = null, t || (f = u.apply(s, r), s = r = null));
  }
  var m = function() {
    s = this, r = arguments, c = Date.now();
    var g = t && !n;
    return n || (n = setTimeout(h, e)), g && (f = u.apply(s, r), s = r = null), f;
  };
  return m.clear = function() {
    n && (clearTimeout(n), n = null);
  }, m.flush = function() {
    n && (f = u.apply(s, r), s = r = null, clearTimeout(n), n = null);
  }, m;
}
qx.debounce = qx;
var uF = qx;
const uE = /* @__PURE__ */ yE(uF);
function cF(u) {
  let {
    debounce: e,
    scroll: t,
    polyfill: n,
    offsetSize: r
  } = u === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : u;
  const s = n || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!s)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [c, f] = b2({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), h = Us({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: c
  }), m = e ? typeof e == "number" ? e : e.scroll : null, g = e ? typeof e == "number" ? e : e.resize : null, _ = Us(!1);
  $u(() => (_.current = !0, () => void (_.current = !1)));
  const [x, M, b] = gE(() => {
    const A = () => {
      if (!h.current.element)
        return;
      const {
        left: P,
        top: N,
        width: I,
        height: B,
        bottom: W,
        right: z,
        x: k,
        y: G
      } = h.current.element.getBoundingClientRect(), $ = {
        left: P,
        top: N,
        width: I,
        height: B,
        bottom: W,
        right: z,
        x: k,
        y: G
      };
      h.current.element instanceof HTMLElement && r && ($.height = h.current.element.offsetHeight, $.width = h.current.element.offsetWidth), Object.freeze($), _.current && !pF(h.current.lastBounds, $) && f(h.current.lastBounds = $);
    };
    return [A, g ? uE(A, g) : A, m ? uE(A, m) : A];
  }, [f, r, m, g]);
  function E() {
    h.current.scrollContainers && (h.current.scrollContainers.forEach((A) => A.removeEventListener("scroll", b, !0)), h.current.scrollContainers = null), h.current.resizeObserver && (h.current.resizeObserver.disconnect(), h.current.resizeObserver = null);
  }
  function w() {
    h.current.element && (h.current.resizeObserver = new s(b), h.current.resizeObserver.observe(h.current.element), t && h.current.scrollContainers && h.current.scrollContainers.forEach((A) => A.addEventListener("scroll", b, {
      capture: !0,
      passive: !0
    })));
  }
  const R = (A) => {
    !A || A === h.current.element || (E(), h.current.element = A, h.current.scrollContainers = OC(A), w());
  };
  return dF(b, !!t), fF(M), $u(() => {
    E(), w();
  }, [t, b, M]), $u(() => E, []), [R, c, x];
}
function fF(u) {
  $u(() => {
    const e = u;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [u]);
}
function dF(u, e) {
  $u(() => {
    if (e) {
      const t = u;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [u, e]);
}
function OC(u) {
  const e = [];
  if (!u || u === document.body)
    return e;
  const {
    overflow: t,
    overflowX: n,
    overflowY: r
  } = window.getComputedStyle(u);
  return [t, n, r].some((s) => s === "auto" || s === "scroll") && e.push(u), [...e, ...OC(u.parentElement)];
}
const hF = ["x", "y", "top", "bottom", "left", "right", "width", "height"], pF = (u, e) => hF.every((t) => u[t] === e[t]);
var mF = Object.defineProperty, vF = Object.defineProperties, gF = Object.getOwnPropertyDescriptors, cE = Object.getOwnPropertySymbols, yF = Object.prototype.hasOwnProperty, _F = Object.prototype.propertyIsEnumerable, fE = (u, e, t) => e in u ? mF(u, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : u[e] = t, dE = (u, e) => {
  for (var t in e || (e = {}))
    yF.call(e, t) && fE(u, t, e[t]);
  if (cE)
    for (var t of cE(e))
      _F.call(e, t) && fE(u, t, e[t]);
  return u;
}, xF = (u, e) => vF(u, gF(e));
function IC(u, e, t) {
  if (!u)
    return;
  if (t(u) === !0)
    return u;
  let n = e ? u.return : u.child;
  for (; n; ) {
    const r = IC(n, e, t);
    if (r)
      return r;
    n = e ? null : n.sibling;
  }
}
function UC(u) {
  try {
    return Object.defineProperties(u, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return u;
  }
}
const RS = UC(Yt.createContext(null));
class FC extends Yt.Component {
  render() {
    return /* @__PURE__ */ Yt.createElement(RS.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
const { ReactCurrentOwner: hE, ReactCurrentDispatcher: pE } = Yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function SF() {
  const u = Yt.useContext(RS);
  if (u === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = Yt.useId();
  return Yt.useMemo(() => {
    for (const n of [hE == null ? void 0 : hE.current, u, u == null ? void 0 : u.alternate]) {
      if (!n)
        continue;
      const r = IC(n, !1, (s) => {
        let c = s.memoizedState;
        for (; c; ) {
          if (c.memoizedState === e)
            return !0;
          c = c.next;
        }
      });
      if (r)
        return r;
    }
  }, [u, e]);
}
function MF() {
  var u, e;
  const t = SF(), [n] = Yt.useState(() => /* @__PURE__ */ new Map());
  n.clear();
  let r = t;
  for (; r; ) {
    const s = (u = r.type) == null ? void 0 : u._context;
    s && s !== RS && !n.has(s) && n.set(s, (e = pE == null ? void 0 : pE.current) == null ? void 0 : e.readContext(UC(s))), r = r.return;
  }
  return n;
}
function bF() {
  const u = MF();
  return Yt.useMemo(
    () => Array.from(u.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ Yt.createElement(e, null, /* @__PURE__ */ Yt.createElement(t.Provider, xF(dE({}, n), {
        value: u.get(t)
      }))),
      (e) => /* @__PURE__ */ Yt.createElement(FC, dE({}, e))
    ),
    [u]
  );
}
const $_ = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function wF(u) {
  const {
    handlePointer: e
  } = QU(u);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, r) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys($_).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: r
      } = u.getState();
      (t = r.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: r,
        events: s
      } = u.getState();
      s.disconnect == null || s.disconnect(), r((c) => ({
        events: {
          ...c.events,
          connected: t
        }
      })), Object.entries((n = s.handlers) != null ? n : []).forEach(([c, f]) => {
        const [h, m] = $_[c];
        t.addEventListener(h, f, {
          passive: m
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = u.getState();
      if (n.connected) {
        var r;
        Object.entries((r = n.handlers) != null ? r : []).forEach(([s, c]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [f] = $_[s];
            n.connected.removeEventListener(f, c);
          }
        }), t((s) => ({
          events: {
            ...s.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const EF = /* @__PURE__ */ Yt.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: r,
  gl: s,
  events: c = wF,
  eventSource: f,
  eventPrefix: h,
  shadows: m,
  linear: g,
  flat: _,
  legacy: x,
  orthographic: M,
  frameloop: b,
  dpr: E,
  performance: w,
  raycaster: R,
  camera: A,
  scene: P,
  onPointerMissed: N,
  onCreated: I,
  ...B
}, W) {
  Yt.useMemo(() => MC(RU), []);
  const z = bF(), [k, G] = cF({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), $ = Yt.useRef(null), oe = Yt.useRef(null);
  Yt.useImperativeHandle(W, () => $.current);
  const ne = EC(N), [ee, ye] = Yt.useState(!1), [Me, De] = Yt.useState(!1);
  if (ee)
    throw ee;
  if (Me)
    throw Me;
  const V = Yt.useRef(null);
  zp(() => {
    const Y = $.current;
    G.width > 0 && G.height > 0 && Y && (V.current || (V.current = oF(Y)), V.current.configure({
      gl: s,
      events: c,
      shadows: m,
      linear: g,
      flat: _,
      legacy: x,
      orthographic: M,
      frameloop: b,
      dpr: E,
      performance: w,
      raycaster: R,
      camera: A,
      scene: P,
      size: G,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...de) => ne.current == null ? void 0 : ne.current(...de),
      onCreated: (de) => {
        de.events.connect == null || de.events.connect(f ? GU(f) ? f.current : f : oe.current), h && de.setEvents({
          compute: (le, Pe) => {
            const We = le[h + "X"], $e = le[h + "Y"];
            Pe.pointer.set(We / Pe.size.width * 2 - 1, -($e / Pe.size.height) * 2 + 1), Pe.raycaster.setFromCamera(Pe.pointer, Pe.camera);
          }
        }), I == null || I(de);
      }
    }), V.current.render(/* @__PURE__ */ Yt.createElement(z, null, /* @__PURE__ */ Yt.createElement(TC, {
      set: De
    }, /* @__PURE__ */ Yt.createElement(Yt.Suspense, {
      fallback: /* @__PURE__ */ Yt.createElement(WU, {
        set: ye
      })
    }, e)))));
  }), Yt.useEffect(() => {
    const Y = $.current;
    if (Y)
      return () => zC(Y);
  }, []);
  const J = f ? "none" : "auto";
  return /* @__PURE__ */ Yt.createElement("div", Tg({
    ref: oe,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: J,
      ...r
    }
  }, B), /* @__PURE__ */ Yt.createElement("div", {
    ref: k,
    style: {
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ Yt.createElement("canvas", {
    ref: $,
    style: {
      display: "block"
    }
  }, t)));
}), TF = /* @__PURE__ */ Yt.forwardRef(function(e, t) {
  return /* @__PURE__ */ Yt.createElement(FC, null, /* @__PURE__ */ Yt.createElement(EF, Tg({}, e, {
    ref: t
  })));
}), mE = { type: "change" }, ex = { type: "start" }, vE = { type: "end" };
class CF extends ks {
  constructor(e, t) {
    super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new q(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: Gu.ROTATE, MIDDLE: Gu.DOLLY, RIGHT: Gu.PAN }, this.touches = { ONE: Wu.ROTATE, TWO: Wu.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return f.phi;
    }, this.getAzimuthalAngle = function() {
      return f.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(te) {
      te.addEventListener("keydown", Gt), this._domElementKeyEvents = te;
    }, this.saveState = function() {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = function() {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(mE), n.update(), s = r.NONE;
    }, this.update = function() {
      const te = new q(), he = new mr().setFromUnitVectors(e.up, new q(0, 1, 0)), ae = he.clone().invert(), pe = new q(), Ee = new mr(), He = 2 * Math.PI;
      return function() {
        const Tt = n.object.position;
        te.copy(Tt).sub(n.target), te.applyQuaternion(he), f.setFromVector3(te), n.autoRotate && s === r.NONE && k(W()), n.enableDamping ? (f.theta += h.theta * n.dampingFactor, f.phi += h.phi * n.dampingFactor) : (f.theta += h.theta, f.phi += h.phi);
        let ie = n.minAzimuthAngle, Re = n.maxAzimuthAngle;
        return isFinite(ie) && isFinite(Re) && (ie < -Math.PI ? ie += He : ie > Math.PI && (ie -= He), Re < -Math.PI ? Re += He : Re > Math.PI && (Re -= He), ie <= Re ? f.theta = Math.max(ie, Math.min(Re, f.theta)) : f.theta = f.theta > (ie + Re) / 2 ? Math.max(ie, f.theta) : Math.min(Re, f.theta)), f.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= m, f.radius = Math.max(n.minDistance, Math.min(n.maxDistance, f.radius)), n.enableDamping === !0 ? n.target.addScaledVector(g, n.dampingFactor) : n.target.add(g), te.setFromSpherical(f), te.applyQuaternion(ae), Tt.copy(n.target).add(te), n.object.lookAt(n.target), n.enableDamping === !0 ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, g.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), g.set(0, 0, 0)), m = 1, _ || pe.distanceToSquared(n.object.position) > c || 8 * (1 - Ee.dot(n.object.quaternion)) > c ? (n.dispatchEvent(mE), pe.copy(n.object.position), Ee.copy(n.object.quaternion), _ = !1, !0) : !1;
      };
    }(), this.dispose = function() {
      n.domElement.removeEventListener("contextmenu", be), n.domElement.removeEventListener("pointerdown", ke), n.domElement.removeEventListener("pointercancel", wt), n.domElement.removeEventListener("wheel", kt), n.domElement.removeEventListener("pointermove", rt), n.domElement.removeEventListener("pointerup", Xe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Gt);
    };
    const n = this, r = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let s = r.NONE;
    const c = 1e-6, f = new Bx(), h = new Bx();
    let m = 1;
    const g = new q();
    let _ = !1;
    const x = new Ue(), M = new Ue(), b = new Ue(), E = new Ue(), w = new Ue(), R = new Ue(), A = new Ue(), P = new Ue(), N = new Ue(), I = [], B = {};
    function W() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function z() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function k(te) {
      h.theta -= te;
    }
    function G(te) {
      h.phi -= te;
    }
    const $ = function() {
      const te = new q();
      return function(ae, pe) {
        te.setFromMatrixColumn(pe, 0), te.multiplyScalar(-ae), g.add(te);
      };
    }(), oe = function() {
      const te = new q();
      return function(ae, pe) {
        n.screenSpacePanning === !0 ? te.setFromMatrixColumn(pe, 1) : (te.setFromMatrixColumn(pe, 0), te.crossVectors(n.object.up, te)), te.multiplyScalar(ae), g.add(te);
      };
    }(), ne = function() {
      const te = new q();
      return function(ae, pe) {
        const Ee = n.domElement;
        if (n.object.isPerspectiveCamera) {
          const He = n.object.position;
          te.copy(He).sub(n.target);
          let Fe = te.length();
          Fe *= Math.tan(n.object.fov / 2 * Math.PI / 180), $(2 * ae * Fe / Ee.clientHeight, n.object.matrix), oe(2 * pe * Fe / Ee.clientHeight, n.object.matrix);
        } else
          n.object.isOrthographicCamera ? ($(ae * (n.object.right - n.object.left) / n.object.zoom / Ee.clientWidth, n.object.matrix), oe(pe * (n.object.top - n.object.bottom) / n.object.zoom / Ee.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    }();
    function ee(te) {
      n.object.isPerspectiveCamera ? m /= te : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * te)), n.object.updateProjectionMatrix(), _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function ye(te) {
      n.object.isPerspectiveCamera ? m *= te : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / te)), n.object.updateProjectionMatrix(), _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function Me(te) {
      x.set(te.clientX, te.clientY);
    }
    function De(te) {
      A.set(te.clientX, te.clientY);
    }
    function V(te) {
      E.set(te.clientX, te.clientY);
    }
    function J(te) {
      M.set(te.clientX, te.clientY), b.subVectors(M, x).multiplyScalar(n.rotateSpeed);
      const he = n.domElement;
      k(2 * Math.PI * b.x / he.clientHeight), G(2 * Math.PI * b.y / he.clientHeight), x.copy(M), n.update();
    }
    function Y(te) {
      P.set(te.clientX, te.clientY), N.subVectors(P, A), N.y > 0 ? ee(z()) : N.y < 0 && ye(z()), A.copy(P), n.update();
    }
    function de(te) {
      w.set(te.clientX, te.clientY), R.subVectors(w, E).multiplyScalar(n.panSpeed), ne(R.x, R.y), E.copy(w), n.update();
    }
    function le(te) {
      te.deltaY < 0 ? ye(z()) : te.deltaY > 0 && ee(z()), n.update();
    }
    function Pe(te) {
      let he = !1;
      switch (te.code) {
        case n.keys.UP:
          ne(0, n.keyPanSpeed), he = !0;
          break;
        case n.keys.BOTTOM:
          ne(0, -n.keyPanSpeed), he = !0;
          break;
        case n.keys.LEFT:
          ne(n.keyPanSpeed, 0), he = !0;
          break;
        case n.keys.RIGHT:
          ne(-n.keyPanSpeed, 0), he = !0;
          break;
      }
      he && (te.preventDefault(), n.update());
    }
    function We() {
      if (I.length === 1)
        x.set(I[0].pageX, I[0].pageY);
      else {
        const te = 0.5 * (I[0].pageX + I[1].pageX), he = 0.5 * (I[0].pageY + I[1].pageY);
        x.set(te, he);
      }
    }
    function $e() {
      if (I.length === 1)
        E.set(I[0].pageX, I[0].pageY);
      else {
        const te = 0.5 * (I[0].pageX + I[1].pageX), he = 0.5 * (I[0].pageY + I[1].pageY);
        E.set(te, he);
      }
    }
    function ve() {
      const te = I[0].pageX - I[1].pageX, he = I[0].pageY - I[1].pageY, ae = Math.sqrt(te * te + he * he);
      A.set(0, ae);
    }
    function gt() {
      n.enableZoom && ve(), n.enablePan && $e();
    }
    function ot() {
      n.enableZoom && ve(), n.enableRotate && We();
    }
    function _t(te) {
      if (I.length == 1)
        M.set(te.pageX, te.pageY);
      else {
        const ae = Et(te), pe = 0.5 * (te.pageX + ae.x), Ee = 0.5 * (te.pageY + ae.y);
        M.set(pe, Ee);
      }
      b.subVectors(M, x).multiplyScalar(n.rotateSpeed);
      const he = n.domElement;
      k(2 * Math.PI * b.x / he.clientHeight), G(2 * Math.PI * b.y / he.clientHeight), x.copy(M);
    }
    function Qe(te) {
      if (I.length === 1)
        w.set(te.pageX, te.pageY);
      else {
        const he = Et(te), ae = 0.5 * (te.pageX + he.x), pe = 0.5 * (te.pageY + he.y);
        w.set(ae, pe);
      }
      R.subVectors(w, E).multiplyScalar(n.panSpeed), ne(R.x, R.y), E.copy(w);
    }
    function At(te) {
      const he = Et(te), ae = te.pageX - he.x, pe = te.pageY - he.y, Ee = Math.sqrt(ae * ae + pe * pe);
      P.set(0, Ee), N.set(0, Math.pow(P.y / A.y, n.zoomSpeed)), ee(N.y), A.copy(P);
    }
    function Ne(te) {
      n.enableZoom && At(te), n.enablePan && Qe(te);
    }
    function we(te) {
      n.enableZoom && At(te), n.enableRotate && _t(te);
    }
    function ke(te) {
      n.enabled !== !1 && (I.length === 0 && (n.domElement.setPointerCapture(te.pointerId), n.domElement.addEventListener("pointermove", rt), n.domElement.addEventListener("pointerup", Xe)), qe(te), te.pointerType === "touch" ? X(te) : St(te));
    }
    function rt(te) {
      n.enabled !== !1 && (te.pointerType === "touch" ? H(te) : pt(te));
    }
    function Xe(te) {
      Ye(te), I.length === 0 && (n.domElement.releasePointerCapture(te.pointerId), n.domElement.removeEventListener("pointermove", rt), n.domElement.removeEventListener("pointerup", Xe)), n.dispatchEvent(vE), s = r.NONE;
    }
    function wt(te) {
      Ye(te);
    }
    function St(te) {
      let he;
      switch (te.button) {
        case 0:
          he = n.mouseButtons.LEFT;
          break;
        case 1:
          he = n.mouseButtons.MIDDLE;
          break;
        case 2:
          he = n.mouseButtons.RIGHT;
          break;
        default:
          he = -1;
      }
      switch (he) {
        case Gu.DOLLY:
          if (n.enableZoom === !1)
            return;
          De(te), s = r.DOLLY;
          break;
        case Gu.ROTATE:
          if (te.ctrlKey || te.metaKey || te.shiftKey) {
            if (n.enablePan === !1)
              return;
            V(te), s = r.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            Me(te), s = r.ROTATE;
          }
          break;
        case Gu.PAN:
          if (te.ctrlKey || te.metaKey || te.shiftKey) {
            if (n.enableRotate === !1)
              return;
            Me(te), s = r.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            V(te), s = r.PAN;
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && n.dispatchEvent(ex);
    }
    function pt(te) {
      switch (s) {
        case r.ROTATE:
          if (n.enableRotate === !1)
            return;
          J(te);
          break;
        case r.DOLLY:
          if (n.enableZoom === !1)
            return;
          Y(te);
          break;
        case r.PAN:
          if (n.enablePan === !1)
            return;
          de(te);
          break;
      }
    }
    function kt(te) {
      n.enabled === !1 || n.enableZoom === !1 || s !== r.NONE || (te.preventDefault(), n.dispatchEvent(ex), le(te), n.dispatchEvent(vE));
    }
    function Gt(te) {
      n.enabled === !1 || n.enablePan === !1 || Pe(te);
    }
    function X(te) {
      switch (Ke(te), I.length) {
        case 1:
          switch (n.touches.ONE) {
            case Wu.ROTATE:
              if (n.enableRotate === !1)
                return;
              We(), s = r.TOUCH_ROTATE;
              break;
            case Wu.PAN:
              if (n.enablePan === !1)
                return;
              $e(), s = r.TOUCH_PAN;
              break;
            default:
              s = r.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Wu.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              gt(), s = r.TOUCH_DOLLY_PAN;
              break;
            case Wu.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              ot(), s = r.TOUCH_DOLLY_ROTATE;
              break;
            default:
              s = r.NONE;
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && n.dispatchEvent(ex);
    }
    function H(te) {
      switch (Ke(te), s) {
        case r.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          _t(te), n.update();
          break;
        case r.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          Qe(te), n.update();
          break;
        case r.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          Ne(te), n.update();
          break;
        case r.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          we(te), n.update();
          break;
        default:
          s = r.NONE;
      }
    }
    function be(te) {
      n.enabled !== !1 && te.preventDefault();
    }
    function qe(te) {
      I.push(te);
    }
    function Ye(te) {
      delete B[te.pointerId];
      for (let he = 0; he < I.length; he++)
        if (I[he].pointerId == te.pointerId) {
          I.splice(he, 1);
          return;
        }
    }
    function Ke(te) {
      let he = B[te.pointerId];
      he === void 0 && (he = new Ue(), B[te.pointerId] = he), he.set(te.pageX, te.pageY);
    }
    function Et(te) {
      const he = te.pointerId === I[0].pointerId ? I[1] : I[0];
      return B[he.pointerId];
    }
    n.domElement.addEventListener("contextmenu", be), n.domElement.addEventListener("pointerdown", ke), n.domElement.addEventListener("pointercancel", wt), n.domElement.addEventListener("wheel", kt, { passive: !1 }), this.update();
  }
}
function RF() {
  const e = Us();
  $u(() => {
    e.current.computeVertexNormals();
  }, []);
  const t = gE(() => {
    const n = new Float32Array(270);
    for (let r = 0; r < 90 * 3; r++)
      n[r] = (Math.random() - 0.5) * 3;
    return n;
  }, []);
  return /* @__PURE__ */ si.jsxs("mesh", { children: [
    /* @__PURE__ */ si.jsx("bufferGeometry", { ref: e, children: /* @__PURE__ */ si.jsx(
      "bufferAttribute",
      {
        attach: "attributes-position",
        count: 90,
        itemSize: 3,
        array: t
      }
    ) }),
    /* @__PURE__ */ si.jsx("meshBasicMaterial", { color: "red", side: Fs })
  ] });
}
MC({ OrbitControls: CF });
function AF() {
  const { camera: u, gl: e } = iF(), t = Us();
  return rF((n, r) => {
    t.current.rotation.y += r;
  }), /* @__PURE__ */ si.jsxs(si.Fragment, { children: [
    /* @__PURE__ */ si.jsx("directionalLight", { position: [1, 2, 3], intensity: 1.5 }),
    /* @__PURE__ */ si.jsx("ambientLight", { intensity: 0.5 }),
    /* @__PURE__ */ si.jsx(RF, {}),
    /* @__PURE__ */ si.jsx("orbitControls", { args: [u, e.domElement] }),
    /* @__PURE__ */ si.jsxs("group", { ref: t, children: [
      /* @__PURE__ */ si.jsxs("mesh", { "position-x": -2, scale: 0.8, children: [
        /* @__PURE__ */ si.jsx("sphereGeometry", {}),
        /* @__PURE__ */ si.jsx("meshStandardMaterial", { color: "orange" })
      ] }),
      /* @__PURE__ */ si.jsxs("mesh", { "rotation-y": Math.PI * 0.25, "position-x": 2, scale: 1.5, children: [
        /* @__PURE__ */ si.jsx("boxGeometry", {}),
        /* @__PURE__ */ si.jsx("meshStandardMaterial", { color: "mediumpurple" })
      ] })
    ] }),
    /* @__PURE__ */ si.jsxs("mesh", { "position-y": -1.5, "rotation-x": -Math.PI * 0.5, scale: 10, children: [
      /* @__PURE__ */ si.jsx("planeGeometry", {}),
      /* @__PURE__ */ si.jsx("meshBasicMaterial", { color: "greenyellow" })
    ] })
  ] });
}
function zF() {
  return /* @__PURE__ */ si.jsx(
    TF,
    {
      camera: {
        fov: 45,
        near: 0.1,
        far: 200,
        position: [2, 2, 4]
      },
      children: /* @__PURE__ */ si.jsx(AF, {})
    }
  );
}
export {
  zF as default
};
